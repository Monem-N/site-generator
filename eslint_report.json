[
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/Builder.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_components' is defined but never used.",
        "line": 108,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 108,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { BuildConfig, ComponentTemplate } from '../types/index.js';\nimport type { InputOptions, OutputOptions, RollupBuild, ManualChunksOption } from 'rollup';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { rollup } from 'rollup';\nimport { nodeResolve } from '@rollup/plugin-node-resolve';\nimport { logger } from 'utils/logger.js';\n\n// Import these dynamically to avoid ESM issues\nlet babel;\nlet commonjs;\nlet terser;\nlet image;\nlet postcss;\nlet autoprefixer;\nlet cssnano;\n\n// Load plugins dynamically\nasync function loadPlugins() {\n  const babelModule = await import('@rollup/plugin-babel');\n  babel = babelModule.babel;\n\n  const commonjsModule = await import('@rollup/plugin-commonjs');\n  commonjs = commonjsModule.default;\n\n  const terserModule = await import('rollup-plugin-terser');\n  terser = terserModule.terser;\n\n  const imageModule = await import('@rollup/plugin-image');\n  image = imageModule.default;\n\n  const postcssModule = await import('rollup-plugin-postcss');\n  postcss = postcssModule.default;\n\n  const autoprefixerModule = await import('autoprefixer');\n  autoprefixer = autoprefixerModule.default;\n\n  const cssnanoModule = await import('cssnano');\n  cssnano = cssnanoModule.default;\n}\n\nexport class Builder {\n  private config: BuildConfig;\n\n  constructor(config: BuildConfig) {\n    this.config = config;\n  }\n\n  public async build(components: ComponentTemplate[]): Promise<void> {\n    try {\n      // 0. Load plugins\n      await loadPlugins();\n\n      // 1. Prepare output directory\n      await this.prepareOutputDirectory();\n\n      // 2. Generate entry points\n      const entryPoints = await this.generateEntryPoints(components);\n\n      // 3. Configure build\n      const buildConfig = this.createBuildConfig(entryPoints);\n\n      // 4. Execute build\n      await this.executeBuild(buildConfig);\n\n      // 5. Process assets\n      await this.processAssets();\n\n      // 6. Generate service worker if needed\n      if (this.config.optimization?.splitChunks) {\n        await this.generateServiceWorker();\n      }\n\n      logger.info('Build completed successfully!');\n    } catch (error) {\n      logger.error('Build failed:', { error });\n      throw error;\n    }\n  }\n\n  private async prepareOutputDirectory(): Promise<void> {\n    await fs.rm(this.config.outDir, { recursive: true, force: true });\n    await fs.mkdir(this.config.outDir, { recursive: true });\n  }\n\n  private async generateEntryPoints(components: ComponentTemplate[]): Promise<Map<string, string>> {\n    const entryPoints = new Map<string, string>();\n    const srcDir = path.join(this.config.outDir, 'src');\n    await fs.mkdir(srcDir, { recursive: true });\n\n    // Generate main entry point\n    const mainEntry = this.generateMainEntry(components);\n    await fs.writeFile(path.join(srcDir, 'index.tsx'), mainEntry, 'utf-8');\n    entryPoints.set('main', path.join(srcDir, 'index.tsx'));\n\n    // Generate component entry points for code splitting\n    if (this.config.optimization?.splitChunks) {\n      for (const component of components) {\n        const componentPath = path.join(srcDir, `${component.name}.tsx`);\n        await fs.writeFile(componentPath, component.content, 'utf-8');\n        entryPoints.set(component.name, componentPath);\n      }\n    }\n\n    return entryPoints;\n  }\n\n  private generateMainEntry(_components: ComponentTemplate[]): string {\n    return `import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App.js';\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n`;\n  }\n\n  private createBuildConfig(entryPoints: Map<string, string>): InputOptions {\n    const plugins = [\n      nodeResolve({\n        extensions: ['.js', '.jsx', '.ts', '.tsx'],\n      }),\n      commonjs(),\n      babel({\n        presets: ['@babel/preset-react', '@babel/preset-typescript'],\n        babelHelpers: 'bundled',\n      }),\n      postcss({\n        plugins: [autoprefixer(), this.config.optimization?.minify ? cssnano() : false].filter(\n          Boolean\n        ),\n        minimize: this.config.optimization?.minify,\n      }),\n      image(),\n    ];\n\n    if (this.config.optimization?.minify) {\n      plugins.push(terser());\n    }\n\n    return {\n      input: Object.fromEntries(entryPoints),\n      plugins,\n    } as InputOptions;\n  }\n\n  private generateChunkConfig(): ManualChunksOption {\n    return (id: string) => {\n      if (id.includes('node_modules')) {\n        return 'vendor';\n      }\n      return undefined;\n    };\n  }\n\n  private async executeBuild(config: InputOptions): Promise<void> {\n    const outputOptions: OutputOptions = {\n      dir: this.config.outDir,\n      format: 'esm',\n      sourcemap: true,\n      manualChunks: this.config.optimization?.splitChunks ? this.generateChunkConfig() : undefined,\n    };\n    const bundle: RollupBuild = await rollup(config as InputOptions);\n    bundle.write(outputOptions);\n    await bundle.close();\n  }\n\n  private async processAssets(): Promise<void> {\n    if (this.config.assets?.images?.optimize) {\n      await this.optimizeImages();\n    }\n\n    if (this.config.assets?.fonts?.preload) {\n      await this.processFonts();\n    }\n  }\n\n  private async optimizeImages(): Promise<void> {\n    const sharp = await import('sharp');\n    const assetsDir = path.join(this.config.outDir, 'assets');\n    const images = await fs.readdir(assetsDir);\n\n    for (const image of images) {\n      if (!/\\.(jpe?g|png|gif|webp)$/i.test(image)) continue;\n\n      // Process image with sharp\n      const imagePath = path.join(assetsDir, image);\n      const optimizedImage = await sharp\n        .default(imagePath)\n        .resize(1920, 1080, { fit: 'inside', withoutEnlargement: true })\n        .toFormat('webp', { quality: 80 })\n        .toBuffer();\n      await fs.writeFile(imagePath.replace(/\\.[^.]+$/, '.webp'), optimizedImage);\n    }\n  }\n\n  private async processFonts(): Promise<void> {\n    const fontsDir = path.join(this.config.outDir, 'fonts');\n    const fonts = await fs.readdir(fontsDir);\n\n    // Generate preload links for fonts\n    const preloadLinks = fonts\n      .filter(font => /\\.(woff2?)$/i.test(font))\n      .map(\n        font =>\n          `<link rel=\"preload\" href=\"/fonts/${font}\" as=\"font\" type=\"font/${font\n            .split('.')\n            .pop()}\" crossorigin>`\n      );\n\n    // Inject preload links into HTML\n    const htmlPath = path.join(this.config.outDir, 'index.html');\n    let html = await fs.readFile(htmlPath, 'utf-8');\n    html = html.replace('</head>', `${preloadLinks.join('\\n')}\\n</head>`);\n    await fs.writeFile(htmlPath, html, 'utf-8');\n  }\n\n  private async generateServiceWorker(): Promise<void> {\n    const workbox = await import('workbox-build');\n    await workbox.generateSW({\n      swDest: path.join(this.config.outDir, 'service-worker.js'),\n      globDirectory: this.config.outDir,\n      globPatterns: ['**/*.{js,css,html,png,jpg,jpeg,gif,svg,woff,woff2}'],\n      skipWaiting: true,\n      clientsClaim: true,\n      runtimeCaching: [\n        {\n          urlPattern: /\\.(?:png|jpg|jpeg|svg|gif)$/,\n          handler: 'CacheFirst',\n          options: {\n            cacheName: 'images',\n            expiration: {\n              maxEntries: 60,\n              maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days\n            },\n          },\n        },\n        {\n          urlPattern: /\\.(?:js|css)$/,\n          handler: 'StaleWhileRevalidate',\n          options: {\n            cacheName: 'static-resources',\n          },\n        },\n      ],\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/CMSIntegrationModule.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_options' is defined but never used.",
        "line": 16,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 65
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { createClient, ContentfulClientApi } from 'contentful';\nimport { ParsedContent } from '../types/parser.js';\nimport { logger } from 'utils/logger.js';\n\nexport class CMSIntegrationModule {\n  private client: ContentfulClientApi<unknown>;\n\n  constructor(spaceId: string, accessToken: string) {\n    this.client = createClient({\n      space: spaceId,\n      accessToken: accessToken,\n    });\n  }\n\n  // Implement the Parser interface's parse method\n  async parse(source: string, _options?: Record<string, unknown>): Promise<ParsedContent> {\n    try {\n      // Assuming source is an entry ID\n      return await this.getEntry(source);\n    } catch (error) {\n      logger.error('Error parsing Contentful entry:', error);\n      throw error;\n    }\n  }\n\n  async getEntry(entryId: string): Promise<ParsedContent> {\n    try {\n      const entry = await this.client.getEntry(entryId);\n\n      // Extract relevant information from Contentful entry\n      // Add type assertions for entry fields\n      const title = String(entry.fields.title || '');\n      const description = String(entry.fields.description || '');\n      const content = String(entry.fields.content || '');\n\n      // Structure the extracted information into ParsedContent format\n      const parsedContent: ParsedContent = {\n        title: title || 'Contentful Entry',\n        description: description || '',\n        metadata: {},\n        sections: [\n          {\n            type: 'section',\n            title: 'Content',\n            content: content || 'No content available.',\n          },\n        ],\n        assets: [],\n        references: [],\n      };\n\n      return parsedContent;\n    } catch (error) {\n      logger.error('Error fetching Contentful entry:', error);\n      throw error;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/DocsifyIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/DocsifyWebsiteGenerator.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/OpenAPIParser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/TestGenerator.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/WebsiteGenerator.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/Builder.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___dirPath' is defined but never used.",
        "line": 58,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 58,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___options' is defined but never used.",
        "line": 58,
        "column": 73,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 58,
        "endColumn": 83
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Insert `⏎······`",
        "line": 63,
        "column": 56,
        "nodeType": null,
        "messageId": "insert",
        "endLine": 63,
        "endColumn": 56,
        "fix": { "range": [1506, 1506], "text": "\n      " }
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___filePath' is defined but never used.",
        "line": 63,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 63,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___content' is defined but never used.",
        "line": 63,
        "column": 78,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 63,
        "endColumn": 96
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Insert `··`",
        "line": 64,
        "column": 7,
        "nodeType": null,
        "messageId": "insert",
        "endLine": 64,
        "endColumn": 7,
        "fix": { "range": [1559, 1559], "text": "  " }
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Replace `}` with `··}⏎····`",
        "line": 65,
        "column": 5,
        "nodeType": null,
        "messageId": "replace",
        "endLine": 65,
        "endColumn": 6,
        "fix": { "range": [1581, 1582], "text": "  }\n    " }
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__builder' is assigned a value but never used.",
        "line": 101,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 101,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__builder' is assigned a value but never used.",
        "line": 107,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 107,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__builder' is assigned a value but never used.",
        "line": 130,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 130,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__builder' is assigned a value but never used.",
        "line": 157,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 157,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__builder' is assigned a value but never used.",
        "line": 184,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 184,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__builder' is assigned a value but never used.",
        "line": 193,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 193,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__builder' is assigned a value but never used.",
        "line": 204,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 204,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__builder' is assigned a value but never used.",
        "line": 216,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 216,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__builder' is assigned a value but never used.",
        "line": 231,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 231,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 3,
    "fixableWarningCount": 0,
    "source": "import { Builder } from '../Builder.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('Builder', () => {\n  // Sample components for testing\n  const sampleComponents = [\n    {\n      name: 'Component1',\n      content: 'export const Component1 = () => <div>Component 1 Content</div>;',\n      metadata: {\n        originalPath: '/test/source/component1.md',\n      },\n    },\n    {\n      name: 'Component2',\n      content: 'export const Component2 = () => <div>Component 2 Content</div>;',\n      metadata: {\n        originalPath: '/test/source/component2.md',\n      },\n    },\n  ];\n\n  // Sample build options\n  const sampleBuildOptions = {\n    target: 'production',\n    outDir: '/test/output',\n    optimization: {\n      minify: true,\n      splitChunks: true,\n      treeshaking: true,\n    },\n    assets: {\n      images: {\n        optimize: true,\n        formats: ['webp'],\n      },\n      fonts: {\n        preload: true,\n        formats: ['woff2'],\n      },\n    },\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for output directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath === '/test/output';\n    });\n\n    // Mock fs.mkdirSync\n    (fs.mkdirSync as jest.Mock).mockImplementation((___dirPath: string, ___options) => {\n      return undefined;\n    });\n\n    // Mock fs.writeFileSync\n    (fs.writeFileSync as jest.Mock).mockImplementation((___filePath: string, ___content: string) => {\n      return undefined;\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock path.dirname to return the directory\n    (path.dirname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('/');\n      parts.pop();\n      return parts.join('/');\n    });\n\n    // Mock path.basename to return the filename\n    (path.basename as jest.Mock).mockImplementation((filePath: string, ext?: string) => {\n      const parts = filePath.split('/');\n      let filename = parts[parts.length - 1];\n      if (ext && filename.endsWith(ext)) {\n        filename = filename.slice(0, -ext.length);\n      }\n      return filename;\n    });\n  });\n\n  test('should initialize with valid options', () => {\n    const __builder = new Builder(sampleBuildOptions);\n    expect(__builder).toBeDefined();\n  });\n\n  test('should create output directory if it does not exist', () => {\n    // Mock fs.existsSync to return false for output directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath !== '/test/output';\n    });\n\n    const __builder = new Builder(sampleBuildOptions);\n\n    expect(fs.mkdirSync).toHaveBeenCalledWith('/test/output', { recursive: true });\n  });\n\n  test('should build components', async () => {\n    const __builder = new Builder(sampleBuildOptions);\n\n    await builder.build(sampleComponents);\n\n    // Should write component files\n    expect(fs.writeFileSync).toHaveBeenCalledTimes(sampleComponents.length);\n\n    // Check first component file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/Component1.js',\n      expect.stringContaining('Component 1 Content'),\n      'utf-8'\n    );\n\n    // Check second component file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/Component2.js',\n      expect.stringContaining('Component 2 Content'),\n      'utf-8'\n    );\n  });\n\n  test('should apply minification when enabled', async () => {\n    const __builder = new Builder({\n      ...sampleBuildOptions,\n      optimization: {\n        ...sampleBuildOptions.optimization,\n        minify: true,\n      },\n    });\n\n    // Mock the minify method\n    builder.minify = jest.fn().mockImplementation((content: string) => {\n      return `/* minified */ ${content}`;\n    });\n\n    await builder.build(sampleComponents);\n\n    // Should call minify for each component\n    expect(builder.minify).toHaveBeenCalledTimes(sampleComponents.length);\n\n    // Check that minified content is written\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/Component1.js',\n      expect.stringContaining('/* minified */'),\n      'utf-8'\n    );\n  });\n\n  test('should not apply minification when disabled', async () => {\n    const __builder = new Builder({\n      ...sampleBuildOptions,\n      optimization: {\n        ...sampleBuildOptions.optimization,\n        minify: false,\n      },\n    });\n\n    // Mock the minify method\n    builder.minify = jest.fn().mockImplementation((content: string) => {\n      return `/* minified */ ${content}`;\n    });\n\n    await builder.build(sampleComponents);\n\n    // Should not call minify\n    expect(builder.minify).not.toHaveBeenCalled();\n\n    // Check that original content is written\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/Component1.js',\n      expect.not.stringContaining('/* minified */'),\n      'utf-8'\n    );\n  });\n\n  test('should handle empty component list', async () => {\n    const __builder = new Builder(sampleBuildOptions);\n\n    await builder.build([]);\n\n    // Should not write any files\n    expect(fs.writeFileSync).not.toHaveBeenCalled();\n  });\n\n  test('should handle errors during build', async () => {\n    const __builder = new Builder(sampleBuildOptions);\n\n    // Mock fs.writeFileSync to throw an error\n    (fs.writeFileSync as jest.Mock).mockImplementation(() => {\n      throw new Error('Write error');\n    });\n\n    await expect(builder.build(sampleComponents)).rejects.toThrow('Write error');\n  });\n\n  test('should optimize assets when enabled', async () => {\n    const __builder = new Builder(sampleBuildOptions);\n\n    // Mock the optimizeAssets method\n    builder.optimizeAssets = jest.fn().mockResolvedValue(undefined);\n\n    await builder.build(sampleComponents);\n\n    // Should call optimizeAssets\n    expect(builder.optimizeAssets).toHaveBeenCalled();\n  });\n\n  test('should not optimize assets when disabled', async () => {\n    const __builder = new Builder({\n      ...sampleBuildOptions,\n      assets: undefined,\n    });\n\n    // Mock the optimizeAssets method\n    builder.optimizeAssets = jest.fn().mockResolvedValue(undefined);\n\n    await builder.build(sampleComponents);\n\n    // Should not call optimizeAssets\n    expect(builder.optimizeAssets).not.toHaveBeenCalled();\n  });\n\n  test('should generate index file', async () => {\n    const __builder = new Builder(sampleBuildOptions);\n\n    await builder.build(sampleComponents);\n\n    // Should write index file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/index.js',\n      expect.stringContaining('export'),\n      'utf-8'\n    );\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/DocsifyWebsiteGenerator.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____ParsedContent' is defined but never used.",
        "line": 5,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___options' is defined but never used.",
        "line": 136,
        "column": 69,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 136,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___filePath' is defined but never used.",
        "line": 159,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 159,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___content' is defined but never used.",
        "line": 159,
        "column": 74,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 159,
        "endColumn": 92
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___src' is defined but never used.",
        "line": 164,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 164,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___dest' is defined but never used.",
        "line": 164,
        "column": 68,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 164,
        "endColumn": 83
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { DocsifyWebsiteGenerator } from '../DocsifyWebsiteGenerator.js';\nimport { WebsiteGeneratorConfig } from '../../config/generator.config.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { ____ParsedContent } from '../../types/parser.js';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\njest.mock('../WebsiteGenerator');\njest.mock('../utils/cache');\n\n// Create a minimal test configuration\nconst createTestConfig = (): WebsiteGeneratorConfig => ({\n  projectName: 'test-docsify-project',\n  sourceDir: '/test/source',\n  outputDir: '/test/output',\n\n  parser: {\n    extensions: ['md'],\n    ignorePatterns: ['node_modules'],\n    plugins: [],\n  },\n\n  generator: {\n    templates: {\n      page: '/test/templates/page.tsx',\n      section: '/test/templates/section.tsx',\n    },\n    componentNaming: {\n      style: 'PascalCase',\n    },\n  },\n\n  designSystem: {\n    type: 'custom',\n    name: 'vue',\n    importPath: '/test/themes',\n    components: {\n      Button: {\n        import: '/test/themes/Button',\n      },\n    },\n    styles: {\n      global: '/test/themes/global.css',\n    },\n  },\n\n  testing: {\n    framework: 'jest',\n    coverage: {\n      enabled: true,\n      threshold: 80,\n    },\n    components: {\n      unit: true,\n      integration: true,\n    },\n  },\n\n  build: {\n    optimization: {\n      minify: true,\n      splitChunks: true,\n      treeshaking: true,\n    },\n    assets: {\n      images: {\n        optimize: true,\n        formats: ['webp'],\n      },\n      fonts: {\n        preload: true,\n        formats: ['woff2'],\n      },\n    },\n  },\n\n  performance: {\n    lazyLoading: true,\n    prefetching: true,\n    caching: {\n      enabled: true,\n      strategy: 'memory',\n    },\n  },\n\n  accessibility: {\n    wcag: {\n      level: 'AA',\n      automated: true,\n    },\n    aria: true,\n    keyboard: true,\n  },\n});\n\ndescribe('DocsifyWebsiteGenerator', () => {\n  // Mock file system data\n  const mockFiles = {\n    '/test/source/README.md': '# Home Page\\n\\nWelcome to the documentation',\n    '/test/source/_sidebar.md': '* [Home](/)\\n* [Guide](guide.md)',\n    '/test/source/guide.md': '# Guide\\n\\nThis is a guide',\n    '/test/source/_navbar.md': '* [Home](/)\\n* [External](https://example.com)',\n    '/test/source/.nojekyll': '',\n    '/test/source/index.html': '<!DOCTYPE html><html><head></head><body></body></html>',\n  };\n\n  // Reset mocks before each test\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for directories and mock files\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath in mockFiles) return true;\n      if (filePath === '/test/source' || filePath === '/test/output') return true;\n      return false;\n    });\n\n    // Mock path.resolve to return the input path\n    (path.resolve as jest.Mock).mockImplementation((filePath: string) => filePath);\n\n    // Mock path.extname to return the correct extension\n    (path.extname as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.md')) return '.md';\n      if (filePath.endsWith('.html')) return '.html';\n      return '';\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) =>\n      paths.join('/').replace(/\\/+/g, '/')\n    );\n\n    // Mock fs.readdir to return mock directory contents\n    (fs.readdir as jest.Mock).mockImplementation((_dirPath: string, ___options) => {\n      if (_dirPath === '/test/source') {\n        return Promise.resolve([\n          { name: 'README.md', isDirectory: () => false },\n          { name: '_sidebar.md', isDirectory: () => false },\n          { name: 'guide.md', isDirectory: () => false },\n          { name: '_navbar.md', isDirectory: () => false },\n          { name: '.nojekyll', isDirectory: () => false },\n          { name: 'index.html', isDirectory: () => false },\n        ]);\n      }\n      return Promise.resolve([]);\n    });\n\n    // Mock fs.readFile to return mock file contents\n    (fs.readFile as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath in mockFiles) {\n        return Promise.resolve(mockFiles[filePath]);\n      }\n      return Promise.reject(new Error(`File not found: ${filePath}`));\n    });\n\n    // Mock fs.writeFile\n    (fs.writeFile as jest.Mock).mockImplementation((___filePath: string, ___content: string) => {\n      return Promise.resolve();\n    });\n\n    // Mock fs.copyFile\n    (fs.copyFile as jest.Mock).mockImplementation((___src: string, ___dest: string) => {\n      return Promise.resolve();\n    });\n  });\n\n  test('should initialize with valid configuration', () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    expect(generator).toBeDefined();\n  });\n\n  test('should set Docsify-specific configuration', () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Access the protected docsifyConfig property using type assertion\n    const docsifyConfig = (generator as unknown).docsifyConfig;\n\n    expect(docsifyConfig).toBeDefined();\n    expect(docsifyConfig.name).toBe(config.projectName);\n    expect(docsifyConfig.repo).toBe('');\n    expect(docsifyConfig.coverpage).toBe(false);\n    expect(docsifyConfig.loadSidebar).toBe(true);\n    expect(docsifyConfig.loadNavbar).toBe(true);\n    expect(docsifyConfig.auto2top).toBe(true);\n    expect(docsifyConfig.maxLevel).toBe(4);\n    expect(docsifyConfig.subMaxLevel).toBe(2);\n    expect(docsifyConfig.themeColor).toBe('#3F51B5');\n  });\n\n  test('should customize Docsify configuration with options', () => {\n    const config = createTestConfig();\n    const docsifyOptions = {\n      name: 'Custom Name',\n      repo: 'user/repo',\n      coverpage: true,\n      themeColor: '#FF5722',\n      maxLevel: 3,\n      subMaxLevel: 3,\n    };\n\n    const generator = new DocsifyWebsiteGenerator(config, docsifyOptions);\n\n    // Access the protected docsifyConfig property using type assertion\n    const docsifyConfig = (generator as unknown).docsifyConfig;\n\n    expect(docsifyConfig.name).toBe('Custom Name');\n    expect(docsifyConfig.repo).toBe('user/repo');\n    expect(docsifyConfig.coverpage).toBe(true);\n    expect(docsifyConfig.themeColor).toBe('#FF5722');\n    expect(docsifyConfig.maxLevel).toBe(3);\n    expect(docsifyConfig.subMaxLevel).toBe(3);\n  });\n\n  test('should generate Docsify index.html', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    // Mock the generateDocsifyFiles method to call the real implementation\n    const originalGenerateDocsifyFiles = (generator as unknown).generateDocsifyFiles;\n    (generator as unknown).generateDocsifyFiles = jest.fn().mockImplementation(async () => {\n      return await originalGenerateDocsifyFiles.call(generator);\n    });\n\n    await generator.generate();\n\n    // Verify that generateDocsifyFiles was called\n    expect((generator as unknown).generateDocsifyFiles).toHaveBeenCalled();\n\n    // Verify that fs.writeFile was called for index.html\n    expect(fs.writeFile).toHaveBeenCalledWith(\n      '/test/output/index.html',\n      expect.stringContaining('<!DOCTYPE html>'),\n      'utf-8'\n    );\n\n    // Verify that the index.html contains Docsify configuration\n    const indexHtmlCall = (fs.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/output/index.html'\n    );\n\n    const indexHtmlContent = indexHtmlCall ? indexHtmlCall[1] : '';\n    expect(indexHtmlContent).toContain('window.$docsify');\n    expect(indexHtmlContent).toContain(config.projectName);\n  });\n\n  test('should copy Docsify-specific files', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that fs.copyFile was called for .nojekyll\n    expect(fs.copyFile).toHaveBeenCalledWith('/test/source/.nojekyll', '/test/output/.nojekyll');\n\n    // Verify that fs.copyFile was called for _sidebar.md\n    expect(fs.copyFile).toHaveBeenCalledWith(\n      '/test/source/_sidebar.md',\n      '/test/output/_sidebar.md'\n    );\n\n    // Verify that fs.copyFile was called for _navbar.md\n    expect(fs.copyFile).toHaveBeenCalledWith('/test/source/_navbar.md', '/test/output/_navbar.md');\n  });\n\n  test('should create .nojekyll file if it does not exist', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock fs.existsSync to return false for .nojekyll\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath === '/test/source/.nojekyll') return false;\n      if (filePath in mockFiles) return true;\n      if (filePath === '/test/source' || filePath === '/test/output') return true;\n      return false;\n    });\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that fs.writeFile was called for .nojekyll\n    expect(fs.writeFile).toHaveBeenCalledWith('/test/output/.nojekyll', '', 'utf-8');\n  });\n\n  test('should create _sidebar.md if it does not exist', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock fs.existsSync to return false for _sidebar.md\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath === '/test/source/_sidebar.md') return false;\n      if (filePath in mockFiles) return true;\n      if (filePath === '/test/source' || filePath === '/test/output') return true;\n      return false;\n    });\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([\n      {\n        title: 'Home Page',\n        content: 'Welcome to the documentation',\n        sections: [],\n        metadata: { originalPath: '/test/source/README.md' },\n      },\n      {\n        title: 'Guide',\n        content: 'This is a guide',\n        sections: [],\n        metadata: { originalPath: '/test/source/guide.md' },\n      },\n    ]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that fs.writeFile was called for _sidebar.md\n    expect(fs.writeFile).toHaveBeenCalledWith(\n      '/test/output/_sidebar.md',\n      expect.stringContaining('* [Home Page](/)'),\n      'utf-8'\n    );\n  });\n\n  test('should apply Docsify theme', async () => {\n    const config = createTestConfig();\n    config.designSystem.name = 'dark';\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that the index.html contains the dark theme\n    const indexHtmlCall = (fs.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/output/index.html'\n    );\n\n    const indexHtmlContent = indexHtmlCall ? indexHtmlCall[1] : '';\n    expect(indexHtmlContent).toContain('theme-dark.css');\n  });\n\n  test('should add Docsify plugins', async () => {\n    const config = createTestConfig();\n    config.plugins = [{ name: 'search' }, { name: 'copy-code' }, { name: 'zoom-image' }];\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that the index.html contains the plugins\n    const indexHtmlCall = (fs.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/output/index.html'\n    );\n\n    const indexHtmlContent = indexHtmlCall ? indexHtmlCall[1] : '';\n    expect(indexHtmlContent).toContain('docsify-search.min.js');\n    expect(indexHtmlContent).toContain('docsify-copy-code.min.js');\n    expect(indexHtmlContent).toContain('zoom-image.min.js');\n  });\n\n  test('should handle errors during Docsify file generation', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock fs.writeFile to throw an error\n    (fs.writeFile as jest.Mock).mockRejectedValue(new Error('Write error'));\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await expect(generator.generate()).rejects.toThrow('Write error');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/TestGenerator.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___dirPath' is defined but never used.",
        "line": 53,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 53,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___options' is defined but never used.",
        "line": 53,
        "column": 73,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 53,
        "endColumn": 83
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Insert `⏎······`",
        "line": 58,
        "column": 56,
        "nodeType": null,
        "messageId": "insert",
        "endLine": 58,
        "endColumn": 56,
        "fix": { "range": [1570, 1570], "text": "\n      " }
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___filePath' is defined but never used.",
        "line": 58,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 58,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___content' is defined but never used.",
        "line": 58,
        "column": 78,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 58,
        "endColumn": 96
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Insert `··`",
        "line": 59,
        "column": 7,
        "nodeType": null,
        "messageId": "insert",
        "endLine": 59,
        "endColumn": 7,
        "fix": { "range": [1623, 1623], "text": "  " }
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Replace `}` with `··}⏎····`",
        "line": 60,
        "column": 5,
        "nodeType": null,
        "messageId": "replace",
        "endLine": 60,
        "endColumn": 6,
        "fix": { "range": [1645, 1646], "text": "  }\n    " }
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__testGenerator' is assigned a value but never used.",
        "line": 96,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 96,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__testGenerator' is assigned a value but never used.",
        "line": 102,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 102,
        "endColumn": 26
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 3,
    "fixableWarningCount": 0,
    "source": "import { TestGenerator } from '../TestGenerator.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('TestGenerator', () => {\n  // Sample components for testing\n  const sampleComponents = [\n    {\n      name: 'Component1',\n      content: 'export const Component1 = () => <div>Component 1 Content</div>;',\n      path: '/test/source/components/Component1.tsx',\n      metadata: {\n        originalPath: '/test/source/component1.md',\n      },\n    },\n    {\n      name: 'Component2',\n      content: 'export const Component2 = () => <div>Component 2 Content</div>;',\n      path: '/test/source/components/Component2.tsx',\n      metadata: {\n        originalPath: '/test/source/component2.md',\n      },\n    },\n  ];\n\n  // Sample test options\n  const sampleTestOptions = {\n    framework: 'jest' as 'jest' | 'vitest', // Type assertion to fix the error\n    coverage: {\n      enabled: true,\n      threshold: 80,\n    },\n    components: {\n      unit: true,\n      integration: true,\n    },\n    outputDir: '/test/output/__tests__',\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for output directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath === '/test/output/__tests__';\n    });\n\n    // Mock fs.mkdirSync\n    (fs.mkdirSync as jest.Mock).mockImplementation((___dirPath: string, ___options) => {\n      return undefined;\n    });\n\n    // Mock fs.writeFileSync\n    (fs.writeFileSync as jest.Mock).mockImplementation((___filePath: string, ___content: string) => {\n      return undefined;\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock path.dirname to return the directory\n    (path.dirname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('/');\n      parts.pop();\n      return parts.join('/');\n    });\n\n    // Mock path.basename to return the filename\n    (path.basename as jest.Mock).mockImplementation((filePath: string, ext?: string) => {\n      const parts = filePath.split('/');\n      let filename = parts[parts.length - 1];\n      if (ext && filename.endsWith(ext)) {\n        filename = filename.slice(0, -ext.length);\n      }\n      return filename;\n    });\n  });\n\n  test('should initialize with valid options', () => {\n    const __testGenerator = new TestGenerator(sampleTestOptions);\n    expect(__testGenerator).toBeDefined();\n  });\n\n  test('should create output directory if it does not exist', () => {\n    // Mock fs.existsSync to return false for output directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath !== '/test/output/__tests__';\n    });\n\n    const __testGenerator = new TestGenerator(sampleTestOptions);\n\n    expect(fs.mkdirSync).toHaveBeenCalledWith('/test/output/__tests__', { recursive: true });\n  });\n\n  test('should generate unit tests for components', async () => {\n    const __testGenerator = new TestGenerator(sampleTestOptions);\n\n    await testGenerator.generateTests(sampleComponents);\n\n    // Should write test files\n    expect(fs.writeFileSync).toHaveBeenCalledTimes(sampleComponents.length);\n\n    // Check first component test file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/Component1.test.js',\n      expect.stringContaining('test('),\n      'utf-8'\n    );\n\n    // Check second component test file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/Component2.test.js',\n      expect.stringContaining('test('),\n      'utf-8'\n    );\n  });\n\n  test('should not generate unit tests when disabled', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      components: {\n        ...sampleTestOptions.components,\n        unit: false,\n      },\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Should not write any unit test files\n    expect(fs.writeFileSync).not.toHaveBeenCalled();\n  });\n\n  test('should generate integration tests when enabled', async () => {\n    const generator = new TestGenerator(sampleTestOptions);\n\n    await generator.generateTests(sampleComponents);\n\n    // Should write integration test file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/integration.test.js',\n      expect.stringContaining('integration'),\n      'utf-8'\n    );\n  });\n\n  test('should not generate integration tests when disabled', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      components: {\n        ...sampleTestOptions.components,\n        integration: false,\n      },\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Should not write integration test file\n    expect(fs.writeFileSync).not.toHaveBeenCalledWith(\n      '/test/output/__tests__/integration.test.js',\n      expect.any(String),\n      'utf-8'\n    );\n  });\n\n  test('should handle empty component list', async () => {\n    const generator = new TestGenerator(sampleTestOptions);\n\n    await generator.generateTests([]);\n\n    // Should not write any files\n    expect(fs.writeFileSync).not.toHaveBeenCalled();\n  });\n\n  test('should handle errors during test generation', async () => {\n    const generator = new TestGenerator(sampleTestOptions);\n\n    // Mock fs.writeFileSync to throw an error\n    (fs.writeFileSync as jest.Mock).mockImplementation(() => {\n      throw new Error('Write error');\n    });\n\n    await expect(generator.generateTests(sampleComponents)).rejects.toThrow('Write error');\n  });\n\n  test('should generate Jest tests when framework is Jest', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      framework: 'jest',\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Check that Jest syntax is used\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/Component1.test.js',\n      expect.stringContaining('describe('),\n      'utf-8'\n    );\n  });\n\n  test('should generate Vitest tests when framework is Vitest', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      framework: 'vitest',\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Check that Vitest syntax is used\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/Component1.test.js',\n      expect.stringContaining('import { describe, it, expect }'),\n      'utf-8'\n    );\n  });\n\n  test('should include coverage threshold when enabled', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      coverage: {\n        enabled: true,\n        threshold: 90,\n      },\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Check that coverage threshold is included\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      expect.any(String),\n      expect.stringContaining('90'),\n      'utf-8'\n    );\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/WebsiteGenerator.test.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'generator' is assigned a value but never used.",
        "line": 242,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 242,
        "endColumn": 20,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'generator' is assigned a value but never used.",
        "line": 251,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 251,
        "endColumn": 20,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/components/ComponentGenerator.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/navigation/NavigationGenerator.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_fs' is defined but never used.",
        "line": 3,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 16
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { NavigationGenerator } from '../../navigation/NavigationGenerator.js';\nimport { ParsedContent } from '../../../types/parser.js';\nimport * as _fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('NavigationGenerator', () => {\n  // Sample parsed content\n  const sampleParsedContent: ParsedContent[] = [\n    {\n      title: 'Home',\n      content: 'Home page content',\n      sections: [\n        {\n          level: 1,\n          title: 'Home',\n          content: 'Home page content',\n        },\n      ],\n      metadata: {\n        originalPath: '/test/source/index.md',\n      },\n    },\n    {\n      title: 'Getting Started',\n      content: 'Getting started guide',\n      sections: [\n        {\n          level: 1,\n          title: 'Getting Started',\n          content: 'Getting started guide',\n        },\n        {\n          level: 2,\n          title: 'Installation',\n          content: 'Installation instructions',\n        },\n        {\n          level: 2,\n          title: 'Configuration',\n          content: 'Configuration instructions',\n        },\n      ],\n      metadata: {\n        originalPath: '/test/source/getting-started.md',\n      },\n    },\n    {\n      title: 'API Reference',\n      content: 'API documentation',\n      sections: [\n        {\n          level: 1,\n          title: 'API Reference',\n          content: 'API documentation',\n        },\n      ],\n      metadata: {\n        originalPath: '/test/source/api/index.md',\n      },\n    },\n    {\n      title: 'Users API',\n      content: 'Users API documentation',\n      sections: [\n        {\n          level: 1,\n          title: 'Users API',\n          content: 'Users API documentation',\n        },\n        {\n          level: 2,\n          title: 'Get Users',\n          content: 'Get users endpoint',\n        },\n        {\n          level: 2,\n          title: 'Create User',\n          content: 'Create user endpoint',\n        },\n      ],\n      metadata: {\n        originalPath: '/test/source/api/users.md',\n      },\n    },\n  ];\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock path.dirname to return the directory\n    (path.dirname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('/');\n      parts.pop();\n      return parts.join('/');\n    });\n\n    // Mock path.basename to return the filename\n    (path.basename as jest.Mock).mockImplementation((filePath: string, ext?: string) => {\n      const parts = filePath.split('/');\n      let filename = parts[parts.length - 1];\n      if (ext && filename.endsWith(ext)) {\n        filename = filename.slice(0, -ext.length);\n      }\n      return filename;\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock path.relative to return relative path\n    (path.relative as jest.Mock).mockImplementation((from: string, to: string) => {\n      // Simple implementation for test purposes\n      const paths: Record<string, string> = {\n        '/test/source/index.md': 'index.md',\n        '/test/source/getting-started.md': 'getting-started.md',\n        '/test/source/api/index.md': 'api/index.md',\n        '/test/source/api/users.md': 'api/users.md',\n      };\n\n      if (_from === '/test/source' && to in paths) {\n        return paths[to];\n      }\n\n      return to.replace(from + '/', '');\n    });\n  });\n\n  test('should initialize with default options', () => {\n    const generator = new NavigationGenerator('/test/source');\n    expect(generator).toBeDefined();\n  });\n\n  test('should initialize with custom options', () => {\n    const options = {\n      maxDepth: 3,\n      includeIndex: true,\n      sortByTitle: true,\n    };\n\n    const generator = new NavigationGenerator('/test/source', options);\n    expect(generator.options).toEqual(options);\n  });\n\n  test('should generate navigation from parsed content', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    expect(navigation).toBeDefined();\n    expect(navigation.items).toBeDefined();\n    expect(navigation.items.length).toBeGreaterThan(0);\n  });\n\n  test('should organize navigation by directory structure', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check top-level items\n    expect(navigation.items.length).toBe(3); // Home, Getting Started, API\n\n    // Check that API has children\n    const apiItem = navigation.items.find(item => item.title === 'API Reference');\n    expect(apiItem).toBeDefined();\n    expect(apiItem?.children).toBeDefined();\n    expect(apiItem?.children?.length).toBe(1); // Users API\n\n    // Check API children\n    const usersApiItem = apiItem?.children?.[0];\n    expect(usersApiItem?.title).toBe('Users API');\n  });\n\n  test('should handle index files correctly', () => {\n    const generator = new NavigationGenerator('/test/source', { includeIndex: true });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that index files are included\n    const homeItem = navigation.items.find(item => item.title === 'Home');\n    expect(homeItem).toBeDefined();\n\n    const apiItem = navigation.items.find(item => item.title === 'API Reference');\n    expect(apiItem).toBeDefined();\n  });\n\n  test('should exclude index files when configured', () => {\n    const generator = new NavigationGenerator('/test/source', { includeIndex: false });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that index files are excluded\n    const homeItem = navigation.items.find(item => item.title === 'Home');\n    expect(homeItem).toBeUndefined();\n\n    // API Reference should still be included because it has children\n    const apiItem = navigation.items.find(item => item.title === 'API Reference');\n    expect(apiItem).toBeDefined();\n  });\n\n  test('should limit navigation depth', () => {\n    const generator = new NavigationGenerator('/test/source', { maxDepth: 1 });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that only top-level items are included\n    expect(navigation.items.length).toBeGreaterThan(0);\n\n    // Check that no items have children\n    for (const item of navigation.items) {\n      expect(item.children).toBeUndefined();\n    }\n  });\n\n  test('should sort navigation items by title', () => {\n    const generator = new NavigationGenerator('/test/source', { sortByTitle: true });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that items are sorted alphabetically\n    const titles = navigation.items.map(item => item.title);\n    const sortedTitles = [...titles].sort();\n    expect(titles).toEqual(sortedTitles);\n  });\n\n  test('should sort navigation items by filename when not sorting by title', () => {\n    const generator = new NavigationGenerator('/test/source', { sortByTitle: false });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that items are in the original order\n    expect(navigation.items[0].title).toBe('Home');\n    expect(navigation.items[1].title).toBe('Getting Started');\n    expect(navigation.items[2].title).toBe('API Reference');\n  });\n\n  test('should generate navigation links correctly', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check links\n    const homeItem = navigation.items.find(item => item.title === 'Home');\n    expect(homeItem?.link).toBe('/');\n\n    const gettingStartedItem = navigation.items.find(item => item.title === 'Getting Started');\n    expect(gettingStartedItem?.link).toBe('/getting-started');\n\n    const apiItem = navigation.items.find(item => item.title === 'API Reference');\n    expect(apiItem?.link).toBe('/api/');\n\n    const usersApiItem = apiItem?.children?.[0];\n    expect(usersApiItem?.link).toBe('/api/users');\n  });\n\n  test('should handle empty content list', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation([]);\n\n    expect(navigation).toBeDefined();\n    expect(navigation.items).toEqual([]);\n  });\n\n  test('should handle content without originalPath', () => {\n    const contentWithoutPath: ParsedContent[] = [\n      {\n        title: 'No Path',\n        content: 'Content without path',\n        sections: [],\n        metadata: {},\n      },\n    ];\n\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation(contentWithoutPath);\n\n    // Content without path should be excluded\n    expect(navigation.items).toEqual([]);\n  });\n\n  test('should generate sidebar navigation', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const sidebar = generator.generateSidebar(sampleParsedContent);\n\n    expect(sidebar).toBeDefined();\n    expect(sidebar).toContain('* [Home](/)');\n    expect(sidebar).toContain('* [Getting Started](/getting-started)');\n    expect(sidebar).toContain('* [API Reference](/api/)');\n    expect(sidebar).toContain('  * [Users API](/api/users)');\n  });\n\n  test('should generate navbar navigation', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navbar = generator.generateNavbar(sampleParsedContent);\n\n    expect(navbar).toBeDefined();\n    expect(navbar).toContain('* [Home](/)');\n    expect(navbar).toContain('* [Getting Started](/getting-started)');\n    expect(navbar).toContain('* [API Reference](/api/)');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/parsers/DocsifyMarkdownParser.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____ParsedContent' is defined but never used.",
        "line": 2,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____logger' is defined but never used.",
        "line": 3,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___filePath' is defined but never used.",
        "line": 193,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 193,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___filePath' is defined but never used.",
        "line": 210,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 210,
        "endColumn": 72
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { DocsifyMarkdownParser } from '../../parsers/DocsifyMarkdownParser.js';\nimport { ____ParsedContent } from '../../../types/parser.js';\nimport { ____logger } from '../../utils/logger.js';\n\ndescribe('DocsifyMarkdownParser', () => {\n  let parser: DocsifyMarkdownParser;\n\n  beforeEach(() => {\n    parser = new DocsifyMarkdownParser();\n  });\n\n  test('should parse basic markdown', async () => {\n    const markdown = '# Hello World\\n\\nThis is a test.';\n    const result = await parser.parse(markdown);\n\n    expect(result.title).toBe('Hello World');\n    expect(result.sections.length).toBe(1);\n    expect(result.sections[0].title).toBe('Hello World');\n    expect(result.sections[0].content).toContain('This is a test.');\n  });\n\n  test('should extract frontmatter', async () => {\n    const markdown = `---\ntitle: Custom Title\ndescription: Custom description\n---\n\n# Hello World\n\nThis is a test.`;\n\n    const result = await parser.parse(markdown);\n\n    expect(result.title).toBe('Custom Title');\n    expect(result.description).toBe('Custom description');\n    expect(result.metadata.title).toBe('Custom Title');\n    expect(result.metadata.description).toBe('Custom description');\n  });\n\n  test('should extract assets', async () => {\n    const markdown = '# Hello World\\n\\n![Image](image.png)\\n\\nThis is a test.';\n    const result = await parser.parse(markdown);\n\n    expect(result.assets.length).toBe(1);\n    expect(result.assets[0].type).toBe('image');\n    expect(result.assets[0].path).toBe('image.png');\n    expect(result.assets[0].metadata.altText).toBe('Image');\n  });\n\n  test('should extract references', async () => {\n    const markdown = '# Hello World\\n\\n[Link](https://example.com)\\n\\nThis is a test.';\n    const result = await parser.parse(markdown);\n\n    expect(result.references.length).toBe(1);\n    expect(result.references[0].type).toBe('external');\n    expect(result.references[0].target).toBe('https://example.com');\n    expect(result.references[0].attributes.text).toBe('Link');\n  });\n\n  test('should handle multiple sections with different heading levels', async () => {\n    const markdown = `# Main Title\n\nMain content.\n\n## Section 1\n\nSection 1 content.\n\n### Subsection 1.1\n\nSubsection 1.1 content.\n\n## Section 2\n\nSection 2 content.`;\n\n    const result = await parser.parse(markdown);\n\n    expect(result.sections.length).toBe(4);\n    expect(result.sections[0].level).toBe(1);\n    expect(result.sections[0].title).toBe('Main Title');\n    expect(result.sections[1].level).toBe(2);\n    expect(result.sections[1].title).toBe('Section 1');\n    expect(result.sections[2].level).toBe(3);\n    expect(result.sections[2].title).toBe('Subsection 1.1');\n    expect(result.sections[3].level).toBe(2);\n    expect(result.sections[3].title).toBe('Section 2');\n  });\n\n  test('should handle code blocks correctly', async () => {\n    const markdown = `# Code Example\n\n\\`\\`\\`javascript\nconst hello = 'world';\nlogger.debug(hello);\n\\`\\`\\`\n\nRegular text.`;\n\n    const result = await parser.parse(markdown);\n\n    expect(result.sections[0].content).toContain('```javascript');\n    expect(result.sections[0].content).toContain(\"const hello = 'world';\");\n    expect(result.sections[0].content).toContain('logger.debug(hello);');\n    expect(result.sections[0].content).toContain('```');\n  });\n\n  test('should handle Docsify-specific syntax', async () => {\n    const markdown = `# Docsify Features\n\n<!-- {docsify-ignore} -->\n\n?> This is a tip\n\n!> This is a warning\n\n[toc]\n\n[Link Text](guide.md#anchor)`;\n\n    const result = await parser.parse(markdown);\n\n    expect(result.sections[0].content).toContain('<!-- {docsify-ignore} -->');\n    expect(result.sections[0].content).toContain('?> This is a tip');\n    expect(result.sections[0].content).toContain('!> This is a warning');\n    expect(result.sections[0].content).toContain('[toc]');\n    // Docsify transforms relative links to hash-based routing\n    expect(result.sections[0].content).toContain('[Link Text](#/guide#anchor)');\n  });\n\n  test('should handle empty or invalid markdown', async () => {\n    const emptyMarkdown = '';\n    const result = await parser.parse(emptyMarkdown);\n\n    expect(result.title).toBe('');\n    expect(result.content).toBe('');\n    expect(result.sections.length).toBe(0);\n  });\n\n  test('should handle markdown with only frontmatter', async () => {\n    const markdownWithOnlyFrontmatter = `---\ntitle: Just Frontmatter\ndescription: No content\n---`;\n\n    const result = await parser.parse(markdownWithOnlyFrontmatter);\n\n    expect(result.title).toBe('Just Frontmatter');\n    expect(result.description).toBe('No content');\n    expect(result.content).toBe('');\n    expect(result.sections.length).toBe(0);\n  });\n\n  test('should handle markdown with tables', async () => {\n    const markdownWithTable = `# Table Example\n\n| Header 1 | Header 2 |\n| -------- | -------- |\n| Cell 1   | Cell 2   |\n| Cell 3   | Cell 4   |`;\n\n    const result = await parser.parse(markdownWithTable);\n\n    expect(result.sections[0].content).toContain('| Header 1 | Header 2 |');\n    expect(result.sections[0].content).toContain('| -------- | -------- |');\n    expect(result.sections[0].content).toContain('| Cell 1   | Cell 2   |');\n    expect(result.sections[0].content).toContain('| Cell 3   | Cell 4   |');\n  });\n\n  test('should handle markdown with lists', async () => {\n    const markdownWithLists = `# Lists Example\n\n- Item 1\n- Item 2\n  - Nested Item 1\n  - Nested Item 2\n- Item 3\n\n1. Ordered Item 1\n2. Ordered Item 2\n3. Ordered Item 3`;\n\n    const result = await parser.parse(markdownWithLists);\n\n    expect(result.sections[0].content).toContain('- Item 1');\n    expect(result.sections[0].content).toContain('  - Nested Item 1');\n    expect(result.sections[0].content).toContain('1. Ordered Item 1');\n  });\n\n  test('should handle file paths correctly', async () => {\n    // Mock the parser's file handling methods\n    const originalReadFile = parser.readFile;\n    parser.readFile = jest.fn().mockImplementation((___filePath: string) => {\n      return '# File Content\\n\\nThis is content from a file.';\n    });\n\n    const result = await parser.parseFile('/path/to/document.md');\n\n    expect(result.title).toBe('File Content');\n    expect(result.content).toContain('This is content from a file.');\n    expect(result.metadata.originalPath).toBe('/path/to/document.md');\n\n    // Restore original method\n    parser.readFile = originalReadFile;\n  });\n\n  test('should handle errors gracefully', async () => {\n    // Mock the parser's file handling methods to throw an error\n    const originalReadFile = parser.readFile;\n    parser.readFile = jest.fn().mockImplementation((___filePath: string) => {\n      throw new Error('File not found');\n    });\n\n    await expect(parser.parseFile('/non-existent/file.md')).rejects.toThrow('File not found');\n\n    // Restore original method\n    parser.readFile = originalReadFile;\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/parsers/OpenAPIParser.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____ParsedContent' is defined but never used.",
        "line": 2,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'___filePath' is defined but never used.",
        "line": 190,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 190,
        "endColumn": 73
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { OpenAPIParser } from '../../parsers/OpenAPIParser.js';\nimport { ____ParsedContent } from '../../../types/parser.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('OpenAPIParser', () => {\n  // Sample OpenAPI specification\n  const sampleOpenAPISpec = {\n    openapi: '3.0.0',\n    info: {\n      title: 'Test API',\n      version: '1.0.0',\n      description: 'A test API for OpenAPIParser',\n    },\n    paths: {\n      '/users': {\n        get: {\n          summary: 'Get all users',\n          description: 'Returns a list of users',\n          responses: {\n            '200': {\n              description: 'Successful operation',\n              content: {\n                'application/json': {\n                  schema: {\n                    type: 'array',\n                    items: {\n                      $ref: '#/components/schemas/User',\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n        post: {\n          summary: 'Create a user',\n          description: 'Creates a new user',\n          requestBody: {\n            content: {\n              'application/json': {\n                schema: {\n                  $ref: '#/components/schemas/User',\n                },\n              },\n            },\n          },\n          responses: {\n            '201': {\n              description: 'User created',\n            },\n          },\n        },\n      },\n      '/users/{id}': {\n        get: {\n          summary: 'Get user by ID',\n          description: 'Returns a single user',\n          parameters: [\n            {\n              name: 'id',\n              in: 'path',\n              required: true,\n              schema: {\n                type: 'integer',\n              },\n            },\n          ],\n          responses: {\n            '200': {\n              description: 'Successful operation',\n              content: {\n                'application/json': {\n                  schema: {\n                    $ref: '#/components/schemas/User',\n                  },\n                },\n              },\n            },\n            '404': {\n              description: 'User not found',\n            },\n          },\n        },\n      },\n    },\n    components: {\n      schemas: {\n        User: {\n          type: 'object',\n          properties: {\n            id: {\n              type: 'integer',\n              format: 'int64',\n            },\n            name: {\n              type: 'string',\n            },\n            email: {\n              type: 'string',\n              format: 'email',\n            },\n          },\n          required: ['name', 'email'],\n        },\n      },\n    },\n  };\n\n  // Sample OpenAPI JSON string\n  const sampleOpenAPIJSON = JSON.stringify(sampleOpenAPISpec, null, 2);\n\n  // Sample OpenAPI YAML string\n  const sampleOpenAPIYAML = `\nopenapi: 3.0.0\ninfo:\n  title: Test API\n  version: 1.0.0\n  description: A test API for OpenAPIParser\npaths:\n  /users:\n    get:\n      summary: Get all users\n      description: Returns a list of users\n      responses:\n        '200':\n          description: Successful operation\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/User'\n    post:\n      summary: Create a user\n      description: Creates a new user\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/User'\n      responses:\n        '201':\n          description: User created\n  /users/{id}:\n    get:\n      summary: Get user by ID\n      description: Returns a single user\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Successful operation\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'\n        '404':\n          description: User not found\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        email:\n          type: string\n          format: email\n      required:\n        - name\n        - email\n`;\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for files\n    (fs.existsSync as jest.Mock).mockImplementation((___filePath: string) => {\n      return true;\n    });\n\n    // Mock fs.readFileSync to return sample OpenAPI spec\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.json')) {\n        return sampleOpenAPIJSON;\n      } else if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {\n        return sampleOpenAPIYAML;\n      }\n      throw new Error(`Unexpected file extension: ${filePath}`);\n    });\n\n    // Mock path.extname to return the correct extension\n    (path.extname as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.json')) {\n        return '.json';\n      } else if (filePath.endsWith('.yaml')) {\n        return '.yaml';\n      } else if (filePath.endsWith('.yml')) {\n        return '.yml';\n      }\n      return '';\n    });\n\n    // Mock path.basename to return the filename\n    (path.basename as jest.Mock).mockImplementation((filePath: string, ext?: string) => {\n      const parts = filePath.split('/');\n      let filename = parts[parts.length - 1];\n      if (ext && filename.endsWith(ext)) {\n        filename = filename.slice(0, -ext.length);\n      }\n      return filename;\n    });\n  });\n\n  test('should initialize with default options', () => {\n    const parser = new OpenAPIParser();\n    expect(parser).toBeDefined();\n  });\n\n  test('should initialize with custom options', () => {\n    const options = {\n      validateSchema: true,\n      includeExamples: true,\n    };\n\n    const parser = new OpenAPIParser(options);\n    expect(parser.options).toEqual(options);\n  });\n\n  test('should parse OpenAPI JSON file', () => {\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/api.json');\n\n    expect(result).toBeDefined();\n    expect(result.title).toBe('Test API');\n    expect(result.content).toContain('A test API for OpenAPIParser');\n    expect(result.sections).toBeDefined();\n    expect(result.sections.length).toBeGreaterThan(0);\n  });\n\n  test('should parse OpenAPI YAML file', () => {\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/api.yaml');\n\n    expect(result).toBeDefined();\n    expect(result.title).toBe('Test API');\n    expect(result.content).toContain('A test API for OpenAPIParser');\n    expect(result.sections).toBeDefined();\n    expect(result.sections.length).toBeGreaterThan(0);\n  });\n\n  test('should extract API paths as sections', () => {\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/api.json');\n\n    // Check that paths are extracted as sections\n    const pathSections = result.sections.filter(\n      section => section.title === '/users' || section.title === '/users/{id}'\n    );\n\n    expect(pathSections.length).toBe(2);\n\n    // Check /users path\n    const usersSection = pathSections.find(section => section.title === '/users');\n    expect(usersSection).toBeDefined();\n    expect(usersSection?.content).toContain('Get all users');\n    expect(usersSection?.content).toContain('Create a user');\n\n    // Check /users/{id} path\n    const userByIdSection = pathSections.find(section => section.title === '/users/{id}');\n    expect(userByIdSection).toBeDefined();\n    expect(userByIdSection?.content).toContain('Get user by ID');\n  });\n\n  test('should extract schemas as sections', () => {\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/api.json');\n\n    // Check that schemas are extracted as sections\n    const schemaSection = result.sections.find(section => section.title === 'User Schema');\n\n    expect(schemaSection).toBeDefined();\n    expect(schemaSection?.content).toContain('id');\n    expect(schemaSection?.content).toContain('name');\n    expect(schemaSection?.content).toContain('email');\n  });\n\n  test('should handle non-existent files', () => {\n    // Mock fs.existsSync to return false\n    (fs.existsSync as jest.Mock).mockReturnValue(false);\n\n    const parser = new OpenAPIParser();\n\n    expect(() => {\n      parser.parse('/test/non-existent.json');\n    }).toThrow('File not found: /test/non-existent.json');\n  });\n\n  test('should handle invalid JSON', () => {\n    // Mock fs.readFileSync to return invalid JSON\n    (fs.readFileSync as jest.Mock).mockReturnValue('{ invalid json }');\n\n    const parser = new OpenAPIParser();\n\n    expect(() => {\n      parser.parse('/test/invalid.json');\n    }).toThrow('Failed to parse OpenAPI specification');\n  });\n\n  test('should handle invalid YAML', () => {\n    // Mock fs.readFileSync to return invalid YAML\n    (fs.readFileSync as jest.Mock).mockReturnValue('invalid: yaml: :');\n\n    const parser = new OpenAPIParser();\n\n    expect(() => {\n      parser.parse('/test/invalid.yaml');\n    }).toThrow('Failed to parse OpenAPI specification');\n  });\n\n  test('should validate schema when enabled', () => {\n    const parser = new OpenAPIParser({ validateSchema: true });\n\n    // Mock the validateSchema method\n    parser.validateSchema = jest.fn();\n\n    parser.parse('/test/api.json');\n\n    expect(parser.validateSchema).toHaveBeenCalled();\n  });\n\n  test('should not validate schema when disabled', () => {\n    const parser = new OpenAPIParser({ validateSchema: false });\n\n    // Mock the validateSchema method\n    parser.validateSchema = jest.fn();\n\n    parser.parse('/test/api.json');\n\n    expect(parser.validateSchema).not.toHaveBeenCalled();\n  });\n\n  test('should include examples when enabled', () => {\n    const parser = new OpenAPIParser({ includeExamples: true });\n    const result = parser.parse('/test/api.json');\n\n    // Check that examples are included\n    expect(result.metadata.examples).toBeDefined();\n  });\n\n  test('should not include examples when disabled', () => {\n    const parser = new OpenAPIParser({ includeExamples: false });\n    const result = parser.parse('/test/api.json');\n\n    // Check that examples are not included\n    expect(result.metadata.examples).toBeUndefined();\n  });\n\n  test('should handle OpenAPI 2.0 (Swagger) specifications', () => {\n    // Mock fs.readFileSync to return Swagger 2.0 spec\n    (fs.readFileSync as jest.Mock).mockReturnValue(\n      JSON.stringify({\n        swagger: '2.0',\n        info: {\n          title: 'Swagger API',\n          version: '1.0.0',\n        },\n        paths: {\n          '/users': {\n            get: {\n              summary: 'Get all users',\n            },\n          },\n        },\n      })\n    );\n\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/swagger.json');\n\n    expect(result).toBeDefined();\n    expect(result.title).toBe('Swagger API');\n    expect(result.sections.some(section => section.title === '/users')).toBe(true);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/parsers/ParserFactory.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/MarkdownEnhancerPlugin.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____Plugin' is defined but never used.",
        "line": 4,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____logger' is defined but never used.",
        "line": 5,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { MarkdownEnhancerPlugin } from '../../plugins/MarkdownEnhancerPlugin.js';\nimport { PluginSystem } from '../../plugins/PluginSystem.js';\nimport { ParsedContent } from '../../../types/parser.js';\nimport { ____Plugin } from '../../../types/plugin.js';\nimport { ____logger } from '../../utils/logger.js';\n\ndescribe('MarkdownEnhancerPlugin', () => {\n  // Sample parsed content\n  const sampleParsedContent: ParsedContent = {\n    title: 'Test Document',\n    content: 'This is a test document with some content.',\n    sections: [\n      {\n        level: 1,\n        title: 'Test Document',\n        content: 'This is a test document with some content.',\n      },\n      {\n        level: 2,\n        title: 'Section 1',\n        content: 'Content for section 1.',\n      },\n    ],\n    metadata: {\n      originalPath: '/test/document.md',\n      title: 'Test Document',\n      description: 'This is a test document',\n    },\n  };\n\n  // Sample markdown content\n  const sampleMarkdown = `# Test Document\n\nThis is a test document with some content.\n\n## Section 1\n\nContent for section 1.\n\n\\`\\`\\`js\n// Code block\nconst test = 'Hello World';\nlogger.debug(test);\n\\`\\`\\`\n\n[Link to another page](another-page.md)\n`;\n\n  test('should initialize with default options', () => {\n    const plugin = new MarkdownEnhancerPlugin();\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('markdown-enhancer');\n    expect(plugin.options).toBeDefined();\n    expect(plugin.hooks).toBeDefined();\n  });\n\n  test('should initialize with custom options', () => {\n    const customOptions = {\n      enableCodeHighlighting: true,\n      enableTableOfContents: true,\n      enableFootnotes: false,\n    };\n\n    const plugin = new MarkdownEnhancerPlugin(customOptions);\n    expect(plugin.options).toEqual(customOptions);\n  });\n\n  test('should enhance code blocks in beforeParse hook', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableCodeHighlighting: true });\n    const result = plugin.hooks.beforeParse?.(sampleMarkdown, plugin.options);\n\n    expect(result).toContain('```js');\n    expect(result).toContain('// Code block');\n    expect(result).toContain(\"const test = 'Hello World';\");\n    expect(result).toContain('logger.debug(test);');\n    expect(result).toContain('```');\n\n    // Should add language class for syntax highlighting\n    expect(result).toContain('class=\"language-js\"');\n  });\n\n  test('should not enhance code blocks when disabled', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableCodeHighlighting: false });\n    const result = plugin.hooks.beforeParse?.(sampleMarkdown, plugin.options);\n\n    expect(result).toContain('```js');\n    expect(result).not.toContain('class=\"language-js\"');\n  });\n\n  test('should add table of contents in afterParse hook', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableTableOfContents: true });\n    const result = plugin.hooks.afterParse?.(sampleParsedContent, plugin.options);\n\n    expect(result).toBeDefined();\n    expect(result?.metadata.tableOfContents).toBeDefined();\n    expect(result?.metadata.tableOfContents).toHaveLength(2);\n    expect(result?.metadata.tableOfContents?.[0].title).toBe('Test Document');\n    expect(result?.metadata.tableOfContents?.[0].level).toBe(1);\n    expect(result?.metadata.tableOfContents?.[1].title).toBe('Section 1');\n    expect(result?.metadata.tableOfContents?.[1].level).toBe(2);\n  });\n\n  test('should not add table of contents when disabled', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableTableOfContents: false });\n    const result = plugin.hooks.afterParse?.(sampleParsedContent, plugin.options);\n\n    expect(result).toBeDefined();\n    expect(result?.metadata.tableOfContents).toBeUndefined();\n  });\n\n  test('should work with PluginSystem', () => {\n    const plugin = new MarkdownEnhancerPlugin();\n    const pluginSystem = new PluginSystem([plugin]);\n\n    const result = pluginSystem.executeHook('beforeParse', sampleMarkdown);\n    expect(result).toBeDefined();\n\n    const parsedResult = pluginSystem.executeHook('afterParse', sampleParsedContent);\n    expect(parsedResult).toBeDefined();\n    expect(parsedResult.metadata.tableOfContents).toBeDefined();\n  });\n\n  test('should handle empty content gracefully', () => {\n    const plugin = new MarkdownEnhancerPlugin();\n    const emptyMarkdown = '';\n\n    const result = plugin.hooks.beforeParse?.(emptyMarkdown, plugin.options);\n    expect(result).toBe('');\n\n    const emptyParsedContent: ParsedContent = {\n      title: '',\n      content: '',\n      sections: [],\n      metadata: {},\n    };\n\n    const parsedResult = plugin.hooks.afterParse?.(emptyParsedContent, plugin.options);\n    expect(parsedResult).toBeDefined();\n    expect(parsedResult?.metadata.tableOfContents).toHaveLength(0);\n  });\n\n  test('should handle content without headings', () => {\n    const plugin = new MarkdownEnhancerPlugin();\n    const markdownWithoutHeadings = 'This is content without any headings.';\n\n    const result = plugin.hooks.beforeParse?.(markdownWithoutHeadings, plugin.options);\n    expect(result).toBe(markdownWithoutHeadings);\n\n    const parsedContentWithoutHeadings: ParsedContent = {\n      title: 'No Headings',\n      content: 'This is content without any headings.',\n      sections: [],\n      metadata: {},\n    };\n\n    const parsedResult = plugin.hooks.afterParse?.(parsedContentWithoutHeadings, plugin.options);\n    expect(parsedResult).toBeDefined();\n    expect(parsedResult?.metadata.tableOfContents).toHaveLength(0);\n  });\n\n  test('should process footnotes when enabled', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableFootnotes: true });\n    const markdownWithFootnotes =\n      'This is a text with a footnote[^1].\\n\\n[^1]: This is the footnote content.';\n\n    const result = plugin.hooks.beforeParse?.(markdownWithFootnotes, plugin.options);\n    expect(result).toContain('This is a text with a footnote');\n    expect(result).toContain('This is the footnote content');\n    expect(result).toContain('<div class=\"footnote\"');\n  });\n\n  test('should not process footnotes when disabled', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableFootnotes: false });\n    const markdownWithFootnotes =\n      'This is a text with a footnote[^1].\\n\\n[^1]: This is the footnote content.';\n\n    const result = plugin.hooks.beforeParse?.(markdownWithFootnotes, plugin.options);\n    expect(result).not.toContain('<div class=\"footnote\"');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/PluginLoader.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____Plugin' is defined but never used.",
        "line": 2,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____logger' is defined but never used.",
        "line": 5,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { PluginLoader } from '../../plugins/PluginLoader.js';\nimport { ____Plugin } from '../../../types/plugin.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { ____logger } from '../../utils/logger.js';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('PluginLoader', () => {\n  // Sample plugin files\n  const mockPluginFiles = {\n    '/plugins/test-plugin.js': `\n      module.exports = {\n        name: 'test-plugin',\n        version: '1.0.0',\n        hooks: {\n          beforeParse: (_content) => 'Modified by test-plugin: ' + content,\n          afterParse: (parsed) => ({ ...parsed, title: 'Enhanced by test-plugin: ' + parsed.title })\n        }\n      };\n    `,\n    '/plugins/another-plugin.js': `\n      module.exports = {\n        name: 'another-plugin',\n        version: '1.0.0',\n        options: {\n          option1: 'default-value'\n        },\n        hooks: {\n          beforeParse: (content, options) => 'Modified by another-plugin with ' + options.option1 + ': ' + content\n        }\n      };\n    `,\n    '/plugins/invalid-plugin.js': `\n      // This is not a valid plugin\n      logger.debug('This is not a plugin');\n    `,\n    '/plugins/error-plugin.js': `\n      throw new Error('Plugin error');\n    `,\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for plugin files\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath in mockPluginFiles || filePath === '/plugins';\n    });\n\n    // Mock fs.readFileSync to return mock plugin files\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath in mockPluginFiles) {\n        return mockPluginFiles[filePath];\n      }\n      throw new Error(`File not found: ${filePath}`);\n    });\n\n    // Mock fs.readdirSync to return plugin files\n    (fs.readdirSync as jest.Mock).mockImplementation((dirPath: string) => {\n      if (dirPath === '/plugins') {\n        return ['test-plugin.js', 'another-plugin.js', 'invalid-plugin.js', 'error-plugin.js'];\n      }\n      return [];\n    });\n\n    // Mock path.resolve to return the input path\n    (path.resolve as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock require to return plugin modules\n    jest.mock(\n      '/plugins/test-plugin.js',\n      () => ({\n        name: 'test-plugin',\n        version: '1.0.0',\n        hooks: {\n          beforeParse: (content: string) => 'Modified by test-plugin: ' + content,\n          afterParse: (parsed: unknown) => ({\n            ...parsed,\n            title: 'Enhanced by test-plugin: ' + parsed.title,\n          }),\n        },\n      }),\n      { virtual: true }\n    );\n\n    jest.mock(\n      '/plugins/another-plugin.js',\n      () => ({\n        name: 'another-plugin',\n        version: '1.0.0',\n        options: {\n          option1: 'default-value',\n        },\n        hooks: {\n          beforeParse: (content: string, options: unknown) =>\n            'Modified by another-plugin with ' + options.option1 + ': ' + content,\n        },\n      }),\n      { virtual: true }\n    );\n\n    jest.mock(\n      '/plugins/invalid-plugin.js',\n      () => ({\n        // Not a valid plugin\n        notAPlugin: true,\n      }),\n      { virtual: true }\n    );\n\n    jest.mock(\n      '/plugins/error-plugin.js',\n      () => {\n        throw new Error('Plugin error');\n      },\n      { virtual: true }\n    );\n  });\n\n  test('should initialize with plugin directory', () => {\n    const loader = new PluginLoader('/plugins');\n    expect(loader).toBeDefined();\n  });\n\n  test('should load plugin from file', async () => {\n    const loader = new PluginLoader('/plugins');\n    const plugin = await loader.loadPluginFromFile('/plugins/test-plugin.js');\n\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('test-plugin');\n    expect(plugin.hooks).toBeDefined();\n    expect(plugin.hooks.beforeParse).toBeDefined();\n    expect(plugin.hooks.afterParse).toBeDefined();\n  });\n\n  test('should load plugin with options', async () => {\n    const loader = new PluginLoader('/plugins');\n    const plugin = await loader.loadPluginFromFile('/plugins/another-plugin.js');\n\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('another-plugin');\n    expect(plugin.options).toBeDefined();\n    expect(plugin.options.option1).toBe('default-value');\n    expect(plugin.hooks).toBeDefined();\n    expect(plugin.hooks.beforeParse).toBeDefined();\n  });\n\n  test('should handle invalid plugin files', async () => {\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginFromFile('/plugins/invalid-plugin.js')).rejects.toThrow(\n      'Invalid plugin format'\n    );\n  });\n\n  test('should handle errors when loading plugins', async () => {\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginFromFile('/plugins/error-plugin.js')).rejects.toThrow(\n      'Plugin error'\n    );\n  });\n\n  test('should handle non-existent plugin files', async () => {\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginFromFile('/plugins/non-existent-plugin.js')).rejects.toThrow(\n      'Plugin file not found'\n    );\n  });\n\n  test('should load all plugins from directory', async () => {\n    const loader = new PluginLoader('/plugins');\n    const plugins = await loader.loadPluginsFromDirectory();\n\n    // Should only load valid plugins\n    expect(plugins).toHaveLength(2);\n    expect(plugins[0].name).toBe('test-plugin');\n    expect(plugins[1].name).toBe('another-plugin');\n  });\n\n  test('should handle errors when loading plugins from directory', async () => {\n    // Mock fs.readdirSync to throw an error\n    (fs.readdirSync as jest.Mock).mockImplementation(() => {\n      throw new Error('Directory error');\n    });\n\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginsFromDirectory()).rejects.toThrow(\n      'Failed to load plugins from directory'\n    );\n  });\n\n  test('should load plugins with custom options', async () => {\n    const loader = new PluginLoader('/plugins');\n    const customOptions = {\n      'another-plugin': {\n        option1: 'custom-value',\n      },\n    };\n\n    const plugins = await loader.loadPluginsFromDirectory(customOptions);\n\n    expect(plugins).toHaveLength(2);\n    expect(plugins[1].name).toBe('another-plugin');\n    expect(plugins[1].options.option1).toBe('custom-value');\n  });\n\n  test('should load specific plugins by name', async () => {\n    const loader = new PluginLoader('/plugins');\n    const plugins = await loader.loadPluginsByName(['test-plugin']);\n\n    expect(plugins).toHaveLength(1);\n    expect(plugins[0].name).toBe('test-plugin');\n  });\n\n  test('should handle non-existent plugins when loading by name', async () => {\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginsByName(['non-existent-plugin'])).rejects.toThrow(\n      'Plugin not found'\n    );\n  });\n\n  test('should validate plugin structure', () => {\n    const loader = new PluginLoader('/plugins');\n\n    // Valid plugin\n    const validPlugin = {\n      name: 'valid-plugin',\n      version: '1.0.0',\n      hooks: {\n        beforeParse: () => '',\n      },\n    };\n    expect(loader.isValidPlugin(validPlugin)).toBe(true);\n\n    // Invalid plugin - no name\n    const noNamePlugin = {\n      hooks: {\n        beforeParse: () => '',\n      },\n    };\n    expect(loader.isValidPlugin(noNamePlugin)).toBe(false);\n\n    // Invalid plugin - no hooks\n    const noHooksPlugin = {\n      name: 'no-hooks-plugin',\n    };\n    expect(loader.isValidPlugin(noHooksPlugin)).toBe(false);\n\n    // Invalid plugin - hooks is not an object\n    const invalidHooksPlugin = {\n      name: 'invalid-hooks-plugin',\n      hooks: 'not an object',\n    };\n    expect(loader.isValidPlugin(invalidHooksPlugin)).toBe(false);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/PluginSystem.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/SiteMapGenerator.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/SyntaxHighlightPlugin.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____logger' is defined but never used.",
        "line": 3,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { SyntaxHighlightPlugin } from '../../plugins/SyntaxHighlightPlugin.js';\nimport { ParsedContent, ContentNode } from '../../../types/parser.js';\nimport { ____logger } from '../../utils/logger.js';\n\ndescribe('SyntaxHighlightPlugin', () => {\n  let plugin: SyntaxHighlightPlugin;\n\n  beforeEach(() => {\n    plugin = new SyntaxHighlightPlugin();\n  });\n\n  test('should initialize with default options', () => {\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('syntax-highlight');\n  });\n\n  test('should initialize with custom options', () => {\n    const customPlugin = new SyntaxHighlightPlugin({\n      theme: 'dark',\n      lineNumbers: true,\n      languages: ['javascript', 'typescript', 'html'],\n      highlightInline: true,\n      codeBlockClass: 'custom-code-block',\n    });\n\n    expect(customPlugin).toBeDefined();\n    expect(customPlugin.name).toBe('syntax-highlight');\n  });\n\n  test('should add syntax highlighting to code blocks', () => {\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n        },\n        {\n          type: 'codeBlock',\n          content: 'function hello() {\\n  logger.debug(\"Hello, world!\");\\n}',\n          attributes: {\n            language: 'javascript',\n          },\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was added to the code block\n    expect(result.sections[1].attributes).toEqual({\n      language: 'javascript',\n      highlighted: true,\n      theme: 'default',\n      lineNumbers: false,\n      className: 'code-block language-javascript',\n    });\n\n    // Verify that metadata was added\n    expect(result.metadata.syntaxHighlighting).toEqual({\n      enabled: true,\n      theme: 'default',\n      lineNumbers: false,\n    });\n  });\n\n  test('should highlight inline code when enabled', () => {\n    // Create a plugin with highlightInline: true\n    const inlinePlugin = new SyntaxHighlightPlugin({\n      highlightInline: true,\n    });\n\n    // Create mock parsed content with inline code\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: [\n            {\n              type: 'text',\n              content: 'This is some text with ',\n            },\n            {\n              type: 'inlineCode',\n              content: 'const x = 42;',\n            },\n            {\n              type: 'text',\n              content: ' inline code.',\n            },\n          ],\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = inlinePlugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was added to the inline code\n    const inlineCode = (result.sections[0].content as ContentNode[])[1];\n    expect(inlineCode.attributes).toEqual({\n      highlighted: true,\n      theme: 'default',\n      className: 'language-text',\n    });\n  });\n\n  test('should not highlight inline code when disabled', () => {\n    // Create mock parsed content with inline code\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: [\n            {\n              type: 'text',\n              content: 'This is some text with ',\n            },\n            {\n              type: 'inlineCode',\n              content: 'const x = 42;',\n            },\n            {\n              type: 'text',\n              content: ' inline code.',\n            },\n          ],\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was not added to the inline code\n    const inlineCode = (result.sections[0].content as ContentNode[])[1];\n    expect(inlineCode.attributes).toBeUndefined();\n  });\n\n  test('should respect the languages option', () => {\n    // Create a plugin with specific languages\n    const languagePlugin = new SyntaxHighlightPlugin({\n      languages: ['javascript', 'typescript'],\n    });\n\n    // Create mock parsed content with different language code blocks\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'codeBlock',\n          content: 'function hello() {\\n  logger.debug(\"Hello, world!\");\\n}',\n          attributes: {\n            language: 'javascript',\n          },\n        },\n        {\n          type: 'codeBlock',\n          content: 'const x: number = 42;',\n          attributes: {\n            language: 'typescript',\n          },\n        },\n        {\n          type: 'codeBlock',\n          content: '<div>Hello, world!</div>',\n          attributes: {\n            language: 'html',\n          },\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = languagePlugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was added to javascript and typescript blocks\n    expect(result.sections[0].attributes?.highlighted).toBe(true);\n    expect(result.sections[1].attributes?.highlighted).toBe(true);\n\n    // Verify that syntax highlighting was not added to html block\n    expect(result.sections[2].attributes?.highlighted).toBeUndefined();\n  });\n\n  test('should process nested content nodes', () => {\n    // Create mock parsed content with nested nodes\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          children: [\n            {\n              type: 'codeBlock',\n              content: 'function hello() {\\n  logger.debug(\"Hello, world!\");\\n}',\n              attributes: {\n                language: 'javascript',\n              },\n            },\n          ],\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was added to the nested code block\n    expect(result.sections[0].children?.[0].attributes).toEqual({\n      language: 'javascript',\n      highlighted: true,\n      theme: 'default',\n      lineNumbers: false,\n      className: 'code-block language-javascript',\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/TableOfContentsPlugin.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'____ContentNode' is defined but never used.",
        "line": 2,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { TableOfContentsPlugin } from '../../plugins/TableOfContentsPlugin.js';\nimport { ParsedContent, ____ContentNode } from '../../../types/parser.js';\n\ndescribe('TableOfContentsPlugin', () => {\n  let plugin: TableOfContentsPlugin;\n\n  beforeEach(() => {\n    plugin = new TableOfContentsPlugin();\n  });\n\n  test('should initialize with default options', () => {\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('table-of-contents');\n  });\n\n  test('should initialize with custom options', () => {\n    const customPlugin = new TableOfContentsPlugin({\n      title: 'Custom TOC',\n      maxLevel: 2,\n      addAnchors: false,\n      className: 'custom-toc',\n      position: 'bottom',\n    });\n\n    expect(customPlugin).toBeDefined();\n    expect(customPlugin.name).toBe('table-of-contents');\n  });\n\n  test('should add table of contents to content', () => {\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n        {\n          type: 'section',\n          title: 'Getting Started',\n          content: 'This is the getting started section',\n          level: 2,\n        },\n        {\n          type: 'section',\n          title: 'Advanced Topics',\n          content: 'This is the advanced topics section',\n          level: 2,\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that the table of contents was added\n    expect(result.sections).toHaveLength(5);\n    expect(result.sections[0].type).toBe('toc');\n    expect(result.sections[0].title).toBe('Table of Contents');\n\n    // Verify the table of contents content\n    const tocContent = result.sections[0].content as string;\n    expect(tocContent).toContain('- [Introduction](#introduction)');\n    expect(tocContent).toContain('  - [Getting Started](#getting-started)');\n    expect(tocContent).toContain('  - [Advanced Topics](#advanced-topics)');\n    expect(tocContent).toContain('- [Conclusion](#conclusion)');\n  });\n\n  test('should add table of contents at the bottom', () => {\n    // Create a plugin with position: 'bottom'\n    const bottomPlugin = new TableOfContentsPlugin({\n      position: 'bottom',\n    });\n\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = bottomPlugin.hooks.afterParse(parsedContent);\n\n    // Verify that the table of contents was added at the bottom\n    expect(result.sections).toHaveLength(3);\n    expect(result.sections[2].type).toBe('toc');\n    expect(result.sections[2].title).toBe('Table of Contents');\n  });\n\n  test('should respect maxLevel option', () => {\n    // Create a plugin with maxLevel: 1\n    const maxLevelPlugin = new TableOfContentsPlugin({\n      maxLevel: 1,\n    });\n\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n        {\n          type: 'section',\n          title: 'Getting Started',\n          content: 'This is the getting started section',\n          level: 2,\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = maxLevelPlugin.hooks.afterParse(parsedContent);\n\n    // Verify the table of contents content\n    const tocContent = result.sections[0].content as string;\n    expect(tocContent).toContain('- [Introduction](#introduction)');\n    expect(tocContent).not.toContain('  - [Getting Started](#getting-started)');\n    expect(tocContent).toContain('- [Conclusion](#conclusion)');\n  });\n\n  test('should add anchors to headings', () => {\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n        {\n          type: 'section',\n          title: 'Getting Started',\n          content: 'This is the getting started section',\n          level: 2,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that anchors were added to headings\n    expect(result.sections[1].attributes).toBeDefined();\n    expect(result.sections[1].attributes?.id).toBe('introduction');\n    expect(result.sections[1].attributes?.className).toContain('anchor');\n\n    expect(result.sections[2].attributes).toBeDefined();\n    expect(result.sections[2].attributes?.id).toBe('getting-started');\n    expect(result.sections[2].attributes?.className).toContain('anchor');\n  });\n\n  test('should not add anchors when addAnchors is false', () => {\n    // Create a plugin with addAnchors: false\n    const noAnchorsPlugin = new TableOfContentsPlugin({\n      addAnchors: false,\n    });\n\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = noAnchorsPlugin.hooks.afterParse(parsedContent);\n\n    // Verify that anchors were not added to headings\n    expect(result.sections[1].attributes?.id).toBeUndefined();\n    expect(result.sections[1].attributes?.className).toBeUndefined();\n  });\n\n  test('should handle empty sections', () => {\n    // Create mock parsed content with no sections\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that the result is the same as the input\n    expect(result).toBe(parsedContent);\n    expect(result.sections).toHaveLength(0);\n  });\n\n  test('should handle nested sections', () => {\n    // Create mock parsed content with nested sections\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n          children: [\n            {\n              type: 'section',\n              title: 'Background',\n              content: 'This is the background',\n              level: 2,\n            },\n          ],\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify the table of contents content\n    const tocContent = result.sections[0].content as string;\n    expect(tocContent).toContain('- [Introduction](#introduction)');\n    expect(tocContent).toContain('  - [Background](#background)');\n    expect(tocContent).toContain('- [Conclusion](#conclusion)');\n\n    // Verify that anchors were added to nested headings\n    expect(result.sections[1].attributes?.id).toBe('introduction');\n    expect(result.sections[1].children?.[0].attributes?.id).toBe('background');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/services/ParserService.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/simple-test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/simple.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/simple/basic.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/templates/HandlebarsTemplateEngine.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/templates/TemplateManager.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_fs' is defined but never used.",
        "line": 6,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 6,
        "endColumn": 16
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { TemplateManager } from '../../templates/TemplateManager.js';\nimport { TemplateEngine } from '../../templates/TemplateEngine.js';\nimport { HandlebarsTemplateEngine } from '../../templates/HandlebarsTemplateEngine.js';\nimport { EjsTemplateEngine } from '../../templates/EjsTemplateEngine.js';\nimport { createMockParsedContent } from '../utils/test-helpers.js';\nimport * as _fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\njest.mock('../../templates/HandlebarsTemplateEngine');\njest.mock('../../templates/EjsTemplateEngine');\n\ndescribe('TemplateManager', () => {\n  let templateManager: TemplateManager;\n  let mockHandlebarsEngine: jest.Mocked<HandlebarsTemplateEngine>;\n  let mockEjsEngine: jest.Mocked<EjsTemplateEngine>;\n\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks();\n\n    // Create mock template engines\n    mockHandlebarsEngine = new HandlebarsTemplateEngine() as jest.Mocked<HandlebarsTemplateEngine>;\n    mockEjsEngine = new EjsTemplateEngine() as jest.Mocked<EjsTemplateEngine>;\n\n    // Mock the constructors\n    (HandlebarsTemplateEngine as jest.Mock).mockImplementation(() => mockHandlebarsEngine);\n    (EjsTemplateEngine as jest.Mock).mockImplementation(() => mockEjsEngine);\n\n    // Create the template manager\n    templateManager = new TemplateManager({\n      defaultEngine: 'handlebars',\n      handlebarsOptions: {\n        partialsDir: '/test/partials',\n      },\n      ejsOptions: {\n        includesDir: '/test/includes',\n      },\n    });\n  });\n\n  test('should initialize with default engines', () => {\n    expect(templateManager).toBeDefined();\n    expect(HandlebarsTemplateEngine).toHaveBeenCalled();\n    expect(EjsTemplateEngine).toHaveBeenCalled();\n  });\n\n  test('should register a custom template engine', () => {\n    // Create a mock custom engine\n    const mockCustomEngine = {\n      render: jest.fn().mockResolvedValue('<div>Custom Template</div>'),\n      renderContent: jest.fn().mockResolvedValue('<div>Custom Content</div>'),\n      clearCache: jest.fn(),\n    } as unknown as TemplateEngine;\n\n    // Register the custom engine\n    templateManager.registerEngine('custom', mockCustomEngine);\n\n    // Get the custom engine\n    const engine = templateManager.getEngine('custom');\n    expect(engine).toBe(mockCustomEngine);\n  });\n\n  test('should get the default engine when no name is provided', () => {\n    const engine = templateManager.getEngine();\n    expect(engine).toBe(mockHandlebarsEngine);\n  });\n\n  test('should throw an error when getting a non-existent engine', () => {\n    expect(() => templateManager.getEngine('non-existent')).toThrow();\n  });\n\n  test('should infer engine from file extension', async () => {\n    // Mock path.extname to return the file extension\n    (path.extname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('.');\n      return parts.length > 1 ? `.${parts[parts.length - 1]}` : '';\n    });\n\n    // Mock the render methods\n    mockHandlebarsEngine.render.mockResolvedValue('<div>Handlebars Template</div>');\n    mockEjsEngine.render.mockResolvedValue('<div>EJS Template</div>');\n\n    // Render templates with different extensions\n    await templateManager.render('template.hbs', { title: 'Test' });\n    await templateManager.render('template.ejs', { title: 'Test' });\n    await templateManager.render('template.txt', { title: 'Test' });\n\n    // Verify that the correct engines were used\n    expect(mockHandlebarsEngine.render).toHaveBeenCalledTimes(2); // .hbs and .txt (default)\n    expect(mockEjsEngine.render).toHaveBeenCalledTimes(1); // .ejs\n  });\n\n  test('should render content with the specified engine', async () => {\n    // Create mock parsed content\n    const mockContent = createMockParsedContent({\n      title: 'Test Document',\n      description: 'Test description',\n    });\n\n    // Mock the renderContent method\n    mockHandlebarsEngine.renderContent.mockResolvedValue('<div>Rendered Content</div>');\n\n    // Render content with the handlebars engine\n    const result = await templateManager.renderContent(\n      mockContent,\n      'template.hbs',\n      undefined,\n      'handlebars'\n    );\n\n    // Verify the result\n    expect(result).toBe('<div>Rendered Content</div>');\n    expect(mockHandlebarsEngine.renderContent).toHaveBeenCalledWith(\n      mockContent,\n      'template.hbs',\n      undefined\n    );\n  });\n\n  test('should clear cache for all engines', () => {\n    // Clear the cache\n    templateManager.clearCache();\n\n    // Verify that clearCache was called on all engines\n    expect(mockHandlebarsEngine.clearCache).toHaveBeenCalled();\n    expect(mockEjsEngine.clearCache).toHaveBeenCalled();\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/templates/helpers/component-helper.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/tools/plugin-docs-generator.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_PluginDocsGeneratorInternals' is defined but never used.",
        "line": 34,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 34,
        "endColumn": 44
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { PluginDocsGenerator } from '../../tools/plugin-docs-generator.js';\nimport { Plugin } from '../../../types/plugin.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('PluginDocsGenerator', () => {\n  let generator: PluginDocsGenerator;\n  let mockPlugin1: Plugin;\n  let mockPlugin2: Plugin;\n\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks();\n\n    // Mock fs.existsSync to return false for directories\n    (fs.existsSync as jest.Mock).mockReturnValue(false);\n\n    // Mock fs.mkdirSync to do nothing\n    (fs.mkdirSync as jest.Mock).mockImplementation(() => {\n      return undefined;\n    });\n\n    // Define interface for fs.promises mock to replace 'any'\n    interface FSPromisesMock {\n      writeFile: jest.Mock;\n      [key: string]: unknown; // Allow for additional properties\n    }\n\n    // Define interface for PluginDocsGenerator internals to avoid using 'any'\n    interface _PluginDocsGeneratorInternals {\n      plugins: Plugin[];\n      [key: string]: unknown; // Allow for additional properties\n    }\n\n    // Mock fs.promises.writeFile to do nothing\n    (fs.promises as unknown as FSPromisesMock) = {\n      writeFile: jest.fn().mockResolvedValue(undefined),\n    };\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => paths.join('/'));\n\n    // Create mock plugins\n    mockPlugin1 = {\n      name: 'test-plugin-1',\n      description: 'A test plugin',\n      hooks: {\n        beforeParse: jest.fn(),\n        afterParse: jest.fn(),\n      },\n      options: {\n        option1: {\n          type: 'string',\n          description: 'Option 1 description',\n          required: true,\n        },\n        option2: {\n          type: 'boolean',\n          description: 'Option 2 description',\n          required: false,\n          default: false,\n        },\n      },\n    };\n\n    mockPlugin2 = {\n      name: 'test-plugin-2',\n      description: 'Another test plugin',\n      hooks: {\n        beforeBuild: jest.fn(),\n        afterBuild: jest.fn(),\n      },\n    };\n\n    // Create the generator\n    generator = new PluginDocsGenerator('/test/docs');\n  });\n\n  test('should initialize with the output directory', () => {\n    expect(generator).toBeDefined();\n  });\n\n  test('should add plugins', () => {\n    // Add plugins\n    generator.addPlugin(mockPlugin1);\n    generator.addPlugin(mockPlugin2);\n\n    // Verify that the plugins were added\n    expect((generator as unknown as PluginDocsGeneratorInternals).plugins).toHaveLength(2);\n    expect((generator as unknown as PluginDocsGeneratorInternals).plugins[0]).toBe(mockPlugin1);\n    expect((generator as unknown as PluginDocsGeneratorInternals).plugins[1]).toBe(mockPlugin2);\n  });\n\n  test('should generate documentation', async () => {\n    // Add plugins\n    generator.addPlugin(mockPlugin1);\n    generator.addPlugin(mockPlugin2);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Verify that the output directory was created\n    expect(fs.existsSync).toHaveBeenCalledWith('/test/docs');\n    expect(fs.mkdirSync).toHaveBeenCalledWith('/test/docs', { recursive: true });\n\n    // Verify that the index file was generated\n    expect(fs.promises.writeFile).toHaveBeenCalledWith(\n      '/test/docs/README.md',\n      expect.stringContaining('# Plugin Documentation'),\n      undefined\n    );\n\n    // Verify that the plugin documentation files were generated\n    expect(fs.promises.writeFile).toHaveBeenCalledWith(\n      '/test/docs/test-plugin-1.md',\n      expect.stringContaining('# test-plugin-1 Plugin'),\n      undefined\n    );\n    expect(fs.promises.writeFile).toHaveBeenCalledWith(\n      '/test/docs/test-plugin-2.md',\n      expect.stringContaining('# test-plugin-2 Plugin'),\n      undefined\n    );\n  });\n\n  test('should generate index file with plugin links', async () => {\n    // Add plugins\n    generator.addPlugin(mockPlugin1);\n    generator.addPlugin(mockPlugin2);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the index file content\n    const indexFileCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/README.md'\n    );\n    const indexContent = indexFileCall ? indexFileCall[1] : '';\n\n    // Verify the index content\n    expect(indexContent).toContain('# Plugin Documentation');\n    expect(indexContent).toContain('## Available Plugins');\n    expect(indexContent).toContain('- [test-plugin-1](test-plugin-1.md): A test plugin');\n    expect(indexContent).toContain('- [test-plugin-2](test-plugin-2.md): Another test plugin');\n  });\n\n  test('should generate plugin documentation with hooks', async () => {\n    // Add a plugin\n    generator.addPlugin(mockPlugin1);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/test-plugin-1.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('# test-plugin-1 Plugin');\n    expect(pluginDocContent).toContain('A test plugin');\n    expect(pluginDocContent).toContain('## Hooks');\n    expect(pluginDocContent).toContain('- `beforeParse`: Called before parsing content');\n    expect(pluginDocContent).toContain('- `afterParse`: Called after parsing content');\n  });\n\n  test('should generate plugin documentation with options', async () => {\n    // Add a plugin\n    generator.addPlugin(mockPlugin1);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/test-plugin-1.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Options');\n    expect(pluginDocContent).toContain('| Option | Type | Description | Required | Default |');\n    expect(pluginDocContent).toContain('| `option1` | `string` | Option 1 description | Yes | - |');\n    expect(pluginDocContent).toContain(\n      '| `option2` | `boolean` | Option 2 description | No | false |'\n    );\n  });\n\n  test('should handle plugins without hooks', async () => {\n    // Create a plugin without hooks\n    const pluginWithoutHooks: Plugin = {\n      name: 'plugin-without-hooks',\n      description: 'A plugin without hooks',\n    };\n\n    // Add the plugin\n    generator.addPlugin(pluginWithoutHooks);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/plugin-without-hooks.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Hooks');\n    expect(pluginDocContent).toContain('This plugin does not implement any hooks.');\n  });\n\n  test('should handle plugins without options', async () => {\n    // Create a plugin without options\n    const pluginWithoutOptions: Plugin = {\n      name: 'plugin-without-options',\n      description: 'A plugin without options',\n      hooks: {\n        beforeParse: jest.fn(),\n      },\n    };\n\n    // Add the plugin\n    generator.addPlugin(pluginWithoutOptions);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/plugin-without-options.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Options');\n    expect(pluginDocContent).toContain('This plugin does not have any options.');\n  });\n\n  test('should handle plugins without description', async () => {\n    // Create a plugin without description\n    const pluginWithoutDescription: Plugin = {\n      name: 'plugin-without-description',\n      hooks: {\n        beforeParse: jest.fn(),\n      },\n    };\n\n    // Add the plugin\n    generator.addPlugin(pluginWithoutDescription);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/plugin-without-description.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('# plugin-without-description Plugin');\n    expect(pluginDocContent).toContain('No description available.');\n  });\n\n  test('should handle plugins with examples', async () => {\n    // Create a plugin with examples\n    const pluginWithExamples: Plugin = {\n      name: 'plugin-with-examples',\n      description: 'A plugin with examples',\n      hooks: {\n        beforeParse: jest.fn(),\n      },\n      examples: [\n        'const plugin = new ExamplePlugin();\\ngenerator.addPlugin(plugin);',\n        'const plugin = new ExamplePlugin({ option: \"value\" });\\ngenerator.addPlugin(plugin);',\n      ],\n    };\n\n    // Add the plugin\n    generator.addPlugin(pluginWithExamples);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/plugin-with-examples.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Examples');\n    expect(pluginDocContent).toContain('```javascript');\n    expect(pluginDocContent).toContain('const plugin = new ExamplePlugin();');\n    expect(pluginDocContent).toContain('const plugin = new ExamplePlugin({ option: \"value\" });');\n  });\n\n  test('should handle plugins without examples', async () => {\n    // Add a plugin without examples\n    generator.addPlugin(mockPlugin1);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/test-plugin-1.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Examples');\n    expect(pluginDocContent).toContain('No examples available.');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/cache-simple.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/cache.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 118,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 118,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 123,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 123,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 132,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 132,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 157,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 157,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 166,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 166,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 178,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 178,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 188,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 188,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 201,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 201,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 222,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 222,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 236,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 236,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 248,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 248,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 265,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 265,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__cache' is assigned a value but never used.",
        "line": 283,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 283,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Logger import commented out as it's not used in this test file\n//import { logger } from '../../utils/logger.js';\nimport { ContentCache, CacheOptions } from '../../utils/cache.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\njest.mock('../../utils/logger.js');\n\n// Define a type for our test data to replace 'any'\ninterface TestDocument {\n  title: string;\n  content: string;\n  [key: string]: unknown; // Allow for additional properties if needed\n}\n\n// Define a type for test items with numeric IDs\ninterface TestItem {\n  id: number;\n  [key: string]: unknown; // Allow for additional properties if needed\n}\n\ndescribe('ContentCache', () => {\n  // Sample cache options\n  const memoryCacheOptions: CacheOptions = {\n    enabled: true,\n    storageType: 'memory',\n    maxSize: 10,\n    ttl: 3600000, // 1 hour\n  };\n\n  const filesystemCacheOptions: CacheOptions = {\n    enabled: true,\n    storageType: 'filesystem',\n    cacheDir: '/test/cache',\n    ttl: 3600000, // 1 hour\n  };\n\n  // Sample cache data\n  const sampleData: TestDocument = {\n    title: 'Test Document',\n    content: 'Test content',\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for cache directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath === '/test/cache';\n    });\n\n    // Mock fs.mkdirSync\n    (fs.mkdirSync as jest.Mock).mockImplementation(() => {\n      return undefined;\n    });\n\n    // Mock fs.writeFileSync\n    (fs.writeFileSync as jest.Mock).mockImplementation(() => {\n      return undefined;\n    });\n\n    // Mock fs.readFileSync\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.includes('valid-key')) {\n        return JSON.stringify({\n          data: sampleData,\n          timestamp: Date.now() - 1000, // 1 second ago\n          key: 'valid-key',\n        });\n      } else if (filePath.includes('expired-key')) {\n        return JSON.stringify({\n          data: sampleData,\n          timestamp: Date.now() - 7200000, // 2 hours ago (expired)\n          key: 'expired-key',\n        });\n      }\n      throw new Error(`File not found: ${filePath}`);\n    });\n\n    // Mock fs.unlinkSync\n    (fs.unlinkSync as jest.Mock).mockImplementation(() => {\n      return undefined;\n    });\n\n    // Mock fs.readdirSync\n    (fs.readdirSync as jest.Mock).mockImplementation((dirPath: string) => {\n      if (dirPath === '/test/cache') {\n        return ['valid-key.json', 'expired-key.json'];\n      }\n      return [];\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n  });\n\n  test('should initialize with memory storage', () => {\n    const __cache = new ContentCache<TestDocument>(memoryCacheOptions);\n    expect(__cache).toBeDefined();\n  });\n\n  test('should initialize with filesystem storage', () => {\n    const __cache = new ContentCache<TestDocument>(filesystemCacheOptions);\n    expect(__cache).toBeDefined();\n    expect(fs.existsSync).toHaveBeenCalledWith('/test/cache');\n  });\n\n  test('should create cache directory if it does not exist', () => {\n    // Mock fs.existsSync to return false for cache directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath !== '/test/cache';\n    });\n\n    const __cache = new ContentCache<TestDocument>(filesystemCacheOptions);\n    expect(fs.mkdirSync).toHaveBeenCalledWith('/test/cache', { recursive: true });\n  });\n\n  test('should set and get item from memory cache', () => {\n    const __cache = new ContentCache<TestDocument>(memoryCacheOptions);\n\n    cache.set('test-key', sampleData);\n    const result = cache.get('test-key');\n\n    expect(result).toEqual(sampleData);\n  });\n\n  test('should set and get item from filesystem cache', () => {\n    const __cache = new ContentCache<TestDocument>(filesystemCacheOptions);\n\n    cache.set('test-key', sampleData);\n\n    // Mock fs.existsSync to return true for cache file\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath === '/test/cache/098f6bcd4621d373cade4e832627b4f6.json';\n    });\n\n    const result = cache.get('test-key');\n\n    expect(result).toEqual(sampleData);\n    expect(fs.writeFileSync).toHaveBeenCalled();\n    expect(fs.readFileSync).toHaveBeenCalled();\n  });\n\n  test('should return null for non-existent item', () => {\n    const testCache = new ContentCache<TestDocument>(memoryCacheOptions);\n\n    const result = testCache.get('non-existent-key');\n\n    expect(result).toBeNull();\n  });\n\n  test('should check if item exists in memory cache', () => {\n    const __cache = new ContentCache<TestDocument>(memoryCacheOptions);\n\n    cache.set('test-key', sampleData);\n\n    expect(cache.has('test-key')).toBe(true);\n    expect(cache.has('non-existent-key')).toBe(false);\n  });\n\n  test('should check if item exists in filesystem cache', () => {\n    const __cache = new ContentCache<TestDocument>(filesystemCacheOptions);\n\n    // Mock fs.existsSync to return true for valid cache file\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath.includes('valid-key');\n    });\n\n    expect(cache.has('valid-key')).toBe(true);\n    expect(cache.has('non-existent-key')).toBe(false);\n  });\n\n  test('should delete item from memory cache', () => {\n    const __cache = new ContentCache<TestDocument>(memoryCacheOptions);\n\n    cache.set('test-key', sampleData);\n    expect(cache.has('test-key')).toBe(true);\n\n    cache.delete('test-key');\n    expect(cache.has('test-key')).toBe(false);\n  });\n\n  test('should delete item from filesystem cache', () => {\n    const __cache = new ContentCache<TestDocument>(filesystemCacheOptions);\n\n    // Mock fs.existsSync to return true for cache file\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath.includes('test-key');\n    });\n\n    cache.delete('test-key');\n\n    expect(fs.unlinkSync).toHaveBeenCalled();\n  });\n\n  test('should clear memory cache', () => {\n    const __cache = new ContentCache<TestDocument>(memoryCacheOptions);\n\n    cache.set('test-key-1', sampleData);\n    cache.set('test-key-2', sampleData);\n\n    cache.clear();\n\n    expect(cache.has('test-key-1')).toBe(false);\n    expect(cache.has('test-key-2')).toBe(false);\n  });\n\n  test('should clear filesystem cache', () => {\n    const testCache = new ContentCache<TestDocument>(filesystemCacheOptions);\n\n    testCache.clear();\n\n    expect(fs.readdirSync).toHaveBeenCalledWith('/test/cache');\n    expect(fs.unlinkSync).toHaveBeenCalledTimes(2); // Two cache files\n  });\n\n  test('should handle expired items in memory cache', () => {\n    const __cache = new ContentCache<TestDocument>({\n      ...memoryCacheOptions,\n      ttl: 1000, // 1 second\n    });\n\n    cache.set('test-key', sampleData);\n\n    // Fast-forward time by 2 seconds\n    jest.advanceTimersByTime(2000);\n\n    expect(cache.get('test-key')).toBeNull();\n  });\n\n  test('should handle expired items in filesystem cache', () => {\n    const __cache = new ContentCache<TestDocument>(filesystemCacheOptions);\n\n    // Mock fs.existsSync to return true for expired cache file\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath.includes('expired-key');\n    });\n\n    expect(cache.get('expired-key')).toBeNull();\n    expect(fs.unlinkSync).toHaveBeenCalled();\n  });\n\n  test('should enforce maximum cache size', () => {\n    const __cache = new ContentCache<TestItem>({\n      ...memoryCacheOptions,\n      maxSize: 2, // Only allow 2 items\n    });\n\n    // Add 3 items\n    cache.set('test-key-1', { id: 1 });\n    cache.set('test-key-2', { id: 2 });\n    cache.set('test-key-3', { id: 3 });\n\n    // The oldest item should be removed\n    expect(cache.has('test-key-1')).toBe(false);\n    expect(cache.has('test-key-2')).toBe(true);\n    expect(cache.has('test-key-3')).toBe(true);\n  });\n\n  test('should get cache statistics', async () => {\n    const __cache = new ContentCache<TestItem>(memoryCacheOptions);\n\n    cache.set('test-key-1', { id: 1 });\n    cache.set('test-key-2', { id: 2 });\n\n    const stats = cache.getStats();\n\n    expect(stats).toBeDefined();\n    // Stats are logged for debugging during test development\n    // console.log('stats', stats);\n    expect((await stats).enabled).toBe(true);\n    expect((await stats).storageType).toBe('memory');\n    expect((await stats).size).toBe(2);\n    expect((await stats).maxSize).toBe(10);\n    expect((await stats).ttl).toBe(3600000);\n  });\n\n  test('should do nothing when cache is disabled', () => {\n    const __cache = new ContentCache<TestDocument>({\n      ...memoryCacheOptions,\n      enabled: false,\n    });\n\n    cache.set('test-key', sampleData);\n\n    expect(cache.get('test-key')).toBeNull();\n    expect(cache.has('test-key')).toBe(false);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/config-validator.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/dependency-graph.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/dev-server.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/errors.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/incremental.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/performance.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/test-helpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/cli-enhanced.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/cli.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/component-generator/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/config/generator.config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/navigation/NavigationGenerator.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/optimization/performance-optimizer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/parsers/DocsifyMarkdownParser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/parsers/OpenAPIParser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/parsers/Parser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/parsers/ParserFactory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/CrossReferencePlugin.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/MarkdownEnhancerPlugin.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/MermaidPlugin.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/PluginLoader.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-var-requires",
        "severity": 2,
        "message": "Require statement not part of import statement.",
        "line": 30,
        "column": 20,
        "nodeType": "CallExpression",
        "messageId": "noVarReqs",
        "endLine": 30,
        "endColumn": 37,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/PluginManager.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_filePath' is defined but never used.",
        "line": 105,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 105,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_filePath' is defined but never used.",
        "line": 109,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 109,
        "endColumn": 73
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Plugin } from '../../types/plugin.js';\nimport { ParsedContent } from '../../types/parser.js';\nimport { logger } from '../utils/logger.js';\n\nexport class PluginManager {\n  private plugins: Plugin[] = [];\n  // Flag to track if the plugin list has been modified\n\n  constructor(plugins: Plugin[] = []) {\n    this.plugins = [...plugins];\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getPlugins(): Plugin[] {\n    return this.plugins;\n  }\n\n  /**\n   * Register a new plugin\n   */\n  registerPlugin(plugin: Plugin): void {\n    this.plugins.push(plugin);\n  }\n\n  /**\n   * Initialize all plugins that have an initialize method\n   */\n  async initializePlugins(): Promise<void> {\n    for (const plugin of this.plugins) {\n      if (plugin.initialize) {\n        await plugin.initialize();\n      }\n    }\n  }\n\n  /**\n   * Execute a specific hook for all plugins\n   */\n  executeHook<T>(hookName: string, data: T, continueOnError = false): T {\n    let result = data;\n\n    for (const plugin of this.plugins) {\n      if (plugin.hooks && plugin.hooks[hookName]) {\n        try {\n          result = plugin.hooks[hookName](result, plugin.options);\n        } catch (error) {\n          if (!continueOnError) {\n            throw error;\n          }\n          logger.warn(`Error executing hook ${hookName} for plugin ${plugin.name}: ${error}`);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Execute a specific hook for a specific plugin\n   */\n  executeHookForPlugin<T>(hookName: string, pluginName: string, data: T): T {\n    const plugin = this.getPluginByName(pluginName);\n\n    if (!plugin || !plugin.hooks || !plugin.hooks[hookName]) {\n      return data;\n    }\n\n    try {\n      return plugin.hooks[hookName](data, plugin.options);\n    } catch (error) {\n      logger.error(`Error executing hook ${hookName} for plugin ${pluginName}: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get a plugin by name\n   */\n  getPluginByName(name: string): Plugin | undefined {\n    return this.plugins.find(plugin => plugin.name === name);\n  }\n\n  /**\n   * Check if a plugin exists\n   */\n  hasPlugin(name: string): boolean {\n    return this.plugins.some(plugin => plugin.name === name);\n  }\n\n  /**\n   * Remove a plugin by name\n   */\n  removePlugin(name: string): void {\n    const index = this.plugins.findIndex(plugin => plugin.name === name);\n    if (index !== -1) {\n      this.plugins.splice(index, 1);\n    }\n  }\n\n  /**\n   * Legacy methods for backward compatibility\n   */\n  async applyBeforeParse(content: string, _filePath?: string): Promise<string> {\n    return this.executeHook('beforeParse', content);\n  }\n\n  async applyAfterParse(parsedContent: ParsedContent, _filePath?: string): Promise<ParsedContent> {\n    return this.executeHook('afterParse', parsedContent);\n  }\n\n  getPlugin(name: string): Plugin | undefined {\n    return this.getPluginByName(name);\n  }\n\n  register(plugin: Plugin): void {\n    this.registerPlugin(plugin);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/PluginSystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/PrismPlugin.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/SiteMapGenerator.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/SyntaxHighlightPlugin.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/TableOfContentsPlugin.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/docsify-plugin.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'element' is defined but never used.",
        "line": 136,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 136,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'designSystem' is defined but never used.",
        "line": 136,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 136,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'element' is defined but never used.",
        "line": 147,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 147,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'designSystem' is defined but never used.",
        "line": 147,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 147,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'element' is defined but never used.",
        "line": 158,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 158,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'designSystem' is defined but never used.",
        "line": 158,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 158,
        "endColumn": 45
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Plugin } from '../../types/plugin.js';\nimport { ParsedContent } from '../../types/parser.js';\nimport { ComponentTemplate } from '../../types/component.js';\n\ninterface DocsifyPluginOptions {\n  basePath?: string;\n  coverpage?: boolean;\n  navbar?: boolean;\n  sidebar?: boolean;\n  themeable?: {\n    responsiveTables: boolean;\n    readyTransition: boolean;\n  };\n}\n\nexport class DocsifyPlugin implements Plugin {\n  name = 'docsify';\n  version = '1.0.0';\n  options: DocsifyPluginOptions;\n  // Hooks are defined in the constructor\n\n  constructor(options: DocsifyPluginOptions = {}) {\n    this.options = {\n      basePath: '/',\n      coverpage: true,\n      navbar: true,\n      sidebar: true,\n      themeable: {\n        responsiveTables: true,\n        readyTransition: true,\n      },\n      ...options,\n    };\n  }\n\n  hooks = {\n    beforeParse: async (content: string): Promise<string> => {\n      // Handle docsify-specific markdown extensions\n      return this.processDocsifyMarkdown(content);\n    },\n\n    afterParse: async (parsed: ParsedContent): Promise<ParsedContent> => {\n      // Add docsify-specific metadata and structure\n      return parsed;\n    },\n\n    beforeGenerate: async (components: ComponentTemplate[]): Promise<ComponentTemplate[]> => {\n      // Add docsify-specific components and styling\n      return this.addDocsifyComponents(components);\n    },\n  };\n\n  private processDocsifyMarkdown(content: string): string {\n    // Process docsify-specific markdown features\n    content = this.processEmbeds(content);\n    content = this.processAlerts(content);\n    content = this.processCodeTabs(content);\n    return content;\n  }\n\n  private processEmbeds(content: string): string {\n    // Handle [!embed] syntax\n    return content.replace(/\\[!embed\\]\\((.*?)\\)/g, (_match, url) => {\n      return `<div class=\"embed-container\">\n        <iframe src=\"${url}\" frameborder=\"0\" allowfullscreen></iframe>\n      </div>`;\n    });\n  }\n\n  private processAlerts(content: string): string {\n    // Handle docsify alert blocks\n    const alertTypes = ['info', 'tip', 'warning', 'danger'];\n    alertTypes.forEach(type => {\n      const regex = new RegExp(`> \\\\[!${type}\\\\]\\\\n([\\\\s\\\\S]*?)(?=\\\\n(?:>|$))`, 'g');\n      content = content.replace(regex, (_match, text) => {\n        return `<div class=\"alert alert-${type}\">${text.trim()}</div>`;\n      });\n    });\n    return content;\n  }\n\n  private processCodeTabs(content: string): string {\n    // Handle code tabs syntax\n    return content.replace(/```tabs([\\\\s\\\\S]*?)```/g, (_match, content) => {\n      const tabs = content.split('====').map((tab: string) => tab.trim());\n      return this.generateCodeTabsHTML(tabs);\n    });\n  }\n\n  private generateCodeTabsHTML(tabs: string[]): string {\n    const tabButtons = tabs\n      .map((tab, index) => {\n        const title = tab.split('\\n')[0];\n        return `<button class=\"tab-button${\n          index === 0 ? ' active' : ''\n        }\" data-tab=\"${index}\">${title}</button>`;\n      })\n      .join('');\n\n    const tabContents = tabs\n      .map((tab, index) => {\n        const content = tab.split('\\n').slice(1).join('\\n');\n        return `<div class=\"tab-content${\n          index === 0 ? ' active' : ''\n        }\" data-tab=\"${index}\">${content}</div>`;\n      })\n      .join('');\n\n    return `<div class=\"tabs-container\">\n      <div class=\"tab-buttons\">${tabButtons}</div>\n      <div class=\"tab-contents\">${tabContents}</div>\n    </div>`;\n  }\n\n  private addDocsifyComponents(components: ComponentTemplate[]): ComponentTemplate[] {\n    // Add docsify-specific components (navbar, sidebar, etc.)\n    if (this.options.navbar) {\n      components.unshift(this.createNavbarComponent());\n    }\n    if (this.options.sidebar) {\n      components.unshift(this.createSidebarComponent());\n    }\n    if (this.options.coverpage) {\n      components.unshift(this.createCoverpageComponent());\n    }\n    return components;\n  }\n\n  private createNavbarComponent(): ComponentTemplate {\n    return {\n      name: 'navbar',\n      path: 'components/navbar.html',\n      type: 'navbar',\n      content: '<nav class=\"app-nav\"></nav>',\n      metadata: { docsify: true },\n      generate: async (element, designSystem) => '<nav class=\"app-nav\"></nav>',\n    };\n  }\n\n  private createSidebarComponent(): ComponentTemplate {\n    return {\n      name: 'sidebar',\n      path: 'components/sidebar.html',\n      type: 'sidebar',\n      content: '<aside class=\"sidebar\"></aside>',\n      metadata: { docsify: true },\n      generate: async (element, designSystem) => '<aside class=\"sidebar\"></aside>',\n    };\n  }\n\n  private createCoverpageComponent(): ComponentTemplate {\n    return {\n      name: 'coverpage',\n      path: 'components/coverpage.html',\n      type: 'coverpage',\n      content: '<section class=\"cover show\"></section>',\n      metadata: { docsify: true },\n      generate: async (element, designSystem) => '<section class=\"cover show\"></section>',\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/services/BaseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/services/ParserService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 168,
        "column": 20,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 168,
        "endColumn": 48
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { BaseService } from './BaseService.js';\nimport { ContentCache, CacheOptions } from '../utils/cache.js';\nimport { ParserError } from '../utils/errors.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { logger } from '../utils/logger.js';\n\n/**\n * Parser service configuration\n */\nexport interface ParserServiceConfig {\n  extensions: string[];\n  ignorePatterns: string[];\n  plugins?: string[];\n  caching?: CacheOptions;\n}\n\n/**\n * Parser result\n */\nexport interface ParseResult {\n  content: Record<string, unknown>;\n  metadata: {\n    filePath: string;\n    lastModified: number;\n    size: number;\n  };\n}\n\n/**\n * Parser service for parsing documentation files\n */\nexport class ParserService extends BaseService {\n  private config: ParserServiceConfig;\n  private cache: ContentCache<ParseResult>;\n  private parsers: Map<string, (content: string, filePath: string) => Record<string, unknown>>;\n\n  constructor(config: ParserServiceConfig) {\n    super('parser-service');\n\n    // Create config with defaults that will be overridden by any values in config\n    this.config = {\n      ...{\n        extensions: ['md', 'markdown'],\n        ignorePatterns: ['node_modules', '.git'],\n      },\n      ...config,\n    };\n\n    this.parsers = new Map();\n\n    // Initialize cache\n    this.cache = new ContentCache<ParseResult>(\n      this.config.caching || {\n        enabled: true,\n        storageType: 'memory',\n      }\n    );\n  }\n\n  /**\n   * Start the parser service\n   */\n  protected async doStart(): Promise<void> {\n    // Register default parsers\n    this.registerParser('md', this.parseMarkdown.bind(this));\n    this.registerParser('markdown', this.parseMarkdown.bind(this));\n\n    // Load plugins if specified\n    if (this.config.plugins && this.config.plugins.length > 0) {\n      for (const plugin of this.config.plugins) {\n        try {\n          // In a real implementation, this would dynamically load plugins\n          logger.debug(`Loading plugin: ${plugin}`);\n        } catch (error) {\n          throw new ParserError(`Failed to load plugin: ${plugin}`, {\n            plugin,\n            error,\n          });\n        }\n      }\n    }\n\n    this.setMetric('parsers', this.parsers.size);\n  }\n\n  /**\n   * Stop the parser service\n   */\n  protected async doStop(): Promise<void> {\n    // Clean up resources\n    this.parsers.clear();\n  }\n\n  /**\n   * Register a parser for a file extension\n   */\n  registerParser(\n    extension: string,\n    parser: (content: string, filePath: string) => Record<string, unknown>\n  ): void {\n    this.parsers.set(extension.toLowerCase(), parser);\n    this.setMetric('parsers', this.parsers.size);\n  }\n\n  /**\n   * Parse a file\n   */\n  async parseFile(filePath: string): Promise<ParseResult> {\n    if (!this.isRunning()) {\n      throw new ParserError('Parser service is not running', {\n        filePath,\n        status: this.getStatus(),\n      });\n    }\n\n    // Check if file exists\n    if (!fs.existsSync(filePath)) {\n      throw new ParserError(`File not found: ${filePath}`, {\n        filePath,\n      });\n    }\n\n    // Get file stats\n    const stats = fs.statSync(filePath);\n\n    // Check if it's a directory\n    if (stats.isDirectory()) {\n      throw new ParserError(`Cannot parse a directory: ${filePath}`, {\n        filePath,\n      });\n    }\n\n    // Check if the file is in the ignore patterns\n    for (const pattern of this.config.ignorePatterns) {\n      if (filePath.includes(pattern)) {\n        throw new ParserError(`File is in ignore pattern: ${filePath}`, {\n          filePath,\n          pattern,\n        });\n      }\n    }\n\n    // Get file extension\n    const extension = path.extname(filePath).slice(1).toLowerCase();\n\n    // Check if we have a parser for this extension\n    if (!this.parsers.has(extension)) {\n      throw new ParserError(`No parser registered for extension: ${extension}`, {\n        filePath,\n        extension,\n      });\n    }\n\n    // Check cache first\n    const cacheKey = `${filePath}:${stats.mtimeMs}`;\n    const cachedResult = this.cache.get(cacheKey);\n\n    if (cachedResult) {\n      this.incrementMetric('cache_hits');\n      return cachedResult;\n    }\n\n    // Read file content\n    const content = fs.readFileSync(filePath, 'utf-8');\n\n    // Parse the content\n    const parser = this.parsers.get(extension)!;\n\n    try {\n      const parsedContent = parser(content, filePath);\n\n      const result: ParseResult = {\n        content: parsedContent,\n        metadata: {\n          filePath,\n          lastModified: stats.mtimeMs,\n          size: stats.size,\n        },\n      };\n\n      // Cache the result\n      this.cache.set(cacheKey, result);\n\n      this.incrementMetric('files_parsed');\n      this.incrementMetric('cache_misses');\n\n      return result;\n    } catch (error) {\n      throw new ParserError(`Failed to parse file: ${filePath}`, {\n        filePath,\n        extension,\n        error,\n      });\n    }\n  }\n\n  /**\n   * Parse a directory recursively\n   */\n  async parseDirectory(dirPath: string): Promise<ParseResult[]> {\n    if (!this.isRunning()) {\n      throw new ParserError('Parser service is not running', {\n        dirPath,\n        status: this.getStatus(),\n      });\n    }\n\n    // Check if directory exists\n    if (!fs.existsSync(dirPath)) {\n      throw new ParserError(`Directory not found: ${dirPath}`, {\n        dirPath,\n      });\n    }\n\n    // Check if it's a directory\n    const stats = fs.statSync(dirPath);\n    if (!stats.isDirectory()) {\n      throw new ParserError(`Not a directory: ${dirPath}`, {\n        dirPath,\n      });\n    }\n\n    const results: ParseResult[] = [];\n\n    // Read directory contents\n    const files = fs.readdirSync(dirPath);\n\n    for (const file of files) {\n      const filePath = path.join(dirPath, file);\n      const fileStats = fs.statSync(filePath);\n\n      // Skip ignored patterns\n      let ignored = false;\n      for (const pattern of this.config.ignorePatterns) {\n        if (filePath.includes(pattern)) {\n          ignored = true;\n          break;\n        }\n      }\n\n      if (ignored) {\n        continue;\n      }\n\n      if (fileStats.isDirectory()) {\n        // Recursively parse subdirectory\n        const subResults = await this.parseDirectory(filePath);\n        results.push(...subResults);\n      } else {\n        // Get file extension\n        const extension = path.extname(file).slice(1).toLowerCase();\n\n        // Check if we have a parser for this extension\n        if (this.parsers.has(extension)) {\n          try {\n            const result = await this.parseFile(filePath);\n            results.push(result);\n          } catch (error) {\n            // Log error but continue with other files\n            logger.error(`Error parsing file ${filePath}:`, error);\n          }\n        }\n      }\n    }\n\n    this.incrementMetric('directories_parsed');\n\n    return results;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getCacheStats(): Promise<Record<string, unknown>> {\n    const stats = await this.cache.getStats();\n    return stats as unknown as Record<string, unknown>;\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n    this.setMetric('cache_hits', 0);\n    this.setMetric('cache_misses', 0);\n  }\n\n  /**\n   * Parse Markdown content\n   * This is a simple implementation - in a real app, you'd use a proper Markdown parser\n   */\n  private parseMarkdown(content: string, filePath: string): Record<string, unknown> {\n    // Extract front matter if present\n    let metadata = {};\n    let mainContent = content;\n\n    const frontMatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n\n    if (frontMatterMatch) {\n      try {\n        metadata = JSON.parse(`{${frontMatterMatch[1]}}`);\n        mainContent = frontMatterMatch[2];\n      } catch (error) {\n        // If parsing fails, assume no front matter\n      }\n    }\n\n    // Extract title from first heading\n    const titleMatch = mainContent.match(/^#\\s+(.*)$/m);\n    const title = titleMatch ? titleMatch[1] : path.basename(filePath, path.extname(filePath));\n\n    // Extract sections\n    const sections = [];\n    const sectionMatches = mainContent.matchAll(/^(#{2,6})\\s+(.*)$/gm);\n\n    for (const match of sectionMatches) {\n      sections.push({\n        level: match[1].length,\n        title: match[2],\n      });\n    }\n\n    return {\n      title,\n      metadata,\n      content: mainContent,\n      sections,\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/EjsTemplateEngine.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'path' is defined but never used.",
        "line": 3,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { TemplateEngine, TemplateEngineOptions } from './TemplateEngine.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as ejs from 'ejs';\nimport { FileSystemError } from '../utils/errors.js';\nimport { tryCatch } from '../utils/errors.js';\n\n/**\n * Interface for EJS template engine options\n */\nexport interface EjsTemplateEngineOptions extends TemplateEngineOptions {\n  /**\n   * Path to the includes directory\n   */\n  includesDir?: string;\n\n  /**\n   * Whether to use strict mode\n   */\n  strict?: boolean;\n\n  /**\n   * Whether to use async rendering\n   */\n  async?: boolean;\n\n  /**\n   * EJS options\n   */\n  ejsOptions?: ejs.Options;\n}\n\n/**\n * EJS template engine implementation\n */\nexport class EjsTemplateEngine extends TemplateEngine {\n  protected options: EjsTemplateEngineOptions;\n\n  constructor(options: EjsTemplateEngineOptions = {}) {\n    super(options);\n    this.options = {\n      ...options,\n      ejsOptions: {\n        async: options.async || false,\n        cache: options.cacheSize && options.cacheSize > 0,\n        ...options.ejsOptions,\n      },\n    };\n\n    // Initialize the template engine\n    this.initialize();\n  }\n\n  /**\n   * Initialize the template engine\n   */\n  private async initialize(): Promise<void> {\n    // Set up includes directory if provided\n    if (this.options.includesDir) {\n      this.options.ejsOptions = {\n        ...this.options.ejsOptions,\n        views: [this.options.includesDir],\n      };\n    }\n  }\n\n  /**\n   * Load a template from the given path\n   * @param templatePath Path to the template file\n   * @returns The loaded template\n   */\n  protected async loadTemplate(templatePath: string): Promise<string> {\n    if (!templatePath || typeof templatePath !== 'string') {\n      throw new Error('Template path must be a non-empty string');\n    }\n\n    // Check if the template is already cached\n    if (this.templateCache.has(templatePath)) {\n      const cached = this.templateCache.get(templatePath);\n      if (typeof cached === 'string') {\n        return cached;\n      }\n      throw new Error(`Invalid cached template type for ${templatePath}`);\n    }\n\n    // Read the template file\n    const templateContent = await tryCatch(\n      () => fs.promises.readFile(templatePath, 'utf-8'),\n      (error: unknown) => {\n        throw new FileSystemError(`Failed to read template file: ${templatePath}`, {\n          path: templatePath,\n          operation: 'read',\n          cause: error,\n        });\n      }\n    );\n\n    // Cache the template if caching is enabled\n    if (this.options.cacheSize && this.options.cacheSize > 0) {\n      // Limit the cache size\n      if (this.templateCache.size >= this.options.cacheSize) {\n        // Remove the oldest entry\n        const firstKey = this.templateCache.keys().next().value;\n        this.templateCache.delete(firstKey);\n      }\n\n      // Add the template to the cache\n      this.templateCache.set(templatePath, templateContent);\n    }\n\n    return templateContent;\n  }\n\n  /**\n   * Render a template with the given data\n   * @param template The template to render\n   * @param data Data to render the template with\n   * @returns The rendered template\n   */\n  protected async renderTemplate(template: string, data: Record<string, unknown>): Promise<string> {\n    if (!template || typeof template !== 'string') {\n      throw new Error('Template must be a non-empty string');\n    }\n\n    // Set up the EJS options\n    const ejsOptions: ejs.Options = {\n      ...this.options.ejsOptions,\n      filename: data.filename && typeof data.filename === 'string' ? data.filename : undefined,\n    };\n\n    // Render the template\n    let rendered: string;\n\n    if (this.options.async) {\n      // Use async rendering\n      rendered = await ejs.render(template, data, ejsOptions);\n    } else {\n      // Use sync rendering\n      if (!ejsOptions.filename) {\n        throw new Error('Filename is required for synchronous EJS rendering');\n      }\n      rendered = await ejs.render(template, data, ejsOptions);\n    }\n\n    // Minify the output if enabled\n    if (this.options.minify) {\n      return this.minifyHtml(rendered);\n    }\n\n    return rendered;\n  }\n\n  /**\n   * Minify HTML content\n   * @param html HTML content to minify\n   * @returns Minified HTML content\n   */\n  private minifyHtml(html: string): string {\n    // Simple minification (just for demonstration)\n    // In a real implementation, you would use a proper HTML minifier\n    return html\n      .replace(/\\s+/g, ' ')\n      .replace(/>\\s+</g, '><')\n      .replace(/\\s+>/g, '>')\n      .replace(/<\\s+/g, '<')\n      .trim();\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/HandlebarsTemplateEngine.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/TemplateEngine.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/TemplateManager.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'TemplateEngineOptions' is defined but never used.",
        "line": 1,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 64,
        "column": 29,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 64,
        "endColumn": 60
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { TemplateEngine, TemplateEngineOptions } from './TemplateEngine.js';\nimport {\n  HandlebarsTemplateEngine,\n  HandlebarsTemplateEngineOptions,\n} from './HandlebarsTemplateEngine.js';\nimport { EjsTemplateEngine, EjsTemplateEngineOptions } from './EjsTemplateEngine.js';\nimport { ParsedContent } from '../../types/parser.js';\nimport { DesignSystem } from '../../types/design.js';\nimport * as path from 'path';\nimport { TemplateError } from '../utils/errors.js';\n\n/**\n * Type of template engine\n */\nexport type TemplateEngineType = 'handlebars' | 'ejs' | 'custom';\n\n/**\n * Interface for template manager options\n */\nexport interface TemplateManagerOptions {\n  /**\n   * The default template engine to use\n   */\n  defaultEngine?: TemplateEngineType;\n\n  /**\n   * Options for the Handlebars template engine\n   */\n  handlebarsOptions?: HandlebarsTemplateEngineOptions;\n\n  /**\n   * Options for the EJS template engine\n   */\n  ejsOptions?: EjsTemplateEngineOptions;\n\n  /**\n   * Custom template engines\n   */\n  customEngines?: Record<string, TemplateEngine>;\n}\n\n/**\n * Template manager for handling different template engines\n */\nexport class TemplateManager {\n  private engines: Map<string, TemplateEngine>;\n  private defaultEngine: TemplateEngineType;\n\n  constructor(options: TemplateManagerOptions = {}) {\n    this.engines = new Map();\n    this.defaultEngine = options.defaultEngine || 'handlebars';\n\n    // Initialize the template engines\n    this.initializeEngines(options);\n  }\n\n  /**\n   * Initialize the template engines\n   * @param options Template manager options\n   */\n  private initializeEngines(options: TemplateManagerOptions): void {\n    // Initialize the Handlebars template engine\n    this.engines.set('handlebars', new HandlebarsTemplateEngine(options.handlebarsOptions));\n    this.engines.set('hbs', this.engines.get('handlebars')!);\n\n    // Initialize the EJS template engine\n    this.engines.set('ejs', new EjsTemplateEngine(options.ejsOptions));\n\n    // Initialize custom template engines\n    if (options.customEngines) {\n      for (const [name, engine] of Object.entries(options.customEngines)) {\n        this.engines.set(name, engine);\n      }\n    }\n  }\n\n  /**\n   * Register a custom template engine\n   * @param name Name of the template engine\n   * @param engine The template engine instance\n   */\n  registerEngine(name: string, engine: TemplateEngine): void {\n    this.engines.set(name, engine);\n  }\n\n  /**\n   * Get a template engine by name\n   * @param name Name of the template engine\n   * @returns The template engine instance\n   */\n  getEngine(name?: string): TemplateEngine {\n    // If no name is provided, use the default engine\n    const engineName = name || this.defaultEngine;\n\n    // Get the template engine\n    const engine = this.engines.get(engineName);\n    if (!engine) {\n      throw new TemplateError(`Template engine not found: ${engineName}`);\n    }\n\n    return engine;\n  }\n\n  /**\n   * Render a template with the given data\n   * @param templatePath Path to the template file\n   * @param data Data to render the template with\n   * @param engineName Optional name of the template engine to use\n   * @returns The rendered template\n   */\n  async render(\n    templatePath: string,\n    data: Record<string, unknown>,\n    engineName?: string\n  ): Promise<string> {\n    // If no engine name is provided, infer it from the template file extension\n    const inferredEngineName = engineName || this.inferEngineFromPath(templatePath);\n\n    // Get the template engine\n    const engine = this.getEngine(inferredEngineName);\n\n    // Render the template\n    return await engine.render(templatePath, data);\n  }\n\n  /**\n   * Render content with the given template\n   * @param content The parsed content to render\n   * @param templatePath Path to the template file\n   * @param designSystem Optional design system to apply\n   * @param engineName Optional name of the template engine to use\n   * @returns The rendered content\n   */\n  async renderContent(\n    content: ParsedContent,\n    templatePath: string,\n    designSystem?: DesignSystem,\n    engineName?: string\n  ): Promise<string> {\n    // If no engine name is provided, infer it from the template file extension\n    const inferredEngineName = engineName || this.inferEngineFromPath(templatePath);\n\n    // Get the template engine\n    const engine = this.getEngine(inferredEngineName);\n\n    // Render the content\n    return await engine.renderContent(content, templatePath, designSystem);\n  }\n\n  /**\n   * Clear the template cache for all engines\n   */\n  clearCache(): void {\n    for (const engine of this.engines.values()) {\n      engine.clearCache();\n    }\n  }\n\n  /**\n   * Infer the template engine from the template file path\n   * @param templatePath Path to the template file\n   * @returns The inferred template engine name\n   */\n  private inferEngineFromPath(templatePath: string): string {\n    const extension = path.extname(templatePath).toLowerCase();\n\n    switch (extension) {\n      case '.hbs':\n      case '.handlebars':\n        return 'handlebars';\n      case '.ejs':\n        return 'ejs';\n      default:\n        return this.defaultEngine;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/docsify-templates.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'designSystem' is defined but never used.",
        "line": 37,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 37,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'designSystem' is defined but never used.",
        "line": 70,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 70,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'designSystem' is defined but never used.",
        "line": 165,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 165,
        "endColumn": 69
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ComponentTemplate } from '../../types/component.js';\nimport { DesignSystem } from '../../types/design.js';\nimport { ContentElement } from '../../types/cms.js';\n\nexport class DocsifyTemplateManager {\n  private designSystem: DesignSystem;\n\n  constructor(designSystem: DesignSystem) {\n    this.designSystem = designSystem;\n  }\n\n  public getTemplate(type: string): ComponentTemplate {\n    switch (type) {\n      case 'markdown':\n        return new MarkdownTemplate(this.designSystem);\n      case 'api':\n        return new APITemplate(this.designSystem);\n      case 'code':\n        return new CodeTemplate(this.designSystem);\n      default:\n        throw new Error(`Template type '${type}' not supported`);\n    }\n  }\n}\n\nclass MarkdownTemplate implements ComponentTemplate {\n  name = 'markdown-template';\n  path = 'templates/markdown.html';\n  content = '';\n  type = 'markdown';\n  private designSystem: DesignSystem;\n\n  constructor(designSystem: DesignSystem) {\n    this.designSystem = designSystem;\n  }\n\n  async generate(element: ContentElement, designSystem: DesignSystem): Promise<string> {\n    const content = element as unknown as { title?: string; body: string };\n    const { title, body } = content;\n    return `\n      <div class=\"markdown-section ${this.designSystem.classNames?.markdownContainer || ''}\">\n        ${title ? `<h1>${title}</h1>` : ''}\n        <div class=\"markdown-body\">\n          ${this.processMarkdownContent(body)}\n        </div>\n      </div>\n    `;\n  }\n\n  private processMarkdownContent(content: string): string {\n    // Apply design system styles to markdown elements\n    return content.replace(\n      /<h([1-6])>/g,\n      (_, level) => `<h${level} class=\"${this.designSystem.classNames?.[`heading${level}`] || ''}\">`\n    );\n  }\n}\n\nclass APITemplate implements ComponentTemplate {\n  name = 'api-template';\n  path = 'templates/api.html';\n  content = '';\n  type = 'api';\n  private designSystem: DesignSystem;\n\n  constructor(designSystem: DesignSystem) {\n    this.designSystem = designSystem;\n  }\n\n  async generate(element: ContentElement, designSystem: DesignSystem): Promise<string> {\n    const content = element as unknown as {\n      method: string;\n      endpoint: string;\n      parameters?: Array<{ name: string; type: string; description: string }>;\n      responses?: Record<string, { description: string; example?: unknown }>;\n    };\n    const { method, endpoint, parameters, responses } = content;\n    return `\n      <div class=\"api-section ${this.designSystem.classNames?.apiContainer || ''}\">\n        <div class=\"api-method ${method.toLowerCase()}\">\n          <span class=\"method\">${method}</span>\n          <span class=\"endpoint\">${endpoint}</span>\n        </div>\n        ${this.generateParameters(parameters)}\n        ${this.generateResponses(responses)}\n      </div>\n    `;\n  }\n\n  private generateParameters(\n    parameters?: Array<{ name: string; type: string; description: string }>\n  ): string {\n    if (!parameters?.length) return '';\n    return `\n      <div class=\"parameters\">\n        <h3>Parameters</h3>\n        <table class=\"${this.designSystem.classNames?.table || ''}\">\n          <thead>\n            <tr>\n              <th>Name</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            ${parameters\n              .map(\n                param => `\n              <tr>\n                <td>${param.name}</td>\n                <td>${param.type}</td>\n                <td>${param.description}</td>\n              </tr>\n            `\n              )\n              .join('')}\n          </tbody>\n        </table>\n      </div>\n    `;\n  }\n\n  private generateResponses(\n    responses?: Record<string, { description: string; example?: unknown }>\n  ): string {\n    if (!responses) return '';\n    return `\n      <div class=\"responses\">\n        <h3>Responses</h3>\n        ${Object.entries(responses)\n          .map(\n            ([code, response]: [string, { description: string; example?: unknown }]) => `\n          <div class=\"response-code\">\n            <span class=\"code\">${code}</span>\n            <span class=\"description\">${response.description}</span>\n          </div>\n          ${\n            response.example\n              ? `\n            <pre><code class=\"language-json\">\n              ${JSON.stringify(response.example, null, 2)}\n            </code></pre>\n          `\n              : ''\n          }\n        `\n          )\n          .join('')}\n      </div>\n    `;\n  }\n}\n\nclass CodeTemplate implements ComponentTemplate {\n  name = 'code-template';\n  path = 'templates/code.html';\n  content = '';\n  type = 'code';\n  private designSystem: DesignSystem;\n\n  constructor(designSystem: DesignSystem) {\n    this.designSystem = designSystem;\n  }\n\n  async generate(element: ContentElement, designSystem: DesignSystem): Promise<string> {\n    const content = element as unknown as { language: string; code: string; filename?: string };\n    const { language, code, filename } = content;\n    return `\n      <div class=\"code-section ${this.designSystem.classNames?.codeContainer || ''}\">\n        ${filename ? `<div class=\"filename\">${filename}</div>` : ''}\n        <pre><code class=\"language-${language}\">\n          ${this.escapeHtml(code)}\n        </code></pre>\n      </div>\n    `;\n  }\n\n  private escapeHtml(str: string): string {\n    const escapeMap: { [key: string]: string } = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#039;',\n    };\n    return str.replace(/[&<>\"']/g, m => escapeMap[m]);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/helpers/component-helper.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/test-compile.ts",
    "messages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 32,
        "column": 1,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 32,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [436, 498], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * This is a simple TypeScript file to test compilation\n */\n\n// Basic types\nconst str = 'Hello, world!';\nconst num = 42;\nconst bool = true;\n\n// Array\nconst arr: number[] = [1, 2, 3];\n\n// Object\ninterface Person {\n  name: string;\n  age: number;\n}\n\nconst person: Person = {\n  name: 'John',\n  age: 30,\n};\n\n// Function\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n\n// Export something\nexport { greet, Person };\n\nconsole.log(str, num, bool, arr, person, greet('TypeScript'));\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/themes/DocsifyThemeAdapter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/themes/docsify-theme-manager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/tools/plugin-docs-generator.ts",
    "messages": [
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Replace `·?·String((option·as·unknown).default)` with `⏎··············?·String((option·as·unknown).default)⏎·············`",
        "line": 91,
        "column": 54,
        "nodeType": null,
        "messageId": "replace",
        "endLine": 91,
        "endColumn": 92,
        "fix": {
          "range": [2440, 2478],
          "text": "\n              ? String((option as unknown).default)\n             "
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 1,
    "fixableWarningCount": 0,
    "source": "import * as fs from 'fs';\nimport * as path from 'path';\nimport { Plugin } from '../types/plugin.js';\n\ninterface PluginDocumentation {\n  name: string;\n  description: string;\n  hooks: string[];\n  options: {\n    name: string;\n    type: string;\n    description: string;\n    required: boolean;\n    default?: string;\n  }[];\n  examples: string[];\n}\n\nexport class PluginDocsGenerator {\n  private plugins: Plugin[] = [];\n  private outputDir: string;\n\n  constructor(outputDir: string) {\n    this.outputDir = outputDir;\n  }\n\n  /**\n   * Add a plugin to document\n   */\n  addPlugin(plugin: Plugin): void {\n    this.plugins.push(plugin);\n  }\n\n  /**\n   * Generate documentation for all plugins\n   */\n  async generateDocs(): Promise<void> {\n    // Create output directory if it doesn't exist\n    if (!fs.existsSync(this.outputDir)) {\n      fs.mkdirSync(this.outputDir, { recursive: true });\n    }\n\n    // Generate index file\n    await this.generateIndexFile();\n\n    // Generate docs for each plugin\n    for (const plugin of this.plugins) {\n      await this.generatePluginDoc(plugin);\n    }\n  }\n\n  /**\n   * Generate index file\n   */\n  private async generateIndexFile(): Promise<void> {\n    let content = '# Plugin Documentation\\n\\n';\n    content += 'This documentation describes the available plugins for the Site Generator.\\n\\n';\n    content += '## Available Plugins\\n\\n';\n\n    for (const plugin of this.plugins) {\n      content += `- [${plugin.name}](${plugin.name}.md): ${\n        plugin.description || 'No description'\n      }\\n`;\n    }\n\n    const filePath = path.join(this.outputDir, 'README.md');\n    await fs.promises.writeFile(filePath, content);\n  }\n\n  /**\n   * Generate documentation for a specific plugin\n   */\n  private async generatePluginDoc(plugin: Plugin): Promise<void> {\n    const doc: PluginDocumentation = {\n      name: plugin.name,\n      description: plugin.description || 'No description available.',\n      hooks: Object.keys(plugin.hooks || {}),\n      options: [],\n      examples: [],\n    };\n\n    // Extract options from plugin\n    if (plugin.options) {\n      for (const [name, option] of Object.entries(plugin.options)) {\n        doc.options.push({\n          name,\n          type: (option as unknown).type || 'any',\n          description: (option as unknown).description || 'No description available.',\n          required: (option as unknown).required || false,\n          default:\n            (option as unknown).default !== undefined ? String((option as unknown).default) : undefined,\n        });\n      }\n    }\n\n    // Generate markdown content\n    let content = `# ${doc.name} Plugin\\n\\n`;\n    content += `${doc.description}\\n\\n`;\n\n    // Hooks\n    content += '## Hooks\\n\\n';\n    if (doc.hooks.length > 0) {\n      for (const hook of doc.hooks) {\n        content += `- \\`${hook}\\`: ${this.getHookDescription(hook)}\\n`;\n      }\n    } else {\n      content += 'This plugin does not implement any hooks.\\n';\n    }\n    content += '\\n';\n\n    // Options\n    content += '## Options\\n\\n';\n    if (doc.options.length > 0) {\n      content += '| Option | Type | Description | Required | Default |\\n';\n      content += '|--------|------|-------------|----------|--------|\\n';\n\n      for (const option of doc.options) {\n        content += `| \\`${option.name}\\` | \\`${option.type}\\` | ${option.description} | ${\n          option.required ? 'Yes' : 'No'\n        } | ${option.default || '-'} |\\n`;\n      }\n    } else {\n      content += 'This plugin does not have any options.\\n';\n    }\n    content += '\\n';\n\n    // Examples\n    content += '## Examples\\n\\n';\n    if (doc.examples.length > 0) {\n      for (const example of doc.examples) {\n        content += '```javascript\\n';\n        content += example;\n        content += '\\n```\\n\\n';\n      }\n    } else {\n      content += 'No examples available.\\n';\n    }\n\n    const filePath = path.join(this.outputDir, `${plugin.name}.md`);\n    await fs.promises.writeFile(filePath, content);\n  }\n\n  /**\n   * Get description for a hook\n   */\n  private getHookDescription(hook: string): string {\n    const descriptions: Record<string, string> = {\n      beforeParse: 'Called before parsing content, allows modifying the raw content.',\n      afterParse: 'Called after parsing content, allows modifying the parsed content.',\n      beforeGenerate: 'Called before generating components, allows modifying the component data.',\n      afterGenerate:\n        'Called after generating components, allows modifying the generated components.',\n      beforeBuild: 'Called before building the website, allows modifying the build configuration.',\n      afterBuild: 'Called after building the website, allows performing post-build operations.',\n    };\n\n    return descriptions[hook] || 'No description available.';\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/build.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/build.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/cms.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/cms.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/component.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/component.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/design.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/design.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/handlebars.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/index.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/openapi.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/parser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/plugin.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/workbox.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/cache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/config-presets.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/config-validator.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/dependency-graph.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/dev-server-class.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/dev-server.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/errors.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_promise' is defined but never used.",
        "line": 144,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 144,
        "endColumn": 53
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { logger } from './logger.js';\n\n/**\n * Base error class for all site generator errors\n * Provides standardized error handling with error codes and contextual information\n */\nexport class SiteGeneratorError extends Error {\n  code: string;\n  context?: Record<string, unknown>;\n\n  constructor(message: string, code: string, context?: Record<string, unknown>) {\n    super(message);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.context = context;\n\n    // Capture stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  /**\n   * Returns a formatted error message with context information\n   */\n  getFormattedMessage(): string {\n    let message = `[${this.code}] ${this.message}`;\n\n    if (this.context && Object.keys(this.context).length > 0) {\n      message += '\\nContext:';\n      for (const [key, value] of Object.entries(this.context)) {\n        message += `\\n  ${key}: ${JSON.stringify(value)}`;\n      }\n    }\n\n    return message;\n  }\n}\n\n/**\n * Error thrown when there's an issue with configuration\n */\nexport class ConfigurationError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, 'CONFIG_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with parsing documentation\n */\nexport class ParserError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, 'PARSER_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with generating components\n */\nexport class GeneratorError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, 'GENERATOR_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with building the website\n */\nexport class BuildError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, 'BUILD_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with plugins\n */\nexport class PluginError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, 'PLUGIN_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with file system operations\n */\nexport class FileSystemError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, 'FS_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when a feature is not implemented\n */\nexport class NotImplementedError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, 'NOT_IMPLEMENTED', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with templates\n */\nexport class TemplateError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, 'TEMPLATE_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with validation\n */\nexport class ValidationError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, 'VALIDATION_ERROR', context);\n  }\n}\n\n/**\n * Global error handler for uncaught exceptions\n */\nexport function setupGlobalErrorHandler(verbose = false): void {\n  process.on('uncaughtException', error => {\n    logger.error('\\n🔥 Uncaught Exception:');\n\n    if (error instanceof SiteGeneratorError) {\n      logger.error(error.getFormattedMessage());\n    } else {\n      logger.error(`[UNKNOWN_ERROR] ${error.message}`);\n    }\n\n    if (verbose) {\n      logger.error('\\nStack Trace:');\n      logger.error(error.stack);\n    } else {\n      logger.error('\\nRun with --verbose flag for more details.');\n    }\n\n    process.exit(1);\n  });\n\n  process.on('unhandledRejection', (reason, _promise) => {\n    logger.error('\\n🔥 Unhandled Promise Rejection:');\n\n    if (reason instanceof SiteGeneratorError) {\n      logger.error(reason.getFormattedMessage());\n    } else {\n      logger.error(`[UNHANDLED_REJECTION] ${reason}`);\n    }\n\n    if (verbose) {\n      logger.error('\\nStack Trace:');\n      logger.error((reason as Error).stack);\n    } else {\n      logger.error('\\nRun with --verbose flag for more details.');\n    }\n\n    process.exit(1);\n  });\n}\n\n/**\n * Error handler for async functions\n * @param fn Async function to wrap with error handling\n * @returns Wrapped function with error handling\n */\nexport function withErrorHandling<T extends unknown[], R>(\n  fn: (...args: T) => Promise<R>\n): (...args: T) => Promise<R> {\n  return async (...args: T): Promise<R> => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      if (error instanceof SiteGeneratorError) {\n        throw error;\n      } else {\n        throw new SiteGeneratorError(\n          (error as Error).message || 'Unknown error occurred',\n          'INTERNAL_ERROR',\n          { originalError: error }\n        );\n      }\n    }\n  };\n}\n\n/**\n * Try-catch wrapper for async functions\n * @param fn Function to execute\n * @param errorHandler Optional error handler\n * @returns Result of the function or error handler\n */\nexport async function tryCatch<T>(\n  fn: () => Promise<T>,\n  errorHandler?: (error: unknown) => T | Promise<T>\n): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (errorHandler) {\n      return await errorHandler(error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Try-catch wrapper for sync functions\n * @param fn Function to execute\n * @param errorHandler Optional error handler\n * @returns Result of the function or error handler\n */\nexport function tryCatchSync<T>(fn: () => T, errorHandler?: (error: unknown) => T): T {\n  try {\n    return fn();\n  } catch (error) {\n    if (errorHandler) {\n      return errorHandler(error);\n    }\n    throw error;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/file-watcher.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/incremental.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/performance.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
