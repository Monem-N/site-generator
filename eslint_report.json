[{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/Builder.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_components' is defined but never used.","line":108,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":108,"endColumn":61}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BuildConfig, ComponentTemplate } from '../types/index.js';\nimport type { InputOptions, OutputOptions, RollupBuild, ManualChunksOption } from 'rollup';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { rollup } from 'rollup';\nimport { nodeResolve } from '@rollup/plugin-node-resolve';\nimport { logger } from './utils/logger.js';\n\n// Import these dynamically to avoid ESM issues\nlet babel;\nlet commonjs;\nlet terser;\nlet image;\nlet postcss;\nlet autoprefixer;\nlet cssnano;\n\n// Load plugins dynamically\nasync function loadPlugins() {\n  const babelModule = await import('@rollup/plugin-babel');\n  babel = babelModule.babel;\n\n  const commonjsModule = await import('@rollup/plugin-commonjs');\n  commonjs = commonjsModule.default;\n\n  const terserModule = await import('rollup-plugin-terser');\n  terser = terserModule.terser;\n\n  const imageModule = await import('@rollup/plugin-image');\n  image = imageModule.default;\n\n  const postcssModule = await import('rollup-plugin-postcss');\n  postcss = postcssModule.default;\n\n  const autoprefixerModule = await import('autoprefixer');\n  autoprefixer = autoprefixerModule.default;\n\n  const cssnanoModule = await import('cssnano');\n  cssnano = cssnanoModule.default;\n}\n\nexport class Builder {\n  private config: BuildConfig;\n\n  constructor(config: BuildConfig) {\n    this.config = config;\n  }\n\n  public async build(components: ComponentTemplate[]): Promise<void> {\n    try {\n      // 0. Load plugins\n      await loadPlugins();\n\n      // 1. Prepare output directory\n      await this.prepareOutputDirectory();\n\n      // 2. Generate entry points\n      const entryPoints = await this.generateEntryPoints(components);\n\n      // 3. Configure build\n      const buildConfig = this.createBuildConfig(entryPoints);\n\n      // 4. Execute build\n      await this.executeBuild(buildConfig);\n\n      // 5. Process assets\n      await this.processAssets();\n\n      // 6. Generate service worker if needed\n      if (this.config.optimization?.splitChunks) {\n        await this.generateServiceWorker();\n      }\n\n      logger.info('Build completed successfully!');\n    } catch (error) {\n      logger.error('Build failed:', { error });\n      throw error;\n    }\n  }\n\n  private async prepareOutputDirectory(): Promise<void> {\n    await fs.rm(this.config.outDir, { recursive: true, force: true });\n    await fs.mkdir(this.config.outDir, { recursive: true });\n  }\n\n  private async generateEntryPoints(components: ComponentTemplate[]): Promise<Map<string, string>> {\n    const entryPoints = new Map<string, string>();\n    const srcDir = path.join(this.config.outDir, 'src');\n    await fs.mkdir(srcDir, { recursive: true });\n\n    // Generate main entry point\n    const mainEntry = this.generateMainEntry(components);\n    await fs.writeFile(path.join(srcDir, 'index.tsx'), mainEntry, 'utf-8');\n    entryPoints.set('main', path.join(srcDir, 'index.tsx'));\n\n    // Generate component entry points for code splitting\n    if (this.config.optimization?.splitChunks) {\n      for (const component of components) {\n        const componentPath = path.join(srcDir, `${component.name}.tsx`);\n        await fs.writeFile(componentPath, component.content, 'utf-8');\n        entryPoints.set(component.name, componentPath);\n      }\n    }\n\n    return entryPoints;\n  }\n\n  private generateMainEntry(_components: ComponentTemplate[]): string {\n    return `import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App.js';\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n`;\n  }\n\n  private createBuildConfig(entryPoints: Map<string, string>): InputOptions {\n    const plugins = [\n      nodeResolve({\n        extensions: ['.js', '.jsx', '.ts', '.tsx'],\n      }),\n      commonjs(),\n      babel({\n        presets: ['@babel/preset-react', '@babel/preset-typescript'],\n        babelHelpers: 'bundled',\n      }),\n      postcss({\n        plugins: [autoprefixer(), this.config.optimization?.minify ? cssnano() : false].filter(\n          Boolean\n        ),\n        minimize: this.config.optimization?.minify,\n      }),\n      image(),\n    ];\n\n    if (this.config.optimization?.minify) {\n      plugins.push(terser());\n    }\n\n    return {\n      input: Object.fromEntries(entryPoints),\n      plugins,\n    } as InputOptions;\n  }\n\n  private generateChunkConfig(): ManualChunksOption {\n    return (id: string) => {\n      if (id.includes('node_modules')) {\n        return 'vendor';\n      }\n      return undefined;\n    };\n  }\n\n  private async executeBuild(config: InputOptions): Promise<void> {\n    const outputOptions: OutputOptions = {\n      dir: this.config.outDir,\n      format: 'esm',\n      sourcemap: true,\n      manualChunks: this.config.optimization?.splitChunks ? this.generateChunkConfig() : undefined,\n    };\n    const bundle: RollupBuild = await rollup(config as InputOptions);\n    bundle.write(outputOptions);\n    await bundle.close();\n  }\n\n  private async processAssets(): Promise<void> {\n    if (this.config.assets?.images?.optimize) {\n      await this.optimizeImages();\n    }\n\n    if (this.config.assets?.fonts?.preload) {\n      await this.processFonts();\n    }\n  }\n\n  private async optimizeImages(): Promise<void> {\n    const sharp = await import('sharp');\n    const assetsDir = path.join(this.config.outDir, 'assets');\n    const images = await fs.readdir(assetsDir);\n\n    for (const image of images) {\n      if (!/\\.(jpe?g|png|gif|webp)$/i.test(image)) continue;\n\n      // Process image with sharp\n      const imagePath = path.join(assetsDir, image);\n      const optimizedImage = await sharp\n        .default(imagePath)\n        .resize(1920, 1080, { fit: 'inside', withoutEnlargement: true })\n        .toFormat('webp', { quality: 80 })\n        .toBuffer();\n      await fs.writeFile(imagePath.replace(/\\.[^.]+$/, '.webp'), optimizedImage);\n    }\n  }\n\n  private async processFonts(): Promise<void> {\n    const fontsDir = path.join(this.config.outDir, 'fonts');\n    const fonts = await fs.readdir(fontsDir);\n\n    // Generate preload links for fonts\n    const preloadLinks = fonts\n      .filter(font => /\\.(woff2?)$/i.test(font))\n      .map(\n        font =>\n          `<link rel=\"preload\" href=\"/fonts/${font}\" as=\"font\" type=\"font/${font\n            .split('.')\n            .pop()}\" crossorigin>`\n      );\n\n    // Inject preload links into HTML\n    const htmlPath = path.join(this.config.outDir, 'index.html');\n    let html = await fs.readFile(htmlPath, 'utf-8');\n    html = html.replace('</head>', `${preloadLinks.join('\\n')}\\n</head>`);\n    await fs.writeFile(htmlPath, html, 'utf-8');\n  }\n\n  private async generateServiceWorker(): Promise<void> {\n    const workbox = await import('workbox-build');\n    await workbox.generateSW({\n      swDest: path.join(this.config.outDir, 'service-worker.js'),\n      globDirectory: this.config.outDir,\n      globPatterns: ['**/*.{js,css,html,png,jpg,jpeg,gif,svg,woff,woff2}'],\n      skipWaiting: true,\n      clientsClaim: true,\n      runtimeCaching: [\n        {\n          urlPattern: /\\.(?:png|jpg|jpeg|svg|gif)$/,\n          handler: 'CacheFirst',\n          options: {\n            cacheName: 'images',\n            expiration: {\n              maxEntries: 60,\n              maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days\n            },\n          },\n        },\n        {\n          urlPattern: /\\.(?:js|css)$/,\n          handler: 'StaleWhileRevalidate',\n          options: {\n            cacheName: 'static-resources',\n          },\n        },\n      ],\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/CMSIntegrationModule.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[235,238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[235,238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":16,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":65}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient, ContentfulClientApi } from 'contentful';\nimport { ParsedContent } from '../types/parser.js';\nimport { logger } from './utils/logger.js';\n\nexport class CMSIntegrationModule {\n  private client: ContentfulClientApi<any>;\n\n  constructor(spaceId: string, accessToken: string) {\n    this.client = createClient({\n      space: spaceId,\n      accessToken: accessToken,\n    });\n  }\n\n  // Implement the Parser interface's parse method\n  async parse(source: string, _options?: Record<string, unknown>): Promise<ParsedContent> {\n    try {\n      // Assuming source is an entry ID\n      return await this.getEntry(source);\n    } catch (error) {\n      logger.error('Error parsing Contentful entry:', error);\n      throw error;\n    }\n  }\n\n  async getEntry(entryId: string): Promise<ParsedContent> {\n    try {\n      const entry = await this.client.getEntry(entryId);\n\n      // Extract relevant information from Contentful entry\n      // Add type assertions for entry fields\n      const title = String(entry.fields.title || '');\n      const description = String(entry.fields.description || '');\n      const content = String(entry.fields.content || '');\n\n      // Structure the extracted information into ParsedContent format\n      const parsedContent: ParsedContent = {\n        title: title || 'Contentful Entry',\n        description: description || '',\n        metadata: {},\n        sections: [\n          {\n            type: 'section',\n            title: 'Content',\n            content: content || 'No content available.',\n          },\n        ],\n        assets: [],\n        references: [],\n      };\n\n      return parsedContent;\n    } catch (error) {\n      logger.error('Error fetching Contentful entry:', error);\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/DocsifyIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":45,"column":29,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":45,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ParserFactory } from './parsers/ParserFactory.js';\nimport { PluginManager } from './plugins/PluginManager.js';\nimport { MermaidPlugin } from './plugins/MermaidPlugin.js';\nimport { CrossReferencePlugin } from './plugins/CrossReferencePlugin.js';\nimport { PrismPlugin } from './plugins/PrismPlugin.js';\nimport { NavigationGenerator } from './navigation/NavigationGenerator.js';\nimport { DocsifyThemeAdapter } from './themes/DocsifyThemeAdapter.js';\nimport * as path from 'path';\nimport { logger } from './utils/logger.js';\n\nexport class DocsifyIntegration {\n  private parserFactory: ParserFactory;\n  private pluginManager: PluginManager;\n  private navigationGenerator: NavigationGenerator;\n  private themeAdapter: DocsifyThemeAdapter;\n  private sourceDir: string;\n\n  constructor(sourceDir: string, theme = 'vue', ignorePaths: string[] = []) {\n    this.sourceDir = sourceDir;\n\n    // Initialize components\n    this.parserFactory = new ParserFactory();\n    this.pluginManager = new PluginManager();\n    this.navigationGenerator = new NavigationGenerator(sourceDir, ignorePaths);\n    this.themeAdapter = new DocsifyThemeAdapter(theme);\n\n    // Register plugins\n    this.registerPlugins();\n  }\n\n  private registerPlugins() {\n    // Register Mermaid plugin\n    this.pluginManager.register(new MermaidPlugin());\n\n    // Register Cross-Reference plugin\n    this.pluginManager.register(new CrossReferencePlugin(this.sourceDir));\n\n    // Register Prism plugin for syntax highlighting\n    this.pluginManager.register(new PrismPlugin());\n  }\n\n  async parseFile(filePath: string): Promise<unknown> {\n    try {\n      const fileExtension = path.extname(filePath).slice(1);\n      const content = await require('fs').promises.readFile(filePath, 'utf-8');\n\n      // Apply plugins before parsing\n      const processedContent = await this.pluginManager.applyBeforeParse(content, filePath);\n\n      // Parse content\n      const parser = this.parserFactory.getParser(fileExtension || 'markdown');\n      let parsedContent = await parser.parse(processedContent, { filePath });\n\n      // Apply plugins after parsing\n      parsedContent = await this.pluginManager.applyAfterParse(parsedContent, filePath);\n\n      return parsedContent;\n    } catch (error) {\n      logger.error(`Error parsing file ${filePath}:`, error);\n      throw error;\n    }\n  }\n\n  async generateNavigation(): Promise<unknown> {\n    return await this.navigationGenerator.generate();\n  }\n\n  getThemeStyles(): unknown {\n    return this.themeAdapter.getThemeStyles();\n  }\n\n  generateThemeCSS(): string {\n    return this.themeAdapter.generateThemeCSS();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/DocsifyWebsiteGenerator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2828,2831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2828,2831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3565,3568],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3565,3568],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WebsiteGeneratorConfig, defaultConfig } from '../config/generator.config.js';\nimport { ParsedContent } from '../types/parser.js';\nimport { DocsifyIntegration } from './DocsifyIntegration.js';\nimport { ComponentGenerator } from '../component-generator.js';\nimport { Builder } from './Builder.js';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { logger } from './utils/logger.js';\n\nexport class DocsifyWebsiteGenerator {\n  private config: WebsiteGeneratorConfig;\n  private docsifyIntegration: DocsifyIntegration;\n  private componentGenerator: ComponentGenerator;\n\n  constructor(config: Partial<WebsiteGeneratorConfig> = {}) {\n    this.config = { ...defaultConfig, ...config };\n\n    // Initialize Docsify integration\n    this.docsifyIntegration = new DocsifyIntegration(\n      this.config.sourceDir,\n      this.config.designSystem?.name || 'vue',\n      this.config.parser.ignorePatterns\n    );\n\n    // Initialize component generator\n    this.componentGenerator = new ComponentGenerator(this.config.designSystem);\n  }\n\n  public async generate(): Promise<void> {\n    try {\n      logger.debug('Starting website generation with Docsify integration...');\n\n      // 1. Parse documentation sources\n      const parsedContent = await this.parseDocumentation();\n\n      // 2. Generate React components\n      const components = await this.generateComponents(parsedContent);\n\n      // 3. Apply design system\n      const styledComponents = await this.applyDesignSystem(components);\n\n      // 4. Generate tests\n      await this.generateTests(styledComponents);\n\n      // 5. Build and optimize\n      await this.build(styledComponents);\n\n      logger.debug('Website generation completed successfully!');\n    } catch (error) {\n      logger.error('Website generation failed:', error);\n      throw error;\n    }\n  }\n\n  private async parseDocumentation(): Promise<ParsedContent[]> {\n    logger.debug('Parsing documentation...');\n\n    const sourceDir = path.resolve(this.config.sourceDir);\n    const files = await this.getDocumentationFiles(sourceDir);\n    const parsedContent: ParsedContent[] = [];\n\n    // Generate navigation\n    const navigation = await this.docsifyIntegration.generateNavigation();\n\n    for (const file of files) {\n      logger.debug(`Parsing file: ${file}`);\n\n      try {\n        // Parse file using Docsify integration\n        const parsed = await this.docsifyIntegration.parseFile(file);\n\n        // Add navigation data\n        parsed.navigation = navigation;\n\n        // Add theme data\n        parsed.theme = this.docsifyIntegration.getThemeStyles();\n\n        parsedContent.push(parsed);\n      } catch (error) {\n        logger.error(`Error parsing file ${file}:`, error);\n      }\n    }\n\n    return parsedContent;\n  }\n\n  private async generateComponents(parsedContent: ParsedContent[]): Promise<any[]> {\n    logger.debug('Generating components...');\n\n    const components: unknown[] = [];\n\n    for (const content of parsedContent) {\n      try {\n        // Generate component using the component generator\n        // Cast content to any to bypass type checking\n        const component = await this.componentGenerator.generatePage(content as unknown);\n\n        components.push({\n          name: this.getComponentName(content.title),\n          path: this.getOutputPath(content),\n          content: component,\n        });\n      } catch (error) {\n        logger.error(`Error generating component for ${content.title}:`, error);\n      }\n    }\n\n    return components;\n  }\n\n  private async applyDesignSystem(components: unknown[]): Promise<any[]> {\n    logger.debug('Applying design system...');\n\n    // Generate theme CSS\n    const themeCSS = this.docsifyIntegration.generateThemeCSS();\n\n    // Save theme CSS to output directory\n    const themePath = path.join(this.config.outputDir, 'theme.css');\n    await fs.mkdir(path.dirname(themePath), { recursive: true });\n    await fs.writeFile(themePath, themeCSS);\n\n    return components;\n  }\n\n  private async generateTests(components: unknown[]): Promise<void> {\n    if (!this.config.testing.components.unit && !this.config.testing.components.integration) {\n      return;\n    }\n\n    logger.debug('Generating tests...');\n\n    const testGenerator = await import('./TestGenerator.js').then(\n      m => new m.TestGenerator(this.config.testing)\n    );\n    await testGenerator.generateTests(components as unknown);\n  }\n\n  private async build(components: unknown[]): Promise<void> {\n    logger.debug('Building website...');\n\n    const buildConfig: unknown = {\n      target: 'production',\n      outDir: this.config.outputDir,\n      optimization: this.config.build.optimization,\n      assets: this.config.build.assets,\n    };\n\n    const builder = new Builder(buildConfig);\n    await builder.build(components as unknown);\n  }\n\n  private async getDocumentationFiles(sourceDir: string): Promise<string[]> {\n    const files: string[] = [];\n    const entries = await fs.readdir(sourceDir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(sourceDir, entry.name);\n\n      // Skip ignored paths\n      if (this.shouldIgnore(entry.name)) {\n        continue;\n      }\n\n      if (entry.isDirectory()) {\n        files.push(...(await this.getDocumentationFiles(fullPath)));\n      } else if (this.isDocumentationFile(entry.name)) {\n        files.push(fullPath);\n      }\n    }\n\n    return files;\n  }\n\n  private shouldIgnore(name: string): boolean {\n    return (\n      name.startsWith('.') ||\n      name === 'node_modules' ||\n      (this.config.parser.ignorePatterns?.includes(name) ?? false)\n    );\n  }\n\n  private isDocumentationFile(filename: string): boolean {\n    const ext = path.extname(filename).slice(1);\n    return this.config.parser.extensions?.includes(ext) ?? false;\n  }\n\n  private getComponentName(title: string): string {\n    return title.replace(/[^a-zA-Z0-9]/g, '').replace(/^[0-9]/, 'Page');\n  }\n\n  private getOutputPath(content: ParsedContent): string {\n    // Generate output path based on the original file path\n    if (content.metadata && content.metadata.originalPath) {\n      // Cast originalPath to string to bypass type checking\n      const originalPath = content.metadata.originalPath as string;\n      const relativePath = path.relative(this.config.sourceDir, originalPath);\n      const dirPath = path.dirname(relativePath);\n      const baseName = path.basename(relativePath, path.extname(relativePath));\n\n      return path.join(dirPath, `${baseName}.jsx`);\n    }\n\n    // Fallback to using the title\n    return `${this.getComponentName(content.title)}.jsx`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/OpenAPIParser.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":5,"column":23,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":5,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ParsedContent } from '../types/index.js';\nimport { Parser } from './parsers/Parser.js';\nimport { logger } from './utils/logger.js';\n// Using require for SwaggerParser due to TypeScript compatibility issues\nconst SwaggerParser = require('swagger-parser');\n\nexport class OpenAPIParser implements Parser {\n  async parse(source: string, options?: Record<string, unknown>): Promise<ParsedContent> {\n    try {\n      // Parse the OpenAPI content using SwaggerParser\n      // Pass options to SwaggerParser if provided\n      const swaggerOptions = (options as Record<string, unknown>) || {};\n      const api = (await SwaggerParser.parse(source, swaggerOptions)) as {\n        openapi: string;\n        info: {\n          title: string;\n          description?: string;\n        };\n        paths: {\n          [path: string]: {\n            [method: string]: {\n              summary?: string;\n              description?: string;\n              parameters?: unknown[];\n            };\n          };\n        };\n      };\n\n      // Extract relevant information from OpenAPI object\n      const title = api.info.title;\n      const description = api.info.description;\n      const paths = api.paths;\n\n      // Structure the extracted information into ParsedContent format\n      const parsedContent: ParsedContent = {\n        title: title || 'API Documentation',\n        description: description || '',\n        metadata: {},\n        sections: [\n          {\n            type: 'section',\n            title: 'Overview',\n            content: description || 'No overview available.',\n          },\n          {\n            type: 'section',\n            title: 'API Endpoints',\n            content: this.generateEndpointsContent(paths),\n          },\n        ],\n        assets: [],\n        references: [],\n      };\n\n      return parsedContent;\n    } catch (error) {\n      logger.error('Error parsing OpenAPI content:', error);\n      throw error;\n    }\n  }\n\n  private generateEndpointsContent(\n    paths: Record<\n      string,\n      {\n        [method: string]: {\n          summary?: string;\n          description?: string;\n          parameters?: unknown[];\n        };\n      }\n    >\n  ): string {\n    let endpointsContent = '';\n    for (const path in paths as Record<string, unknown>) {\n      if (Object.prototype.hasOwnProperty.call(paths, path)) {\n        const pathItem = paths[path];\n        for (const method in pathItem) {\n          if (Object.prototype.hasOwnProperty.call(pathItem, method)) {\n            const operation = pathItem[method];\n            endpointsContent += `### ${method.toUpperCase()} ${path}\\n`;\n            endpointsContent += `${operation.summary || 'No summary available.'}\\n\\n`;\n            endpointsContent += `${operation.description || 'No description available.'}\\n\\n`;\n          }\n        }\n      }\n    }\n    return endpointsContent;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/TestGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/WebsiteGenerator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'element' is defined but never used.","line":150,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":150,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'designSystem' is defined but never used.","line":150,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":150,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WebsiteGeneratorConfig, defaultConfig } from '../config/generator.config.js';\nimport { ParsedContent } from '../types/parser.js';\nimport { Plugin } from '../types/plugin.js';\nimport { ComponentTemplate } from '../types/component.js';\nimport { BuildConfig } from '../types/index.js';\nimport { DesignSystem } from '../types/design.js';\nimport { DocumentationParserFactory } from '../parser-implementation.js';\nimport { ComponentGenerator } from '../component-generator.js';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { logger } from './utils/logger.js';\n\nexport class WebsiteGenerator {\n  private config: WebsiteGeneratorConfig;\n  private parserFactory: typeof DocumentationParserFactory;\n  private componentGenerator: ComponentGenerator;\n  private plugins: Plugin[] = [];\n\n  constructor(config: Partial<WebsiteGeneratorConfig> = {}) {\n    this.config = { ...defaultConfig, ...config };\n    this.parserFactory = DocumentationParserFactory;\n    if (\n      this.config.cms?.type === 'contentful' &&\n      this.config.cms?.spaceId &&\n      this.config.cms?.accessToken\n    ) {\n      import('./CMSIntegrationModule.js').then(CMSIntegrationModule => {\n        const cmsModule = new CMSIntegrationModule.CMSIntegrationModule(\n          this.config.cms?.spaceId as string,\n          this.config.cms?.accessToken as string\n        );\n        this.parserFactory.prototype.register('contentful', cmsModule);\n      });\n    }\n    // Convert designSystem config to DesignSystem interface implementation\n    const designSystem: DesignSystem = {\n      type: this.config.designSystem.type,\n      importPath: this.config.designSystem.importPath,\n      classNames: this.config.designSystem.styles.components || {},\n      pageComponents: Object.keys(this.config.designSystem.components || {}),\n      getConfigForType: (elementType: string) => ({\n        classMapping: this.config.designSystem.styles.components?.[elementType] || {},\n        components: Object.keys(this.config.designSystem.components || {}),\n      }),\n    };\n    this.componentGenerator = new ComponentGenerator(designSystem);\n  }\n\n  private async initializePlugins(): Promise<void> {\n    if (!this.config.plugins) return;\n\n    for (const pluginConfig of this.config.plugins) {\n      try {\n        const plugin = await import(pluginConfig.name);\n        this.plugins.push({\n          ...plugin.default,\n          options: pluginConfig.options,\n        });\n      } catch (error) {\n        // Use a logger instead of console.error\n        if (this.config.logging?.enabled !== false) {\n          // eslint-disable-next-line no-console\n          logger.error(`Failed to load plugin ${pluginConfig.name}:`, error);\n        }\n      }\n    }\n  }\n\n  public async generate(): Promise<void> {\n    try {\n      // Initialize plugins\n      await this.initializePlugins();\n\n      // 1. Parse documentation sources\n      const parsedContent = await this.parseDocumentation();\n\n      // 2. Generate React components\n      const components = await this.generateComponents(parsedContent);\n\n      // 3. Apply design system\n      const styledComponents = await this.applyDesignSystem(components);\n\n      // 4. Generate tests\n      await this.generateTests(styledComponents);\n\n      // 5. Build and optimize\n      await this.build(styledComponents);\n\n      // Use a logger instead of console.log\n      if (this.config.logging?.enabled !== false) {\n        // eslint-disable-next-line no-console\n        logger.debug('Website generation completed successfully!');\n      }\n    } catch (error) {\n      // Use a logger instead of console.error\n      if (this.config.logging?.enabled !== false) {\n        // eslint-disable-next-line no-console\n        logger.error('Website generation failed:', error);\n      }\n      throw error;\n    }\n  }\n\n  public async parseDocumentation(): Promise<ParsedContent[]> {\n    const sourceDir = path.resolve(this.config.sourceDir);\n    const files = await this.getDocumentationFiles(sourceDir);\n    const parsedContent: ParsedContent[] = [];\n\n    for (const file of files) {\n      const content = await fs.readFile(file, 'utf-8');\n      const format = path.extname(file).slice(1);\n\n      // Apply plugins' beforeParse hooks\n      let processedContent = content;\n      for (const plugin of this.plugins) {\n        if (plugin.hooks?.beforeParse) {\n          processedContent = await plugin.hooks.beforeParse(processedContent);\n        }\n      }\n\n      // Parse content\n      const parser = this.parserFactory.prototype.getParser(format);\n      let parsed = await parser.parse(processedContent);\n\n      // Apply plugins' afterParse hooks\n      for (const plugin of this.plugins) {\n        if (plugin.hooks?.afterParse) {\n          parsed = await plugin.hooks.afterParse(parsed);\n        }\n      }\n\n      parsedContent.push(parsed);\n    }\n\n    return parsedContent;\n  }\n\n  public async generateComponents(parsedContent: ParsedContent[]): Promise<ComponentTemplate[]> {\n    const components: ComponentTemplate[] = [];\n\n    for (const content of parsedContent) {\n      // Apply plugins' beforeGenerate hooks\n      const currentComponent = await this.componentGenerator.generateComponent(content);\n\n      // Convert string to ComponentTemplate if needed\n      let currentComponents: ComponentTemplate | ComponentTemplate[] = {\n        name: `component-${components.length}`,\n        path: `/${content.type || 'component'}`,\n        content: currentComponent,\n        generate: async (element, designSystem) => currentComponent,\n      };\n\n      for (const plugin of this.plugins) {\n        if (plugin.hooks?.beforeGenerate) {\n          // Ensure we always pass an array to the plugin hooks\n          const componentsArray = Array.isArray(currentComponents)\n            ? currentComponents\n            : [currentComponents];\n          const result = await plugin.hooks.beforeGenerate(componentsArray);\n          currentComponents = result;\n        }\n      }\n\n      if (Array.isArray(currentComponents)) {\n        components.push(...currentComponents);\n      } else {\n        components.push(currentComponents);\n      }\n    }\n\n    return components;\n  }\n\n  public async applyDesignSystem(components: ComponentTemplate[]): Promise<ComponentTemplate[]> {\n    return Promise.all(\n      components.map(async component => {\n        // If the content is already processed, just return the component\n        if (typeof component.content !== 'string') {\n          return component;\n        }\n        // Convert string content to an object with type property for the component generator\n        const contentObj = { type: 'content', value: component.content };\n        const generatedContent = await this.componentGenerator.generateComponent(contentObj);\n\n        return {\n          ...component,\n          content: generatedContent,\n        };\n      })\n    );\n  }\n\n  public async generateTests(components: ComponentTemplate[]): Promise<void> {\n    if (!this.config.testing.components.unit && !this.config.testing.components.integration) {\n      return;\n    }\n\n    const testGenerator = await import('./TestGenerator.js').then(\n      m => new m.TestGenerator(this.config.testing)\n    );\n    // Convert ComponentTemplate[] to ComponentConfig[] for TestGenerator\n    const componentConfigs = components.map(comp => ({\n      name: comp.name,\n      path: comp.path,\n      content: comp.content,\n    }));\n    await testGenerator.generateTests(componentConfigs);\n  }\n\n  public async build(components: ComponentTemplate[]): Promise<void> {\n    const buildConfig: BuildConfig = {\n      target: 'production',\n      outDir: this.config.outputDir,\n      optimization: this.config.build.optimization,\n      assets: this.config.build.assets,\n    };\n\n    const builder = await import('./Builder.js').then(m => new m.Builder(buildConfig));\n    await builder.build(components);\n  }\n\n  public async getDocumentationFiles(sourceDir: string): Promise<string[]> {\n    const files: string[] = [];\n    const entries = await fs.readdir(sourceDir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(sourceDir, entry.name);\n\n      if (entry.isDirectory()) {\n        files.push(...(await this.getDocumentationFiles(fullPath)));\n      } else if (this.isDocumentationFile(entry.name)) {\n        files.push(fullPath);\n      }\n    }\n\n    return files;\n  }\n\n  public isDocumentationFile(filename: string): boolean {\n    const ext = path.extname(filename).slice(1);\n    return this.config.parser.extensions?.includes(ext) ?? false;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/Builder.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dirPath' is defined but never used.","line":58,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":58,"column":70,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":78},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filePath' is defined but never used.","line":63,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":73},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_content' is defined but never used.","line":63,"column":75,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":91},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'builder' is assigned a value but never used.","line":101,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":101,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Builder } from '../Builder.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('Builder', () => {\n  // Sample components for testing\n  const sampleComponents = [\n    {\n      name: 'Component1',\n      content: 'export const Component1 = () => <div>Component 1 Content</div>;',\n      metadata: {\n        originalPath: '/test/source/component1.md',\n      },\n    },\n    {\n      name: 'Component2',\n      content: 'export const Component2 = () => <div>Component 2 Content</div>;',\n      metadata: {\n        originalPath: '/test/source/component2.md',\n      },\n    },\n  ];\n\n  // Sample build options\n  const sampleBuildOptions = {\n    target: 'production',\n    outDir: '/test/output',\n    optimization: {\n      minify: true,\n      splitChunks: true,\n      treeshaking: true,\n    },\n    assets: {\n      images: {\n        optimize: true,\n        formats: ['webp'],\n      },\n      fonts: {\n        preload: true,\n        formats: ['woff2'],\n      },\n    },\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for output directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath === '/test/output';\n    });\n\n    // Mock fs.mkdirSync\n    (fs.mkdirSync as jest.Mock).mockImplementation((dirPath: string, _options) => {\n      return undefined;\n    });\n\n    // Mock fs.writeFileSync\n    (fs.writeFileSync as jest.Mock).mockImplementation((filePath: string, _content: string) => {\n      return undefined;\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock path.dirname to return the directory\n    (path.dirname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('/');\n      parts.pop();\n      return parts.join('/');\n    });\n\n    // Mock path.basename to return the filename\n    (path.basename as jest.Mock).mockImplementation((filePath: string, ext?: string) => {\n      const parts = filePath.split('/');\n      let filename = parts[parts.length - 1];\n      if (ext && filename.endsWith(ext)) {\n        filename = filename.slice(0, -ext.length);\n      }\n      return filename;\n    });\n  });\n\n  test('should initialize with valid options', () => {\n    const builder = new Builder(sampleBuildOptions);\n    expect(builder).toBeDefined();\n  });\n\n  test('should create output directory if it does not exist', () => {\n    // Mock fs.existsSync to return false for output directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath !== '/test/output';\n    });\n\n    const builder = new Builder(sampleBuildOptions);\n\n    expect(fs.mkdirSync).toHaveBeenCalledWith('/test/output', { recursive: true });\n  });\n\n  test('should build components', async () => {\n    const builder = new Builder(sampleBuildOptions);\n\n    await builder.build(sampleComponents);\n\n    // Should write component files\n    expect(fs.writeFileSync).toHaveBeenCalledTimes(sampleComponents.length);\n\n    // Check first component file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/Component1.js',\n      expect.stringContaining('Component 1 Content'),\n      'utf-8'\n    );\n\n    // Check second component file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/Component2.js',\n      expect.stringContaining('Component 2 Content'),\n      'utf-8'\n    );\n  });\n\n  test('should apply minification when enabled', async () => {\n    const builder = new Builder({\n      ...sampleBuildOptions,\n      optimization: {\n        ...sampleBuildOptions.optimization,\n        minify: true,\n      },\n    });\n\n    // Mock the minify method\n    builder.minify = jest.fn().mockImplementation((content: string) => {\n      return `/* minified */ ${content}`;\n    });\n\n    await builder.build(sampleComponents);\n\n    // Should call minify for each component\n    expect(builder.minify).toHaveBeenCalledTimes(sampleComponents.length);\n\n    // Check that minified content is written\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/Component1.js',\n      expect.stringContaining('/* minified */'),\n      'utf-8'\n    );\n  });\n\n  test('should not apply minification when disabled', async () => {\n    const builder = new Builder({\n      ...sampleBuildOptions,\n      optimization: {\n        ...sampleBuildOptions.optimization,\n        minify: false,\n      },\n    });\n\n    // Mock the minify method\n    builder.minify = jest.fn().mockImplementation((content: string) => {\n      return `/* minified */ ${content}`;\n    });\n\n    await builder.build(sampleComponents);\n\n    // Should not call minify\n    expect(builder.minify).not.toHaveBeenCalled();\n\n    // Check that original content is written\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/Component1.js',\n      expect.not.stringContaining('/* minified */'),\n      'utf-8'\n    );\n  });\n\n  test('should handle empty component list', async () => {\n    const builder = new Builder(sampleBuildOptions);\n\n    await builder.build([]);\n\n    // Should not write any files\n    expect(fs.writeFileSync).not.toHaveBeenCalled();\n  });\n\n  test('should handle errors during build', async () => {\n    const builder = new Builder(sampleBuildOptions);\n\n    // Mock fs.writeFileSync to throw an error\n    (fs.writeFileSync as jest.Mock).mockImplementation(() => {\n      throw new Error('Write error');\n    });\n\n    await expect(builder.build(sampleComponents)).rejects.toThrow('Write error');\n  });\n\n  test('should optimize assets when enabled', async () => {\n    const builder = new Builder(sampleBuildOptions);\n\n    // Mock the optimizeAssets method\n    builder.optimizeAssets = jest.fn().mockResolvedValue(undefined);\n\n    await builder.build(sampleComponents);\n\n    // Should call optimizeAssets\n    expect(builder.optimizeAssets).toHaveBeenCalled();\n  });\n\n  test('should not optimize assets when disabled', async () => {\n    const builder = new Builder({\n      ...sampleBuildOptions,\n      assets: undefined,\n    });\n\n    // Mock the optimizeAssets method\n    builder.optimizeAssets = jest.fn().mockResolvedValue(undefined);\n\n    await builder.build(sampleComponents);\n\n    // Should not call optimizeAssets\n    expect(builder.optimizeAssets).not.toHaveBeenCalled();\n  });\n\n  test('should generate index file', async () => {\n    const builder = new Builder(sampleBuildOptions);\n\n    await builder.build(sampleComponents);\n\n    // Should write index file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/index.js',\n      expect.stringContaining('export'),\n      'utf-8'\n    );\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/DocsifyWebsiteGenerator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ParsedContent' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dirPath' is defined but never used.","line":136,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":136,"endColumn":66},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":136,"column":68,"nodeType":"Identifier","messageId":"unusedVar","endLine":136,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filePath' is defined but never used.","line":159,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":159,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_content' is defined but never used.","line":159,"column":71,"nodeType":"Identifier","messageId":"unusedVar","endLine":159,"endColumn":87},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'src' is defined but never used.","line":164,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":164,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_dest' is defined but never used.","line":164,"column":65,"nodeType":"Identifier","messageId":"unusedVar","endLine":164,"endColumn":78}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DocsifyWebsiteGenerator } from '../DocsifyWebsiteGenerator.js';\nimport { WebsiteGeneratorConfig } from '../../config/generator.config.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { ParsedContent } from '../../types/parser.js';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\njest.mock('../WebsiteGenerator');\njest.mock('../utils/cache');\n\n// Create a minimal test configuration\nconst createTestConfig = (): WebsiteGeneratorConfig => ({\n  projectName: 'test-docsify-project',\n  sourceDir: '/test/source',\n  outputDir: '/test/output',\n\n  parser: {\n    extensions: ['md'],\n    ignorePatterns: ['node_modules'],\n    plugins: [],\n  },\n\n  generator: {\n    templates: {\n      page: '/test/templates/page.tsx',\n      section: '/test/templates/section.tsx',\n    },\n    componentNaming: {\n      style: 'PascalCase',\n    },\n  },\n\n  designSystem: {\n    type: 'custom',\n    name: 'vue',\n    importPath: '/test/themes',\n    components: {\n      Button: {\n        import: '/test/themes/Button',\n      },\n    },\n    styles: {\n      global: '/test/themes/global.css',\n    },\n  },\n\n  testing: {\n    framework: 'jest',\n    coverage: {\n      enabled: true,\n      threshold: 80,\n    },\n    components: {\n      unit: true,\n      integration: true,\n    },\n  },\n\n  build: {\n    optimization: {\n      minify: true,\n      splitChunks: true,\n      treeshaking: true,\n    },\n    assets: {\n      images: {\n        optimize: true,\n        formats: ['webp'],\n      },\n      fonts: {\n        preload: true,\n        formats: ['woff2'],\n      },\n    },\n  },\n\n  performance: {\n    lazyLoading: true,\n    prefetching: true,\n    caching: {\n      enabled: true,\n      strategy: 'memory',\n    },\n  },\n\n  accessibility: {\n    wcag: {\n      level: 'AA',\n      automated: true,\n    },\n    aria: true,\n    keyboard: true,\n  },\n});\n\ndescribe('DocsifyWebsiteGenerator', () => {\n  // Mock file system data\n  const mockFiles = {\n    '/test/source/README.md': '# Home Page\\n\\nWelcome to the documentation',\n    '/test/source/_sidebar.md': '* [Home](/)\\n* [Guide](guide.md)',\n    '/test/source/guide.md': '# Guide\\n\\nThis is a guide',\n    '/test/source/_navbar.md': '* [Home](/)\\n* [External](https://example.com)',\n    '/test/source/.nojekyll': '',\n    '/test/source/index.html': '<!DOCTYPE html><html><head></head><body></body></html>',\n  };\n\n  // Reset mocks before each test\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for directories and mock files\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath in mockFiles) return true;\n      if (filePath === '/test/source' || filePath === '/test/output') return true;\n      return false;\n    });\n\n    // Mock path.resolve to return the input path\n    (path.resolve as jest.Mock).mockImplementation((filePath: string) => filePath);\n\n    // Mock path.extname to return the correct extension\n    (path.extname as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.md')) return '.md';\n      if (filePath.endsWith('.html')) return '.html';\n      return '';\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) =>\n      paths.join('/').replace(/\\/+/g, '/')\n    );\n\n    // Mock fs.readdir to return mock directory contents\n    (fs.readdir as jest.Mock).mockImplementation((dirPath: string, _options) => {\n      if (_dirPath === '/test/source') {\n        return Promise.resolve([\n          { name: 'README.md', isDirectory: () => false },\n          { name: '_sidebar.md', isDirectory: () => false },\n          { name: 'guide.md', isDirectory: () => false },\n          { name: '_navbar.md', isDirectory: () => false },\n          { name: '.nojekyll', isDirectory: () => false },\n          { name: 'index.html', isDirectory: () => false },\n        ]);\n      }\n      return Promise.resolve([]);\n    });\n\n    // Mock fs.readFile to return mock file contents\n    (fs.readFile as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath in mockFiles) {\n        return Promise.resolve(mockFiles[filePath]);\n      }\n      return Promise.reject(new Error(`File not found: ${filePath}`));\n    });\n\n    // Mock fs.writeFile\n    (fs.writeFile as jest.Mock).mockImplementation((filePath: string, _content: string) => {\n      return Promise.resolve();\n    });\n\n    // Mock fs.copyFile\n    (fs.copyFile as jest.Mock).mockImplementation((src: string, _dest: string) => {\n      return Promise.resolve();\n    });\n  });\n\n  test('should initialize with valid configuration', () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    expect(generator).toBeDefined();\n  });\n\n  test('should set Docsify-specific configuration', () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Access the protected docsifyConfig property using type assertion\n    const docsifyConfig = (generator as unknown).docsifyConfig;\n\n    expect(docsifyConfig).toBeDefined();\n    expect(docsifyConfig.name).toBe(config.projectName);\n    expect(docsifyConfig.repo).toBe('');\n    expect(docsifyConfig.coverpage).toBe(false);\n    expect(docsifyConfig.loadSidebar).toBe(true);\n    expect(docsifyConfig.loadNavbar).toBe(true);\n    expect(docsifyConfig.auto2top).toBe(true);\n    expect(docsifyConfig.maxLevel).toBe(4);\n    expect(docsifyConfig.subMaxLevel).toBe(2);\n    expect(docsifyConfig.themeColor).toBe('#3F51B5');\n  });\n\n  test('should customize Docsify configuration with options', () => {\n    const config = createTestConfig();\n    const docsifyOptions = {\n      name: 'Custom Name',\n      repo: 'user/repo',\n      coverpage: true,\n      themeColor: '#FF5722',\n      maxLevel: 3,\n      subMaxLevel: 3,\n    };\n\n    const generator = new DocsifyWebsiteGenerator(config, docsifyOptions);\n\n    // Access the protected docsifyConfig property using type assertion\n    const docsifyConfig = (generator as unknown).docsifyConfig;\n\n    expect(docsifyConfig.name).toBe('Custom Name');\n    expect(docsifyConfig.repo).toBe('user/repo');\n    expect(docsifyConfig.coverpage).toBe(true);\n    expect(docsifyConfig.themeColor).toBe('#FF5722');\n    expect(docsifyConfig.maxLevel).toBe(3);\n    expect(docsifyConfig.subMaxLevel).toBe(3);\n  });\n\n  test('should generate Docsify index.html', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    // Mock the generateDocsifyFiles method to call the real implementation\n    const originalGenerateDocsifyFiles = (generator as unknown).generateDocsifyFiles;\n    (generator as unknown).generateDocsifyFiles = jest.fn().mockImplementation(async () => {\n      return await originalGenerateDocsifyFiles.call(generator);\n    });\n\n    await generator.generate();\n\n    // Verify that generateDocsifyFiles was called\n    expect((generator as unknown).generateDocsifyFiles).toHaveBeenCalled();\n\n    // Verify that fs.writeFile was called for index.html\n    expect(fs.writeFile).toHaveBeenCalledWith(\n      '/test/output/index.html',\n      expect.stringContaining('<!DOCTYPE html>'),\n      'utf-8'\n    );\n\n    // Verify that the index.html contains Docsify configuration\n    const indexHtmlCall = (fs.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/output/index.html'\n    );\n\n    const indexHtmlContent = indexHtmlCall ? indexHtmlCall[1] : '';\n    expect(indexHtmlContent).toContain('window.$docsify');\n    expect(indexHtmlContent).toContain(config.projectName);\n  });\n\n  test('should copy Docsify-specific files', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that fs.copyFile was called for .nojekyll\n    expect(fs.copyFile).toHaveBeenCalledWith('/test/source/.nojekyll', '/test/output/.nojekyll');\n\n    // Verify that fs.copyFile was called for _sidebar.md\n    expect(fs.copyFile).toHaveBeenCalledWith(\n      '/test/source/_sidebar.md',\n      '/test/output/_sidebar.md'\n    );\n\n    // Verify that fs.copyFile was called for _navbar.md\n    expect(fs.copyFile).toHaveBeenCalledWith('/test/source/_navbar.md', '/test/output/_navbar.md');\n  });\n\n  test('should create .nojekyll file if it does not exist', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock fs.existsSync to return false for .nojekyll\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath === '/test/source/.nojekyll') return false;\n      if (filePath in mockFiles) return true;\n      if (filePath === '/test/source' || filePath === '/test/output') return true;\n      return false;\n    });\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that fs.writeFile was called for .nojekyll\n    expect(fs.writeFile).toHaveBeenCalledWith('/test/output/.nojekyll', '', 'utf-8');\n  });\n\n  test('should create _sidebar.md if it does not exist', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock fs.existsSync to return false for _sidebar.md\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath === '/test/source/_sidebar.md') return false;\n      if (filePath in mockFiles) return true;\n      if (filePath === '/test/source' || filePath === '/test/output') return true;\n      return false;\n    });\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([\n      {\n        title: 'Home Page',\n        content: 'Welcome to the documentation',\n        sections: [],\n        metadata: { originalPath: '/test/source/README.md' },\n      },\n      {\n        title: 'Guide',\n        content: 'This is a guide',\n        sections: [],\n        metadata: { originalPath: '/test/source/guide.md' },\n      },\n    ]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that fs.writeFile was called for _sidebar.md\n    expect(fs.writeFile).toHaveBeenCalledWith(\n      '/test/output/_sidebar.md',\n      expect.stringContaining('* [Home Page](/)'),\n      'utf-8'\n    );\n  });\n\n  test('should apply Docsify theme', async () => {\n    const config = createTestConfig();\n    config.designSystem.name = 'dark';\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that the index.html contains the dark theme\n    const indexHtmlCall = (fs.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/output/index.html'\n    );\n\n    const indexHtmlContent = indexHtmlCall ? indexHtmlCall[1] : '';\n    expect(indexHtmlContent).toContain('theme-dark.css');\n  });\n\n  test('should add Docsify plugins', async () => {\n    const config = createTestConfig();\n    config.plugins = [{ name: 'search' }, { name: 'copy-code' }, { name: 'zoom-image' }];\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    // Verify that the index.html contains the plugins\n    const indexHtmlCall = (fs.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/output/index.html'\n    );\n\n    const indexHtmlContent = indexHtmlCall ? indexHtmlCall[1] : '';\n    expect(indexHtmlContent).toContain('docsify-search.min.js');\n    expect(indexHtmlContent).toContain('docsify-copy-code.min.js');\n    expect(indexHtmlContent).toContain('zoom-image.min.js');\n  });\n\n  test('should handle errors during Docsify file generation', async () => {\n    const config = createTestConfig();\n    const generator = new DocsifyWebsiteGenerator(config);\n\n    // Mock fs.writeFile to throw an error\n    (fs.writeFile as jest.Mock).mockRejectedValue(new Error('Write error'));\n\n    // Mock the parent class methods\n    (generator as unknown).parseDocumentation = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateComponents = jest.fn().mockResolvedValue([]);\n    (generator as unknown).generateTests = jest.fn().mockResolvedValue([]);\n    (generator as unknown).buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await expect(generator.generate()).rejects.toThrow('Write error');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/TestGenerator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_dirPath' is defined but never used.","line":53,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":53,"column":71,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":79},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_filePath' is defined but never used.","line":58,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":74},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_content' is defined but never used.","line":58,"column":76,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":92},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'testGenerator' is assigned a value but never used.","line":96,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TestGenerator } from '../TestGenerator.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('TestGenerator', () => {\n  // Sample components for testing\n  const sampleComponents = [\n    {\n      name: 'Component1',\n      content: 'export const Component1 = () => <div>Component 1 Content</div>;',\n      path: '/test/source/components/Component1.tsx',\n      metadata: {\n        originalPath: '/test/source/component1.md',\n      },\n    },\n    {\n      name: 'Component2',\n      content: 'export const Component2 = () => <div>Component 2 Content</div>;',\n      path: '/test/source/components/Component2.tsx',\n      metadata: {\n        originalPath: '/test/source/component2.md',\n      },\n    },\n  ];\n\n  // Sample test options\n  const sampleTestOptions = {\n    framework: 'jest' as 'jest' | 'vitest', // Type assertion to fix the error\n    coverage: {\n      enabled: true,\n      threshold: 80,\n    },\n    components: {\n      unit: true,\n      integration: true,\n    },\n    outputDir: '/test/output/__tests__',\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for output directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath === '/test/output/__tests__';\n    });\n\n    // Mock fs.mkdirSync\n    (fs.mkdirSync as jest.Mock).mockImplementation((_dirPath: string, _options) => {\n      return undefined;\n    });\n\n    // Mock fs.writeFileSync\n    (fs.writeFileSync as jest.Mock).mockImplementation((_filePath: string, _content: string) => {\n      return undefined;\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock path.dirname to return the directory\n    (path.dirname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('/');\n      parts.pop();\n      return parts.join('/');\n    });\n\n    // Mock path.basename to return the filename\n    (path.basename as jest.Mock).mockImplementation((filePath: string, ext?: string) => {\n      const parts = filePath.split('/');\n      let filename = parts[parts.length - 1];\n      if (ext && filename.endsWith(ext)) {\n        filename = filename.slice(0, -ext.length);\n      }\n      return filename;\n    });\n  });\n\n  test('should initialize with valid options', () => {\n    const testGenerator = new TestGenerator(sampleTestOptions);\n    expect(testGenerator).toBeDefined();\n  });\n\n  test('should create output directory if it does not exist', () => {\n    // Mock fs.existsSync to return false for output directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath !== '/test/output/__tests__';\n    });\n\n    const testGenerator = new TestGenerator(sampleTestOptions);\n\n    expect(fs.mkdirSync).toHaveBeenCalledWith('/test/output/__tests__', { recursive: true });\n  });\n\n  test('should generate unit tests for components', async () => {\n    const testGenerator = new TestGenerator(sampleTestOptions);\n\n    await testGenerator.generateTests(sampleComponents);\n\n    // Should write test files\n    expect(fs.writeFileSync).toHaveBeenCalledTimes(sampleComponents.length);\n\n    // Check first component test file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/Component1.test.js',\n      expect.stringContaining('test('),\n      'utf-8'\n    );\n\n    // Check second component test file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/Component2.test.js',\n      expect.stringContaining('test('),\n      'utf-8'\n    );\n  });\n\n  test('should not generate unit tests when disabled', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      components: {\n        ...sampleTestOptions.components,\n        unit: false,\n      },\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Should not write any unit test files\n    expect(fs.writeFileSync).not.toHaveBeenCalled();\n  });\n\n  test('should generate integration tests when enabled', async () => {\n    const generator = new TestGenerator(sampleTestOptions);\n\n    await generator.generateTests(sampleComponents);\n\n    // Should write integration test file\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/integration.test.js',\n      expect.stringContaining('integration'),\n      'utf-8'\n    );\n  });\n\n  test('should not generate integration tests when disabled', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      components: {\n        ...sampleTestOptions.components,\n        integration: false,\n      },\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Should not write integration test file\n    expect(fs.writeFileSync).not.toHaveBeenCalledWith(\n      '/test/output/__tests__/integration.test.js',\n      expect.any(String),\n      'utf-8'\n    );\n  });\n\n  test('should handle empty component list', async () => {\n    const generator = new TestGenerator(sampleTestOptions);\n\n    await generator.generateTests([]);\n\n    // Should not write any files\n    expect(fs.writeFileSync).not.toHaveBeenCalled();\n  });\n\n  test('should handle errors during test generation', async () => {\n    const generator = new TestGenerator(sampleTestOptions);\n\n    // Mock fs.writeFileSync to throw an error\n    (fs.writeFileSync as jest.Mock).mockImplementation(() => {\n      throw new Error('Write error');\n    });\n\n    await expect(generator.generateTests(sampleComponents)).rejects.toThrow('Write error');\n  });\n\n  test('should generate Jest tests when framework is Jest', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      framework: 'jest',\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Check that Jest syntax is used\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/Component1.test.js',\n      expect.stringContaining('describe('),\n      'utf-8'\n    );\n  });\n\n  test('should generate Vitest tests when framework is Vitest', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      framework: 'vitest',\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Check that Vitest syntax is used\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '/test/output/__tests__/Component1.test.js',\n      expect.stringContaining('import { describe, it, expect }'),\n      'utf-8'\n    );\n  });\n\n  test('should include coverage threshold when enabled', async () => {\n    const generator = new TestGenerator({\n      ...sampleTestOptions,\n      coverage: {\n        enabled: true,\n        threshold: 90,\n      },\n    });\n\n    await generator.generateTests(sampleComponents);\n\n    // Check that coverage threshold is included\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      expect.any(String),\n      expect.stringContaining('90'),\n      'utf-8'\n    );\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/WebsiteGenerator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Plugin' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ComponentTemplate' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dirPath' is defined but never used.","line":179,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":179,"endColumn":66},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":179,"column":68,"nodeType":"Identifier","messageId":"unusedVar","endLine":179,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'generator' is assigned a value but never used.","line":243,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":243,"endColumn":20},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":478,"column":12,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":478,"endColumn":39},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":495,"column":21,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":495,"endColumn":42}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WebsiteGenerator } from '../WebsiteGenerator.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { WebsiteGeneratorConfig } from '../../config/generator.config.js';\nimport { ParsedContent } from '../../types/parser.js';\nimport { Plugin } from '../../types/plugin.js';\nimport { ComponentTemplate } from '../../types/component.js';\nimport { ContentCache } from '../utils/cache.js';\nimport { SiteGeneratorError } from '../utils/errors.js';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\njest.mock('../utils/cache');\njest.mock('../TestGenerator', () => ({\n  TestGenerator: jest.fn().mockImplementation(() => ({\n    generateTests: jest.fn().mockResolvedValue(undefined),\n  })),\n}));\njest.mock('../Builder', () => ({\n  Builder: jest.fn().mockImplementation(() => ({\n    build: jest.fn().mockResolvedValue(undefined),\n  })),\n}));\n\n// Mock DocumentationParserFactory\njest.mock('../parser-implementation', () => ({\n  DocumentationParserFactory: {\n    prototype: {\n      register: jest.fn(),\n      getParser: jest.fn().mockImplementation(() => ({\n        parse: jest.fn().mockImplementation(content => ({\n          title: 'Test Document',\n          content: content,\n          sections: [],\n          metadata: { originalPath: '/test/source/test.md' },\n        })),\n      })),\n    },\n  },\n}));\n\n// Mock ComponentGenerator\njest.mock('../component-generator', () => ({\n  ComponentGenerator: jest.fn().mockImplementation(() => ({\n    generateComponent: jest.fn().mockImplementation(content => ({\n      name: 'TestComponent',\n      content: content,\n    })),\n    generatePage: jest.fn().mockImplementation(content => ({\n      name: 'TestPage',\n      content: content,\n    })),\n  })),\n}));\n\n// Create a minimal test configuration\nconst createTestConfig = (): WebsiteGeneratorConfig => ({\n  projectName: 'test-project',\n  sourceDir: '/test/source',\n  outputDir: '/test/output',\n\n  parser: {\n    extensions: ['md'],\n    ignorePatterns: ['node_modules'],\n    plugins: [],\n  },\n\n  generator: {\n    templates: {\n      page: '/test/templates/page.tsx',\n      section: '/test/templates/section.tsx',\n    },\n    componentNaming: {\n      style: 'PascalCase',\n    },\n  },\n\n  designSystem: {\n    type: 'custom',\n    name: 'test-theme',\n    importPath: '/test/themes',\n    components: {\n      Button: {\n        import: '/test/themes/Button',\n      },\n    },\n    styles: {\n      global: '/test/themes/global.css',\n    },\n  },\n\n  testing: {\n    framework: 'jest',\n    coverage: {\n      enabled: true,\n      threshold: 80,\n    },\n    components: {\n      unit: true,\n      integration: true,\n    },\n  },\n\n  build: {\n    optimization: {\n      minify: true,\n      splitChunks: true,\n      treeshaking: true,\n    },\n    assets: {\n      images: {\n        optimize: true,\n        formats: ['webp'],\n      },\n      fonts: {\n        preload: true,\n        formats: ['woff2'],\n      },\n    },\n  },\n\n  performance: {\n    lazyLoading: true,\n    prefetching: true,\n    caching: {\n      enabled: true,\n      strategy: 'memory',\n    },\n  },\n\n  accessibility: {\n    wcag: {\n      level: 'AA',\n      automated: true,\n    },\n    aria: true,\n    keyboard: true,\n  },\n});\n\ndescribe('WebsiteGenerator', () => {\n  // Mock file system data\n  const mockFiles = {\n    '/test/source/doc1.md': '# Document 1\\n\\nContent of document 1',\n    '/test/source/doc2.md': '# Document 2\\n\\nContent of document 2',\n    '/test/source/subfolder/doc3.md': '# Document 3\\n\\nContent of document 3',\n    '/test/source/ignored/doc4.md': '# Document 4\\n\\nContent of document 4',\n    '/test/source/file.txt': 'This is not a markdown file',\n  };\n\n  // Reset mocks before each test\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for directories and mock files\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath in mockFiles) return true;\n      if (filePath === '/test/source' || filePath === '/test/output') return true;\n      return false;\n    });\n\n    // Mock path.resolve to return the input path\n    (path.resolve as jest.Mock).mockImplementation((filePath: string) => filePath);\n\n    // Mock path.extname to return the correct extension\n    (path.extname as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.md')) return '.md';\n      if (filePath.endsWith('.txt')) return '.txt';\n      return '';\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) =>\n      paths.join('/').replace(/\\/+/g, '/')\n    );\n\n    // Mock fs.readdir to return mock directory contents\n    (fs.readdir as jest.Mock).mockImplementation((dirPath: string, _options) => {\n      if (_dirPath === '/test/source') {\n        return Promise.resolve([\n          { name: 'doc1.md', isDirectory: () => false },\n          { name: 'doc2.md', isDirectory: () => false },\n          { name: 'subfolder', isDirectory: () => true },\n          { name: 'ignored', isDirectory: () => true },\n          { name: 'file.txt', isDirectory: () => false },\n        ]);\n      } else if (_dirPath === '/test/source/subfolder') {\n        return Promise.resolve([{ name: 'doc3.md', isDirectory: () => false }]);\n      } else if (_dirPath === '/test/source/ignored') {\n        return Promise.resolve([{ name: 'doc4.md', isDirectory: () => false }]);\n      }\n      return Promise.resolve([]);\n    });\n\n    // Mock fs.readFile to return mock file contents\n    (fs.readFile as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath in mockFiles) {\n        return Promise.resolve(mockFiles[filePath]);\n      }\n      return Promise.reject(new Error(`File not found: ${filePath}`));\n    });\n\n    // Mock ContentCache constructor\n    (ContentCache as jest.Mock).mockImplementation(() => ({\n      get: jest.fn().mockReturnValue(null),\n      set: jest.fn(),\n      has: jest.fn().mockReturnValue(false),\n      clear: jest.fn(),\n      getStats: jest.fn().mockReturnValue({ size: 0 }),\n    }));\n  });\n\n  test('should initialize with valid configuration', () => {\n    const config = createTestConfig();\n    const generator = new WebsiteGenerator(config);\n\n    expect(generator).toBeDefined();\n    expect(generator.getConfig()).toEqual(config);\n  });\n\n  test('should validate source directory exists', () => {\n    const config = createTestConfig();\n\n    // Mock fs.existsSync to return false for source directory\n    (fs.existsSync as jest.Mock).mockImplementation((path: string) => {\n      return path !== config.sourceDir;\n    });\n\n    expect(() => {\n      new WebsiteGenerator(config);\n    }).toThrow(/Source directory does not exist/);\n  });\n\n  test('should create output directory if it does not exist', () => {\n    const config = createTestConfig();\n\n    // Mock fs.existsSync to return false for output directory\n    (fs.existsSync as jest.Mock).mockImplementation((path: string) => {\n      return path !== config.outputDir;\n    });\n\n    const generator = new WebsiteGenerator(config);\n\n    expect(fs.mkdirSync).toHaveBeenCalledWith(config.outputDir, { recursive: true });\n  });\n\n  test('should register plugins from configuration', () => {\n    const config = createTestConfig();\n    config.plugins = [{ name: 'test-plugin' }, { name: 'another-plugin', options: { foo: 'bar' } }];\n\n    const generator = new WebsiteGenerator(config);\n    const registeredPlugins = generator.getPlugins();\n\n    expect(registeredPlugins).toHaveLength(2);\n    expect(registeredPlugins[0].name).toBe('test-plugin');\n    expect(registeredPlugins[1].name).toBe('another-plugin');\n    expect(registeredPlugins[1].options).toEqual({ foo: 'bar' });\n  });\n\n  test('should generate website', async () => {\n    const config = createTestConfig();\n    const generator = new WebsiteGenerator(config);\n\n    // Mock the internal methods\n    generator.parseDocumentation = jest.fn().mockResolvedValue([]);\n    generator.generateComponents = jest.fn().mockResolvedValue([]);\n    generator.generateTests = jest.fn().mockResolvedValue([]);\n    generator.buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    expect(generator.parseDocumentation).toHaveBeenCalled();\n    expect(generator.generateComponents).toHaveBeenCalled();\n    expect(generator.generateTests).toHaveBeenCalled();\n    expect(generator.buildWebsite).toHaveBeenCalled();\n  });\n\n  test('should handle errors during generation', async () => {\n    const config = createTestConfig();\n    const generator = new WebsiteGenerator(config);\n\n    // Mock the internal methods to throw an error\n    generator.parseDocumentation = jest.fn().mockRejectedValue(new Error('Parse error'));\n\n    await expect(generator.generate()).rejects.toThrow('Parse error');\n  });\n\n  test('should apply caching when enabled', async () => {\n    const config = createTestConfig();\n    config.performance.caching.enabled = true;\n\n    const generator = new WebsiteGenerator(config);\n\n    // Mock the cache methods\n    generator.cache = {\n      get: jest.fn().mockReturnValue(null),\n      set: jest.fn(),\n      has: jest.fn().mockReturnValue(false),\n      clear: jest.fn(),\n      getStats: jest.fn().mockReturnValue({ size: 0 }),\n    } as unknown;\n\n    // Mock the internal methods\n    generator.parseDocumentation = jest.fn().mockResolvedValue([]);\n    generator.generateComponents = jest.fn().mockResolvedValue([]);\n    generator.generateTests = jest.fn().mockResolvedValue([]);\n    generator.buildWebsite = jest.fn().mockResolvedValue(true);\n\n    await generator.generate();\n\n    expect(generator.cache.get).toHaveBeenCalled();\n    expect(generator.cache.set).toHaveBeenCalled();\n  });\n\n  test('should parse documentation files correctly', async () => {\n    const config = createTestConfig();\n    const generator = new WebsiteGenerator(config);\n\n    // Call the actual parseDocumentation method\n    const parsedContent = await generator.parseDocumentation();\n\n    // Verify the results\n    expect(parsedContent).toHaveLength(3); // 3 markdown files (excluding the ignored one)\n    expect(parsedContent[0].title).toBe('Test Document');\n    expect(parsedContent[1].title).toBe('Test Document');\n    expect(parsedContent[2].title).toBe('Test Document');\n  });\n\n  test('should filter files based on extensions', async () => {\n    const config = createTestConfig();\n    config.parser.extensions = ['md']; // Only parse markdown files\n    const generator = new WebsiteGenerator(config);\n\n    // Call the actual method\n    const files = await generator.getDocumentationFiles('/test/source');\n\n    // Verify the results\n    expect(files).toHaveLength(3); // 3 markdown files (excluding the ignored one)\n    expect(files).toContain('/test/source/doc1.md');\n    expect(files).toContain('/test/source/doc2.md');\n    expect(files).toContain('/test/source/subfolder/doc3.md');\n    expect(files).not.toContain('/test/source/file.txt'); // Not a markdown file\n    expect(files).not.toContain('/test/source/ignored/doc4.md'); // In ignored directory\n  });\n\n  test('should respect ignore patterns', async () => {\n    const config = createTestConfig();\n    config.parser.ignorePatterns = ['ignored']; // Ignore the 'ignored' directory\n    const generator = new WebsiteGenerator(config);\n\n    // Call the actual method\n    const files = await generator.getDocumentationFiles('/test/source');\n\n    // Verify the results\n    expect(files).not.toContain('/test/source/ignored/doc4.md');\n  });\n\n  test('should apply plugins to parsed content', async () => {\n    const config = createTestConfig();\n\n    // Add mock plugins\n    config.plugins = [\n      {\n        name: 'test-plugin',\n        hooks: {\n          beforeParse: jest.fn().mockImplementation(content => `Modified ${content}`),\n          afterParse: jest.fn().mockImplementation(parsed => ({\n            ...parsed,\n            title: `Enhanced ${parsed.title}`,\n          })),\n        },\n      },\n    ];\n\n    const generator = new WebsiteGenerator(config);\n\n    // Mock plugin initialization\n    await generator.initializePlugins();\n\n    // Call the actual parseDocumentation method\n    const parsedContent = await generator.parseDocumentation();\n\n    // Verify the results\n    expect(parsedContent[0].title).toBe('Enhanced Test Document');\n  });\n\n  test('should handle errors during parsing', async () => {\n    const config = createTestConfig();\n    const generator = new WebsiteGenerator(config);\n\n    // Mock parser to throw an error\n    const mockParser = {\n      parse: jest.fn().mockRejectedValue(new Error('Parse error')),\n    };\n\n    const mockParserFactory = jest.fn().mockImplementation(() => ({\n      getParser: jest.fn().mockReturnValue(mockParser),\n    }));\n\n    generator.parserFactory = mockParserFactory as unknown;\n\n    // Call the method and expect it to throw\n    await expect(generator.parseDocumentation()).rejects.toThrow('Parse error');\n  });\n\n  test('should generate components from parsed content', async () => {\n    const config = createTestConfig();\n    const generator = new WebsiteGenerator(config);\n\n    // Create mock parsed content\n    const mockParsedContent: ParsedContent[] = [\n      {\n        title: 'Test Document 1',\n        content: 'Content 1',\n        sections: [],\n        metadata: { originalPath: '/test/source/doc1.md' },\n        description: '',\n        assets: [],\n        references: [],\n      },\n      {\n        title: 'Test Document 2',\n        content: 'Content 2',\n        sections: [],\n        metadata: { originalPath: '/test/source/doc2.md' },\n        description: '',\n        assets: [],\n        references: [],\n      },\n    ];\n\n    // Call the method\n    const components = await generator.generateComponents(mockParsedContent);\n\n    // Verify the results\n    expect(components).toHaveLength(2);\n    expect(components[0].name).toBe('TestComponent');\n    expect(components[1].name).toBe('TestComponent');\n  });\n\n  test('should apply design system to components', async () => {\n    const config = createTestConfig();\n    const generator = new WebsiteGenerator(config);\n\n    // Create mock components\n    const mockComponents = [\n      { name: 'Component1', content: 'Content 1' },\n      { name: 'Component2', content: 'Content 2' },\n    ];\n\n    // Call the method\n    const styledComponents = await generator.applyDesignSystem(mockComponents as unknown);\n\n    // Verify the results\n    expect(styledComponents).toHaveLength(2);\n    expect(styledComponents[0].content).toEqual({ name: 'TestComponent', content: 'Content 1' });\n    expect(styledComponents[1].content).toEqual({ name: 'TestComponent', content: 'Content 2' });\n  });\n\n  test('should skip test generation when disabled', async () => {\n    const config = createTestConfig();\n    config.testing.components.unit = false;\n    config.testing.components.integration = false;\n\n    const generator = new WebsiteGenerator(config);\n\n    // Create mock components\n    const mockComponents = [\n      { name: 'Component1', content: 'Content 1' },\n      { name: 'Component2', content: 'Content 2' },\n    ];\n\n    // Call the method\n    await generator.generateTests(mockComponents as unknown);\n\n    // Verify that TestGenerator was not imported\n    expect(require('../TestGenerator').TestGenerator).not.toHaveBeenCalled();\n  });\n\n  test('should build the website with the correct configuration', async () => {\n    const config = createTestConfig();\n    const generator = new WebsiteGenerator(config);\n\n    // Create mock components\n    const mockComponents = [\n      { name: 'Component1', content: 'Content 1' },\n      { name: 'Component2', content: 'Content 2' },\n    ];\n\n    // Call the method\n    await generator.build(mockComponents as unknown);\n\n    // Verify that Builder was called with the correct config\n    const Builder = require('../Builder').Builder;\n    expect(Builder).toHaveBeenCalledWith({\n      target: 'production',\n      outDir: config.outputDir,\n      optimization: config.build.optimization,\n      assets: config.build.assets,\n    });\n\n    // Verify that build was called with the components\n    const buildInstance = Builder.mock.results[0].value;\n    expect(buildInstance.build).toHaveBeenCalledWith(mockComponents);\n  });\n\n  test('should handle errors with SiteGeneratorError', async () => {\n    const config = createTestConfig();\n    const generator = new WebsiteGenerator(config);\n\n    // Mock fs.readdir to throw an error\n    (fs.readdir as unknown as jest.Mock).mockRejectedValue(new Error('File system error'));\n\n    // Call the method and expect it to throw a SiteGeneratorError\n    await expect(generator.getDocumentationFiles('/test/source')).rejects.toThrow(\n      SiteGeneratorError\n    );\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/components/ComponentGenerator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/navigation/NavigationGenerator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fs' is defined but never used.","line":3,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NavigationGenerator } from '../../navigation/NavigationGenerator.js';\nimport { ParsedContent } from '../../../types/parser.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('NavigationGenerator', () => {\n  // Sample parsed content\n  const sampleParsedContent: ParsedContent[] = [\n    {\n      title: 'Home',\n      content: 'Home page content',\n      sections: [\n        {\n          level: 1,\n          title: 'Home',\n          content: 'Home page content',\n        },\n      ],\n      metadata: {\n        originalPath: '/test/source/index.md',\n      },\n    },\n    {\n      title: 'Getting Started',\n      content: 'Getting started guide',\n      sections: [\n        {\n          level: 1,\n          title: 'Getting Started',\n          content: 'Getting started guide',\n        },\n        {\n          level: 2,\n          title: 'Installation',\n          content: 'Installation instructions',\n        },\n        {\n          level: 2,\n          title: 'Configuration',\n          content: 'Configuration instructions',\n        },\n      ],\n      metadata: {\n        originalPath: '/test/source/getting-started.md',\n      },\n    },\n    {\n      title: 'API Reference',\n      content: 'API documentation',\n      sections: [\n        {\n          level: 1,\n          title: 'API Reference',\n          content: 'API documentation',\n        },\n      ],\n      metadata: {\n        originalPath: '/test/source/api/index.md',\n      },\n    },\n    {\n      title: 'Users API',\n      content: 'Users API documentation',\n      sections: [\n        {\n          level: 1,\n          title: 'Users API',\n          content: 'Users API documentation',\n        },\n        {\n          level: 2,\n          title: 'Get Users',\n          content: 'Get users endpoint',\n        },\n        {\n          level: 2,\n          title: 'Create User',\n          content: 'Create user endpoint',\n        },\n      ],\n      metadata: {\n        originalPath: '/test/source/api/users.md',\n      },\n    },\n  ];\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock path.dirname to return the directory\n    (path.dirname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('/');\n      parts.pop();\n      return parts.join('/');\n    });\n\n    // Mock path.basename to return the filename\n    (path.basename as jest.Mock).mockImplementation((filePath: string, ext?: string) => {\n      const parts = filePath.split('/');\n      let filename = parts[parts.length - 1];\n      if (ext && filename.endsWith(ext)) {\n        filename = filename.slice(0, -ext.length);\n      }\n      return filename;\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock path.relative to return relative path\n    (path.relative as jest.Mock).mockImplementation((from: string, to: string) => {\n      // Simple implementation for test purposes\n      const paths: Record<string, string> = {\n        '/test/source/index.md': 'index.md',\n        '/test/source/getting-started.md': 'getting-started.md',\n        '/test/source/api/index.md': 'api/index.md',\n        '/test/source/api/users.md': 'api/users.md',\n      };\n\n      if (_from === '/test/source' && to in paths) {\n        return paths[to];\n      }\n\n      return to.replace(from + '/', '');\n    });\n  });\n\n  test('should initialize with default options', () => {\n    const generator = new NavigationGenerator('/test/source');\n    expect(generator).toBeDefined();\n  });\n\n  test('should initialize with custom options', () => {\n    const options = {\n      maxDepth: 3,\n      includeIndex: true,\n      sortByTitle: true,\n    };\n\n    const generator = new NavigationGenerator('/test/source', options);\n    expect(generator.options).toEqual(options);\n  });\n\n  test('should generate navigation from parsed content', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    expect(navigation).toBeDefined();\n    expect(navigation.items).toBeDefined();\n    expect(navigation.items.length).toBeGreaterThan(0);\n  });\n\n  test('should organize navigation by directory structure', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check top-level items\n    expect(navigation.items.length).toBe(3); // Home, Getting Started, API\n\n    // Check that API has children\n    const apiItem = navigation.items.find(item => item.title === 'API Reference');\n    expect(apiItem).toBeDefined();\n    expect(apiItem?.children).toBeDefined();\n    expect(apiItem?.children?.length).toBe(1); // Users API\n\n    // Check API children\n    const usersApiItem = apiItem?.children?.[0];\n    expect(usersApiItem?.title).toBe('Users API');\n  });\n\n  test('should handle index files correctly', () => {\n    const generator = new NavigationGenerator('/test/source', { includeIndex: true });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that index files are included\n    const homeItem = navigation.items.find(item => item.title === 'Home');\n    expect(homeItem).toBeDefined();\n\n    const apiItem = navigation.items.find(item => item.title === 'API Reference');\n    expect(apiItem).toBeDefined();\n  });\n\n  test('should exclude index files when configured', () => {\n    const generator = new NavigationGenerator('/test/source', { includeIndex: false });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that index files are excluded\n    const homeItem = navigation.items.find(item => item.title === 'Home');\n    expect(homeItem).toBeUndefined();\n\n    // API Reference should still be included because it has children\n    const apiItem = navigation.items.find(item => item.title === 'API Reference');\n    expect(apiItem).toBeDefined();\n  });\n\n  test('should limit navigation depth', () => {\n    const generator = new NavigationGenerator('/test/source', { maxDepth: 1 });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that only top-level items are included\n    expect(navigation.items.length).toBeGreaterThan(0);\n\n    // Check that no items have children\n    for (const item of navigation.items) {\n      expect(item.children).toBeUndefined();\n    }\n  });\n\n  test('should sort navigation items by title', () => {\n    const generator = new NavigationGenerator('/test/source', { sortByTitle: true });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that items are sorted alphabetically\n    const titles = navigation.items.map(item => item.title);\n    const sortedTitles = [...titles].sort();\n    expect(titles).toEqual(sortedTitles);\n  });\n\n  test('should sort navigation items by filename when not sorting by title', () => {\n    const generator = new NavigationGenerator('/test/source', { sortByTitle: false });\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check that items are in the original order\n    expect(navigation.items[0].title).toBe('Home');\n    expect(navigation.items[1].title).toBe('Getting Started');\n    expect(navigation.items[2].title).toBe('API Reference');\n  });\n\n  test('should generate navigation links correctly', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation(sampleParsedContent);\n\n    // Check links\n    const homeItem = navigation.items.find(item => item.title === 'Home');\n    expect(homeItem?.link).toBe('/');\n\n    const gettingStartedItem = navigation.items.find(item => item.title === 'Getting Started');\n    expect(gettingStartedItem?.link).toBe('/getting-started');\n\n    const apiItem = navigation.items.find(item => item.title === 'API Reference');\n    expect(apiItem?.link).toBe('/api/');\n\n    const usersApiItem = apiItem?.children?.[0];\n    expect(usersApiItem?.link).toBe('/api/users');\n  });\n\n  test('should handle empty content list', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation([]);\n\n    expect(navigation).toBeDefined();\n    expect(navigation.items).toEqual([]);\n  });\n\n  test('should handle content without originalPath', () => {\n    const contentWithoutPath: ParsedContent[] = [\n      {\n        title: 'No Path',\n        content: 'Content without path',\n        sections: [],\n        metadata: {},\n      },\n    ];\n\n    const generator = new NavigationGenerator('/test/source');\n    const navigation = generator.generateNavigation(contentWithoutPath);\n\n    // Content without path should be excluded\n    expect(navigation.items).toEqual([]);\n  });\n\n  test('should generate sidebar navigation', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const sidebar = generator.generateSidebar(sampleParsedContent);\n\n    expect(sidebar).toBeDefined();\n    expect(sidebar).toContain('* [Home](/)');\n    expect(sidebar).toContain('* [Getting Started](/getting-started)');\n    expect(sidebar).toContain('* [API Reference](/api/)');\n    expect(sidebar).toContain('  * [Users API](/api/users)');\n  });\n\n  test('should generate navbar navigation', () => {\n    const generator = new NavigationGenerator('/test/source');\n    const navbar = generator.generateNavbar(sampleParsedContent);\n\n    expect(navbar).toBeDefined();\n    expect(navbar).toContain('* [Home](/)');\n    expect(navbar).toContain('* [Getting Started](/getting-started)');\n    expect(navbar).toContain('* [API Reference](/api/)');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/parsers/DocsifyMarkdownParser.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ParsedContent' is defined but never used.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filePath' is defined but never used.","line":193,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":193,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filePath' is defined but never used.","line":210,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":210,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DocsifyMarkdownParser } from '../../parsers/DocsifyMarkdownParser.js';\nimport { ParsedContent } from '../../../types/parser.js';\nimport { logger } from './utils/logger.js';\n\ndescribe('DocsifyMarkdownParser', () => {\n  let parser: DocsifyMarkdownParser;\n\n  beforeEach(() => {\n    parser = new DocsifyMarkdownParser();\n  });\n\n  test('should parse basic markdown', async () => {\n    const markdown = '# Hello World\\n\\nThis is a test.';\n    const result = await parser.parse(markdown);\n\n    expect(result.title).toBe('Hello World');\n    expect(result.sections.length).toBe(1);\n    expect(result.sections[0].title).toBe('Hello World');\n    expect(result.sections[0].content).toContain('This is a test.');\n  });\n\n  test('should extract frontmatter', async () => {\n    const markdown = `---\ntitle: Custom Title\ndescription: Custom description\n---\n\n# Hello World\n\nThis is a test.`;\n\n    const result = await parser.parse(markdown);\n\n    expect(result.title).toBe('Custom Title');\n    expect(result.description).toBe('Custom description');\n    expect(result.metadata.title).toBe('Custom Title');\n    expect(result.metadata.description).toBe('Custom description');\n  });\n\n  test('should extract assets', async () => {\n    const markdown = '# Hello World\\n\\n![Image](image.png)\\n\\nThis is a test.';\n    const result = await parser.parse(markdown);\n\n    expect(result.assets.length).toBe(1);\n    expect(result.assets[0].type).toBe('image');\n    expect(result.assets[0].path).toBe('image.png');\n    expect(result.assets[0].metadata.altText).toBe('Image');\n  });\n\n  test('should extract references', async () => {\n    const markdown = '# Hello World\\n\\n[Link](https://example.com)\\n\\nThis is a test.';\n    const result = await parser.parse(markdown);\n\n    expect(result.references.length).toBe(1);\n    expect(result.references[0].type).toBe('external');\n    expect(result.references[0].target).toBe('https://example.com');\n    expect(result.references[0].attributes.text).toBe('Link');\n  });\n\n  test('should handle multiple sections with different heading levels', async () => {\n    const markdown = `# Main Title\n\nMain content.\n\n## Section 1\n\nSection 1 content.\n\n### Subsection 1.1\n\nSubsection 1.1 content.\n\n## Section 2\n\nSection 2 content.`;\n\n    const result = await parser.parse(markdown);\n\n    expect(result.sections.length).toBe(4);\n    expect(result.sections[0].level).toBe(1);\n    expect(result.sections[0].title).toBe('Main Title');\n    expect(result.sections[1].level).toBe(2);\n    expect(result.sections[1].title).toBe('Section 1');\n    expect(result.sections[2].level).toBe(3);\n    expect(result.sections[2].title).toBe('Subsection 1.1');\n    expect(result.sections[3].level).toBe(2);\n    expect(result.sections[3].title).toBe('Section 2');\n  });\n\n  test('should handle code blocks correctly', async () => {\n    const markdown = `# Code Example\n\n\\`\\`\\`javascript\nconst hello = 'world';\nlogger.debug(hello);\n\\`\\`\\`\n\nRegular text.`;\n\n    const result = await parser.parse(markdown);\n\n    expect(result.sections[0].content).toContain('```javascript');\n    expect(result.sections[0].content).toContain(\"const hello = 'world';\");\n    expect(result.sections[0].content).toContain('logger.debug(hello);');\n    expect(result.sections[0].content).toContain('```');\n  });\n\n  test('should handle Docsify-specific syntax', async () => {\n    const markdown = `# Docsify Features\n\n<!-- {docsify-ignore} -->\n\n?> This is a tip\n\n!> This is a warning\n\n[toc]\n\n[Link Text](guide.md#anchor)`;\n\n    const result = await parser.parse(markdown);\n\n    expect(result.sections[0].content).toContain('<!-- {docsify-ignore} -->');\n    expect(result.sections[0].content).toContain('?> This is a tip');\n    expect(result.sections[0].content).toContain('!> This is a warning');\n    expect(result.sections[0].content).toContain('[toc]');\n    // Docsify transforms relative links to hash-based routing\n    expect(result.sections[0].content).toContain('[Link Text](#/guide#anchor)');\n  });\n\n  test('should handle empty or invalid markdown', async () => {\n    const emptyMarkdown = '';\n    const result = await parser.parse(emptyMarkdown);\n\n    expect(result.title).toBe('');\n    expect(result.content).toBe('');\n    expect(result.sections.length).toBe(0);\n  });\n\n  test('should handle markdown with only frontmatter', async () => {\n    const markdownWithOnlyFrontmatter = `---\ntitle: Just Frontmatter\ndescription: No content\n---`;\n\n    const result = await parser.parse(markdownWithOnlyFrontmatter);\n\n    expect(result.title).toBe('Just Frontmatter');\n    expect(result.description).toBe('No content');\n    expect(result.content).toBe('');\n    expect(result.sections.length).toBe(0);\n  });\n\n  test('should handle markdown with tables', async () => {\n    const markdownWithTable = `# Table Example\n\n| Header 1 | Header 2 |\n| -------- | -------- |\n| Cell 1   | Cell 2   |\n| Cell 3   | Cell 4   |`;\n\n    const result = await parser.parse(markdownWithTable);\n\n    expect(result.sections[0].content).toContain('| Header 1 | Header 2 |');\n    expect(result.sections[0].content).toContain('| -------- | -------- |');\n    expect(result.sections[0].content).toContain('| Cell 1   | Cell 2   |');\n    expect(result.sections[0].content).toContain('| Cell 3   | Cell 4   |');\n  });\n\n  test('should handle markdown with lists', async () => {\n    const markdownWithLists = `# Lists Example\n\n- Item 1\n- Item 2\n  - Nested Item 1\n  - Nested Item 2\n- Item 3\n\n1. Ordered Item 1\n2. Ordered Item 2\n3. Ordered Item 3`;\n\n    const result = await parser.parse(markdownWithLists);\n\n    expect(result.sections[0].content).toContain('- Item 1');\n    expect(result.sections[0].content).toContain('  - Nested Item 1');\n    expect(result.sections[0].content).toContain('1. Ordered Item 1');\n  });\n\n  test('should handle file paths correctly', async () => {\n    // Mock the parser's file handling methods\n    const originalReadFile = parser.readFile;\n    parser.readFile = jest.fn().mockImplementation((filePath: string) => {\n      return '# File Content\\n\\nThis is content from a file.';\n    });\n\n    const result = await parser.parseFile('/path/to/document.md');\n\n    expect(result.title).toBe('File Content');\n    expect(result.content).toContain('This is content from a file.');\n    expect(result.metadata.originalPath).toBe('/path/to/document.md');\n\n    // Restore original method\n    parser.readFile = originalReadFile;\n  });\n\n  test('should handle errors gracefully', async () => {\n    // Mock the parser's file handling methods to throw an error\n    const originalReadFile = parser.readFile;\n    parser.readFile = jest.fn().mockImplementation((filePath: string) => {\n      throw new Error('File not found');\n    });\n\n    await expect(parser.parseFile('/non-existent/file.md')).rejects.toThrow('File not found');\n\n    // Restore original method\n    parser.readFile = originalReadFile;\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/parsers/OpenAPIParser.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ParsedContent' is defined but never used.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filePath' is defined but never used.","line":190,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":190,"endColumn":70}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { OpenAPIParser } from '../../parsers/OpenAPIParser.js';\nimport { ParsedContent } from '../../../types/parser.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('OpenAPIParser', () => {\n  // Sample OpenAPI specification\n  const sampleOpenAPISpec = {\n    openapi: '3.0.0',\n    info: {\n      title: 'Test API',\n      version: '1.0.0',\n      description: 'A test API for OpenAPIParser',\n    },\n    paths: {\n      '/users': {\n        get: {\n          summary: 'Get all users',\n          description: 'Returns a list of users',\n          responses: {\n            '200': {\n              description: 'Successful operation',\n              content: {\n                'application/json': {\n                  schema: {\n                    type: 'array',\n                    items: {\n                      $ref: '#/components/schemas/User',\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n        post: {\n          summary: 'Create a user',\n          description: 'Creates a new user',\n          requestBody: {\n            content: {\n              'application/json': {\n                schema: {\n                  $ref: '#/components/schemas/User',\n                },\n              },\n            },\n          },\n          responses: {\n            '201': {\n              description: 'User created',\n            },\n          },\n        },\n      },\n      '/users/{id}': {\n        get: {\n          summary: 'Get user by ID',\n          description: 'Returns a single user',\n          parameters: [\n            {\n              name: 'id',\n              in: 'path',\n              required: true,\n              schema: {\n                type: 'integer',\n              },\n            },\n          ],\n          responses: {\n            '200': {\n              description: 'Successful operation',\n              content: {\n                'application/json': {\n                  schema: {\n                    $ref: '#/components/schemas/User',\n                  },\n                },\n              },\n            },\n            '404': {\n              description: 'User not found',\n            },\n          },\n        },\n      },\n    },\n    components: {\n      schemas: {\n        User: {\n          type: 'object',\n          properties: {\n            id: {\n              type: 'integer',\n              format: 'int64',\n            },\n            name: {\n              type: 'string',\n            },\n            email: {\n              type: 'string',\n              format: 'email',\n            },\n          },\n          required: ['name', 'email'],\n        },\n      },\n    },\n  };\n\n  // Sample OpenAPI JSON string\n  const sampleOpenAPIJSON = JSON.stringify(sampleOpenAPISpec, null, 2);\n\n  // Sample OpenAPI YAML string\n  const sampleOpenAPIYAML = `\nopenapi: 3.0.0\ninfo:\n  title: Test API\n  version: 1.0.0\n  description: A test API for OpenAPIParser\npaths:\n  /users:\n    get:\n      summary: Get all users\n      description: Returns a list of users\n      responses:\n        '200':\n          description: Successful operation\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/User'\n    post:\n      summary: Create a user\n      description: Creates a new user\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/User'\n      responses:\n        '201':\n          description: User created\n  /users/{id}:\n    get:\n      summary: Get user by ID\n      description: Returns a single user\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Successful operation\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'\n        '404':\n          description: User not found\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        email:\n          type: string\n          format: email\n      required:\n        - name\n        - email\n`;\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for files\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return true;\n    });\n\n    // Mock fs.readFileSync to return sample OpenAPI spec\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.json')) {\n        return sampleOpenAPIJSON;\n      } else if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {\n        return sampleOpenAPIYAML;\n      }\n      throw new Error(`Unexpected file extension: ${filePath}`);\n    });\n\n    // Mock path.extname to return the correct extension\n    (path.extname as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.json')) {\n        return '.json';\n      } else if (filePath.endsWith('.yaml')) {\n        return '.yaml';\n      } else if (filePath.endsWith('.yml')) {\n        return '.yml';\n      }\n      return '';\n    });\n\n    // Mock path.basename to return the filename\n    (path.basename as jest.Mock).mockImplementation((filePath: string, ext?: string) => {\n      const parts = filePath.split('/');\n      let filename = parts[parts.length - 1];\n      if (ext && filename.endsWith(ext)) {\n        filename = filename.slice(0, -ext.length);\n      }\n      return filename;\n    });\n  });\n\n  test('should initialize with default options', () => {\n    const parser = new OpenAPIParser();\n    expect(parser).toBeDefined();\n  });\n\n  test('should initialize with custom options', () => {\n    const options = {\n      validateSchema: true,\n      includeExamples: true,\n    };\n\n    const parser = new OpenAPIParser(options);\n    expect(parser.options).toEqual(options);\n  });\n\n  test('should parse OpenAPI JSON file', () => {\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/api.json');\n\n    expect(result).toBeDefined();\n    expect(result.title).toBe('Test API');\n    expect(result.content).toContain('A test API for OpenAPIParser');\n    expect(result.sections).toBeDefined();\n    expect(result.sections.length).toBeGreaterThan(0);\n  });\n\n  test('should parse OpenAPI YAML file', () => {\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/api.yaml');\n\n    expect(result).toBeDefined();\n    expect(result.title).toBe('Test API');\n    expect(result.content).toContain('A test API for OpenAPIParser');\n    expect(result.sections).toBeDefined();\n    expect(result.sections.length).toBeGreaterThan(0);\n  });\n\n  test('should extract API paths as sections', () => {\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/api.json');\n\n    // Check that paths are extracted as sections\n    const pathSections = result.sections.filter(\n      section => section.title === '/users' || section.title === '/users/{id}'\n    );\n\n    expect(pathSections.length).toBe(2);\n\n    // Check /users path\n    const usersSection = pathSections.find(section => section.title === '/users');\n    expect(usersSection).toBeDefined();\n    expect(usersSection?.content).toContain('Get all users');\n    expect(usersSection?.content).toContain('Create a user');\n\n    // Check /users/{id} path\n    const userByIdSection = pathSections.find(section => section.title === '/users/{id}');\n    expect(userByIdSection).toBeDefined();\n    expect(userByIdSection?.content).toContain('Get user by ID');\n  });\n\n  test('should extract schemas as sections', () => {\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/api.json');\n\n    // Check that schemas are extracted as sections\n    const schemaSection = result.sections.find(section => section.title === 'User Schema');\n\n    expect(schemaSection).toBeDefined();\n    expect(schemaSection?.content).toContain('id');\n    expect(schemaSection?.content).toContain('name');\n    expect(schemaSection?.content).toContain('email');\n  });\n\n  test('should handle non-existent files', () => {\n    // Mock fs.existsSync to return false\n    (fs.existsSync as jest.Mock).mockReturnValue(false);\n\n    const parser = new OpenAPIParser();\n\n    expect(() => {\n      parser.parse('/test/non-existent.json');\n    }).toThrow('File not found: /test/non-existent.json');\n  });\n\n  test('should handle invalid JSON', () => {\n    // Mock fs.readFileSync to return invalid JSON\n    (fs.readFileSync as jest.Mock).mockReturnValue('{ invalid json }');\n\n    const parser = new OpenAPIParser();\n\n    expect(() => {\n      parser.parse('/test/invalid.json');\n    }).toThrow('Failed to parse OpenAPI specification');\n  });\n\n  test('should handle invalid YAML', () => {\n    // Mock fs.readFileSync to return invalid YAML\n    (fs.readFileSync as jest.Mock).mockReturnValue('invalid: yaml: :');\n\n    const parser = new OpenAPIParser();\n\n    expect(() => {\n      parser.parse('/test/invalid.yaml');\n    }).toThrow('Failed to parse OpenAPI specification');\n  });\n\n  test('should validate schema when enabled', () => {\n    const parser = new OpenAPIParser({ validateSchema: true });\n\n    // Mock the validateSchema method\n    parser.validateSchema = jest.fn();\n\n    parser.parse('/test/api.json');\n\n    expect(parser.validateSchema).toHaveBeenCalled();\n  });\n\n  test('should not validate schema when disabled', () => {\n    const parser = new OpenAPIParser({ validateSchema: false });\n\n    // Mock the validateSchema method\n    parser.validateSchema = jest.fn();\n\n    parser.parse('/test/api.json');\n\n    expect(parser.validateSchema).not.toHaveBeenCalled();\n  });\n\n  test('should include examples when enabled', () => {\n    const parser = new OpenAPIParser({ includeExamples: true });\n    const result = parser.parse('/test/api.json');\n\n    // Check that examples are included\n    expect(result.metadata.examples).toBeDefined();\n  });\n\n  test('should not include examples when disabled', () => {\n    const parser = new OpenAPIParser({ includeExamples: false });\n    const result = parser.parse('/test/api.json');\n\n    // Check that examples are not included\n    expect(result.metadata.examples).toBeUndefined();\n  });\n\n  test('should handle OpenAPI 2.0 (Swagger) specifications', () => {\n    // Mock fs.readFileSync to return Swagger 2.0 spec\n    (fs.readFileSync as jest.Mock).mockReturnValue(\n      JSON.stringify({\n        swagger: '2.0',\n        info: {\n          title: 'Swagger API',\n          version: '1.0.0',\n        },\n        paths: {\n          '/users': {\n            get: {\n              summary: 'Get all users',\n            },\n          },\n        },\n      })\n    );\n\n    const parser = new OpenAPIParser();\n    const result = parser.parse('/test/swagger.json');\n\n    expect(result).toBeDefined();\n    expect(result.title).toBe('Swagger API');\n    expect(result.sections.some(section => section.title === '/users')).toBe(true);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/parsers/ParserFactory.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[950,953],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[950,953],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ParserFactory } from '../../parsers/ParserFactory.js';\nimport { DocsifyMarkdownParser } from '../../parsers/DocsifyMarkdownParser.js';\n\ndescribe('ParserFactory', () => {\n  let parserFactory: ParserFactory;\n\n  beforeEach(() => {\n    parserFactory = new ParserFactory();\n  });\n\n  test('should initialize with no parsers', () => {\n    expect(parserFactory).toBeDefined();\n    expect(parserFactory.getParsers()).toEqual({});\n  });\n\n  test('should register a parser', () => {\n    const parser = new DocsifyMarkdownParser();\n    parserFactory.register('md', parser);\n\n    expect(parserFactory.getParsers()).toHaveProperty('md');\n    expect(parserFactory.getParsers()['md']).toBe(parser);\n  });\n\n  test('should register multiple parsers', () => {\n    const markdownParser = new DocsifyMarkdownParser();\n    const jsonParser = { parse: jest.fn() };\n\n    parserFactory.register('md', markdownParser);\n    parserFactory.register('json', jsonParser as any);\n\n    expect(parserFactory.getParsers()).toHaveProperty('md');\n    expect(parserFactory.getParsers()).toHaveProperty('json');\n    expect(parserFactory.getParsers()['md']).toBe(markdownParser);\n    expect(parserFactory.getParsers()['json']).toBe(jsonParser);\n  });\n\n  test('should get a registered parser', () => {\n    const parser = new DocsifyMarkdownParser();\n    parserFactory.register('md', parser);\n\n    const retrievedParser = parserFactory.getParser('md');\n    expect(retrievedParser).toBe(parser);\n  });\n\n  test('should throw error when getting an unregistered parser', () => {\n    expect(() => {\n      parserFactory.getParser('unknown');\n    }).toThrow('No parser registered for extension: unknown');\n  });\n\n  test('should check if a parser is registered', () => {\n    const parser = new DocsifyMarkdownParser();\n    parserFactory.register('md', parser);\n\n    expect(parserFactory.hasParser('md')).toBe(true);\n    expect(parserFactory.hasParser('unknown')).toBe(false);\n  });\n\n  test('should unregister a parser', () => {\n    const parser = new DocsifyMarkdownParser();\n    parserFactory.register('md', parser);\n    expect(parserFactory.hasParser('md')).toBe(true);\n\n    parserFactory.unregister('md');\n    expect(parserFactory.hasParser('md')).toBe(false);\n  });\n\n  test('should do nothing when unregistering a non-existent parser', () => {\n    expect(() => {\n      parserFactory.unregister('unknown');\n    }).not.toThrow();\n  });\n\n  test('should get parser for file by extension', () => {\n    const parser = new DocsifyMarkdownParser();\n    parserFactory.register('md', parser);\n\n    const retrievedParser = parserFactory.getParserForFile('document.md');\n    expect(retrievedParser).toBe(parser);\n  });\n\n  test('should throw error when getting parser for file with unknown extension', () => {\n    expect(() => {\n      parserFactory.getParserForFile('document.unknown');\n    }).toThrow('No parser registered for file: document.unknown');\n  });\n\n  test('should handle file paths with multiple dots', () => {\n    const parser = new DocsifyMarkdownParser();\n    parserFactory.register('md', parser);\n\n    const retrievedParser = parserFactory.getParserForFile('path/to/document.v1.md');\n    expect(retrievedParser).toBe(parser);\n  });\n\n  test('should handle file paths with no extension', () => {\n    expect(() => {\n      parserFactory.getParserForFile('document');\n    }).toThrow('No parser registered for file: document');\n  });\n\n  test('should register default parsers', () => {\n    parserFactory.registerDefaultParsers();\n\n    expect(parserFactory.hasParser('md')).toBe(true);\n    expect(parserFactory.hasParser('markdown')).toBe(true);\n  });\n\n  test('should clear all parsers', () => {\n    const parser = new DocsifyMarkdownParser();\n    parserFactory.register('md', parser);\n    parserFactory.register('markdown', parser);\n    expect(parserFactory.hasParser('md')).toBe(true);\n    expect(parserFactory.hasParser('markdown')).toBe(true);\n\n    parserFactory.clear();\n    expect(parserFactory.hasParser('md')).toBe(false);\n    expect(parserFactory.hasParser('markdown')).toBe(false);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/MarkdownEnhancerPlugin.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Plugin' is defined but never used.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MarkdownEnhancerPlugin } from '../../plugins/MarkdownEnhancerPlugin.js';\nimport { PluginSystem } from '../../plugins/PluginSystem.js';\nimport { ParsedContent } from '../../../types/parser.js';\nimport { Plugin } from '../../../types/plugin.js';\nimport { logger } from './utils/logger.js';\n\ndescribe('MarkdownEnhancerPlugin', () => {\n  // Sample parsed content\n  const sampleParsedContent: ParsedContent = {\n    title: 'Test Document',\n    content: 'This is a test document with some content.',\n    sections: [\n      {\n        level: 1,\n        title: 'Test Document',\n        content: 'This is a test document with some content.',\n      },\n      {\n        level: 2,\n        title: 'Section 1',\n        content: 'Content for section 1.',\n      },\n    ],\n    metadata: {\n      originalPath: '/test/document.md',\n      title: 'Test Document',\n      description: 'This is a test document',\n    },\n  };\n\n  // Sample markdown content\n  const sampleMarkdown = `# Test Document\n\nThis is a test document with some content.\n\n## Section 1\n\nContent for section 1.\n\n\\`\\`\\`js\n// Code block\nconst test = 'Hello World';\nlogger.debug(test);\n\\`\\`\\`\n\n[Link to another page](another-page.md)\n`;\n\n  test('should initialize with default options', () => {\n    const plugin = new MarkdownEnhancerPlugin();\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('markdown-enhancer');\n    expect(plugin.options).toBeDefined();\n    expect(plugin.hooks).toBeDefined();\n  });\n\n  test('should initialize with custom options', () => {\n    const customOptions = {\n      enableCodeHighlighting: true,\n      enableTableOfContents: true,\n      enableFootnotes: false,\n    };\n\n    const plugin = new MarkdownEnhancerPlugin(customOptions);\n    expect(plugin.options).toEqual(customOptions);\n  });\n\n  test('should enhance code blocks in beforeParse hook', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableCodeHighlighting: true });\n    const result = plugin.hooks.beforeParse?.(sampleMarkdown, plugin.options);\n\n    expect(result).toContain('```js');\n    expect(result).toContain('// Code block');\n    expect(result).toContain(\"const test = 'Hello World';\");\n    expect(result).toContain('logger.debug(test);');\n    expect(result).toContain('```');\n\n    // Should add language class for syntax highlighting\n    expect(result).toContain('class=\"language-js\"');\n  });\n\n  test('should not enhance code blocks when disabled', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableCodeHighlighting: false });\n    const result = plugin.hooks.beforeParse?.(sampleMarkdown, plugin.options);\n\n    expect(result).toContain('```js');\n    expect(result).not.toContain('class=\"language-js\"');\n  });\n\n  test('should add table of contents in afterParse hook', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableTableOfContents: true });\n    const result = plugin.hooks.afterParse?.(sampleParsedContent, plugin.options);\n\n    expect(result).toBeDefined();\n    expect(result?.metadata.tableOfContents).toBeDefined();\n    expect(result?.metadata.tableOfContents).toHaveLength(2);\n    expect(result?.metadata.tableOfContents?.[0].title).toBe('Test Document');\n    expect(result?.metadata.tableOfContents?.[0].level).toBe(1);\n    expect(result?.metadata.tableOfContents?.[1].title).toBe('Section 1');\n    expect(result?.metadata.tableOfContents?.[1].level).toBe(2);\n  });\n\n  test('should not add table of contents when disabled', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableTableOfContents: false });\n    const result = plugin.hooks.afterParse?.(sampleParsedContent, plugin.options);\n\n    expect(result).toBeDefined();\n    expect(result?.metadata.tableOfContents).toBeUndefined();\n  });\n\n  test('should work with PluginSystem', () => {\n    const plugin = new MarkdownEnhancerPlugin();\n    const pluginSystem = new PluginSystem([plugin]);\n\n    const result = pluginSystem.executeHook('beforeParse', sampleMarkdown);\n    expect(result).toBeDefined();\n\n    const parsedResult = pluginSystem.executeHook('afterParse', sampleParsedContent);\n    expect(parsedResult).toBeDefined();\n    expect(parsedResult.metadata.tableOfContents).toBeDefined();\n  });\n\n  test('should handle empty content gracefully', () => {\n    const plugin = new MarkdownEnhancerPlugin();\n    const emptyMarkdown = '';\n\n    const result = plugin.hooks.beforeParse?.(emptyMarkdown, plugin.options);\n    expect(result).toBe('');\n\n    const emptyParsedContent: ParsedContent = {\n      title: '',\n      content: '',\n      sections: [],\n      metadata: {},\n    };\n\n    const parsedResult = plugin.hooks.afterParse?.(emptyParsedContent, plugin.options);\n    expect(parsedResult).toBeDefined();\n    expect(parsedResult?.metadata.tableOfContents).toHaveLength(0);\n  });\n\n  test('should handle content without headings', () => {\n    const plugin = new MarkdownEnhancerPlugin();\n    const markdownWithoutHeadings = 'This is content without any headings.';\n\n    const result = plugin.hooks.beforeParse?.(markdownWithoutHeadings, plugin.options);\n    expect(result).toBe(markdownWithoutHeadings);\n\n    const parsedContentWithoutHeadings: ParsedContent = {\n      title: 'No Headings',\n      content: 'This is content without any headings.',\n      sections: [],\n      metadata: {},\n    };\n\n    const parsedResult = plugin.hooks.afterParse?.(parsedContentWithoutHeadings, plugin.options);\n    expect(parsedResult).toBeDefined();\n    expect(parsedResult?.metadata.tableOfContents).toHaveLength(0);\n  });\n\n  test('should process footnotes when enabled', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableFootnotes: true });\n    const markdownWithFootnotes =\n      'This is a text with a footnote[^1].\\n\\n[^1]: This is the footnote content.';\n\n    const result = plugin.hooks.beforeParse?.(markdownWithFootnotes, plugin.options);\n    expect(result).toContain('This is a text with a footnote');\n    expect(result).toContain('This is the footnote content');\n    expect(result).toContain('<div class=\"footnote\"');\n  });\n\n  test('should not process footnotes when disabled', () => {\n    const plugin = new MarkdownEnhancerPlugin({ enableFootnotes: false });\n    const markdownWithFootnotes =\n      'This is a text with a footnote[^1].\\n\\n[^1]: This is the footnote content.';\n\n    const result = plugin.hooks.beforeParse?.(markdownWithFootnotes, plugin.options);\n    expect(result).not.toContain('<div class=\"footnote\"');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/PluginLoader.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Plugin' is defined but never used.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dirPath' is defined but never used.","line":62,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":62,"endColumn":70},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2741,2744],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2741,2744],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3162,3165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3162,3165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PluginLoader } from '../../plugins/PluginLoader.js';\nimport { Plugin } from '../../../types/plugin.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { logger } from './utils/logger.js';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('PluginLoader', () => {\n  // Sample plugin files\n  const mockPluginFiles = {\n    '/plugins/test-plugin.js': `\n      module.exports = {\n        name: 'test-plugin',\n        version: '1.0.0',\n        hooks: {\n          beforeParse: (_content) => 'Modified by test-plugin: ' + content,\n          afterParse: (parsed) => ({ ...parsed, title: 'Enhanced by test-plugin: ' + parsed.title })\n        }\n      };\n    `,\n    '/plugins/another-plugin.js': `\n      module.exports = {\n        name: 'another-plugin',\n        version: '1.0.0',\n        options: {\n          option1: 'default-value'\n        },\n        hooks: {\n          beforeParse: (content, options) => 'Modified by another-plugin with ' + options.option1 + ': ' + content\n        }\n      };\n    `,\n    '/plugins/invalid-plugin.js': `\n      // This is not a valid plugin\n      logger.debug('This is not a plugin');\n    `,\n    '/plugins/error-plugin.js': `\n      throw new Error('Plugin error');\n    `,\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for plugin files\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath in mockPluginFiles || filePath === '/plugins';\n    });\n\n    // Mock fs.readFileSync to return mock plugin files\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath in mockPluginFiles) {\n        return mockPluginFiles[filePath];\n      }\n      throw new Error(`File not found: ${filePath}`);\n    });\n\n    // Mock fs.readdirSync to return plugin files\n    (fs.readdirSync as jest.Mock).mockImplementation((dirPath: string) => {\n      if (_dirPath === '/plugins') {\n        return ['test-plugin.js', 'another-plugin.js', 'invalid-plugin.js', 'error-plugin.js'];\n      }\n      return [];\n    });\n\n    // Mock path.resolve to return the input path\n    (path.resolve as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n\n    // Mock require to return plugin modules\n    jest.mock(\n      '/plugins/test-plugin.js',\n      () => ({\n        name: 'test-plugin',\n        version: '1.0.0',\n        hooks: {\n          beforeParse: (content: string) => 'Modified by test-plugin: ' + content,\n          afterParse: (parsed: any) => ({\n            ...parsed,\n            title: 'Enhanced by test-plugin: ' + parsed.title,\n          }),\n        },\n      }),\n      { virtual: true }\n    );\n\n    jest.mock(\n      '/plugins/another-plugin.js',\n      () => ({\n        name: 'another-plugin',\n        version: '1.0.0',\n        options: {\n          option1: 'default-value',\n        },\n        hooks: {\n          beforeParse: (content: string, options: any) =>\n            'Modified by another-plugin with ' + options.option1 + ': ' + content,\n        },\n      }),\n      { virtual: true }\n    );\n\n    jest.mock(\n      '/plugins/invalid-plugin.js',\n      () => ({\n        // Not a valid plugin\n        notAPlugin: true,\n      }),\n      { virtual: true }\n    );\n\n    jest.mock(\n      '/plugins/error-plugin.js',\n      () => {\n        throw new Error('Plugin error');\n      },\n      { virtual: true }\n    );\n  });\n\n  test('should initialize with plugin directory', () => {\n    const loader = new PluginLoader('/plugins');\n    expect(loader).toBeDefined();\n  });\n\n  test('should load plugin from file', async () => {\n    const loader = new PluginLoader('/plugins');\n    const plugin = await loader.loadPluginFromFile('/plugins/test-plugin.js');\n\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('test-plugin');\n    expect(plugin.hooks).toBeDefined();\n    expect(plugin.hooks.beforeParse).toBeDefined();\n    expect(plugin.hooks.afterParse).toBeDefined();\n  });\n\n  test('should load plugin with options', async () => {\n    const loader = new PluginLoader('/plugins');\n    const plugin = await loader.loadPluginFromFile('/plugins/another-plugin.js');\n\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('another-plugin');\n    expect(plugin.options).toBeDefined();\n    expect(plugin.options.option1).toBe('default-value');\n    expect(plugin.hooks).toBeDefined();\n    expect(plugin.hooks.beforeParse).toBeDefined();\n  });\n\n  test('should handle invalid plugin files', async () => {\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginFromFile('/plugins/invalid-plugin.js')).rejects.toThrow(\n      'Invalid plugin format'\n    );\n  });\n\n  test('should handle errors when loading plugins', async () => {\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginFromFile('/plugins/error-plugin.js')).rejects.toThrow(\n      'Plugin error'\n    );\n  });\n\n  test('should handle non-existent plugin files', async () => {\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginFromFile('/plugins/non-existent-plugin.js')).rejects.toThrow(\n      'Plugin file not found'\n    );\n  });\n\n  test('should load all plugins from directory', async () => {\n    const loader = new PluginLoader('/plugins');\n    const plugins = await loader.loadPluginsFromDirectory();\n\n    // Should only load valid plugins\n    expect(plugins).toHaveLength(2);\n    expect(plugins[0].name).toBe('test-plugin');\n    expect(plugins[1].name).toBe('another-plugin');\n  });\n\n  test('should handle errors when loading plugins from directory', async () => {\n    // Mock fs.readdirSync to throw an error\n    (fs.readdirSync as jest.Mock).mockImplementation(() => {\n      throw new Error('Directory error');\n    });\n\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginsFromDirectory()).rejects.toThrow(\n      'Failed to load plugins from directory'\n    );\n  });\n\n  test('should load plugins with custom options', async () => {\n    const loader = new PluginLoader('/plugins');\n    const customOptions = {\n      'another-plugin': {\n        option1: 'custom-value',\n      },\n    };\n\n    const plugins = await loader.loadPluginsFromDirectory(customOptions);\n\n    expect(plugins).toHaveLength(2);\n    expect(plugins[1].name).toBe('another-plugin');\n    expect(plugins[1].options.option1).toBe('custom-value');\n  });\n\n  test('should load specific plugins by name', async () => {\n    const loader = new PluginLoader('/plugins');\n    const plugins = await loader.loadPluginsByName(['test-plugin']);\n\n    expect(plugins).toHaveLength(1);\n    expect(plugins[0].name).toBe('test-plugin');\n  });\n\n  test('should handle non-existent plugins when loading by name', async () => {\n    const loader = new PluginLoader('/plugins');\n\n    await expect(loader.loadPluginsByName(['non-existent-plugin'])).rejects.toThrow(\n      'Plugin not found'\n    );\n  });\n\n  test('should validate plugin structure', () => {\n    const loader = new PluginLoader('/plugins');\n\n    // Valid plugin\n    const validPlugin = {\n      name: 'valid-plugin',\n      version: '1.0.0',\n      hooks: {\n        beforeParse: () => '',\n      },\n    };\n    expect(loader.isValidPlugin(validPlugin)).toBe(true);\n\n    // Invalid plugin - no name\n    const noNamePlugin = {\n      hooks: {\n        beforeParse: () => '',\n      },\n    };\n    expect(loader.isValidPlugin(noNamePlugin)).toBe(false);\n\n    // Invalid plugin - no hooks\n    const noHooksPlugin = {\n      name: 'no-hooks-plugin',\n    };\n    expect(loader.isValidPlugin(noHooksPlugin)).toBe(false);\n\n    // Invalid plugin - hooks is not an object\n    const invalidHooksPlugin = {\n      name: 'invalid-hooks-plugin',\n      hooks: 'not an object',\n    };\n    expect(loader.isValidPlugin(invalidHooksPlugin)).toBe(false);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/PluginSystem.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/SiteMapGenerator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[451,454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[451,454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1973,1976],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1973,1976],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2026,2029],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2026,2029],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2117,2120],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2117,2120],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2184,2187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2184,2187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2250,2253],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2250,2253],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2900,2903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2900,2903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2953,2956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2953,2956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4479,4482],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4479,4482],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4539,4542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4539,4542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5243,5246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5243,5246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5296,5299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5296,5299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5361,5364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5361,5364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":234,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7393,7396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7393,7396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":290,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8939,8942],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8939,8942],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":291,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":291,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9006,9009],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9006,9009],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9073,9076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9073,9076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":323,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":323,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9932,9935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9932,9935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SiteMapGenerator } from '../../plugins/SiteMapGenerator.js';\nimport { ParsedContent } from '../../../types/parser.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('SiteMapGenerator', () => {\n  let generator: SiteMapGenerator;\n\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks();\n\n    // Mock fs.promises.writeFile to do nothing\n    (fs.promises as any) = {\n      writeFile: jest.fn().mockResolvedValue(undefined),\n    };\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => paths.join('/'));\n\n    // Create the generator\n    generator = new SiteMapGenerator({\n      baseUrl: 'https://example.com',\n    });\n  });\n\n  test('should initialize with default options', () => {\n    expect(generator).toBeDefined();\n    expect(generator.name).toBe('sitemap-generator');\n    expect(generator.description).toBe('Generates a sitemap.xml file for the website');\n  });\n\n  test('should initialize with custom options', () => {\n    const customGenerator = new SiteMapGenerator({\n      baseUrl: 'https://example.com',\n      outputPath: 'custom-sitemap.xml',\n      defaultChangeFreq: 'daily',\n      defaultPriority: 0.8,\n      includeLastMod: false,\n      exclude: ['private/*', 'admin.html'],\n    });\n\n    expect(customGenerator).toBeDefined();\n  });\n\n  test('should collect URL information after parsing', () => {\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Page',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {\n        originalPath: '/content/test-page.md',\n        lastModified: 1625097600000, // 2021-07-01\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the afterParse hook\n    generator.hooks.afterParse(parsedContent);\n\n    // Verify that the URL was added\n    expect((generator as any).urls).toHaveLength(1);\n    expect((generator as any).urls[0].loc).toBe('https://example.com/content/test-page/');\n    expect((generator as any).urls[0].lastmod).toBe('2021-07-01');\n    expect((generator as any).urls[0].changefreq).toBe('weekly');\n    expect((generator as any).urls[0].priority).toBe(0.5);\n  });\n\n  test('should handle index files correctly', () => {\n    // Create mock parsed content for an index file\n    const parsedContent: ParsedContent = {\n      title: 'Home Page',\n      description: 'Home page description',\n      content: 'Home page content',\n      metadata: {\n        originalPath: '/content/index.md',\n        lastModified: 1625097600000, // 2021-07-01\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the afterParse hook\n    generator.hooks.afterParse(parsedContent);\n\n    // Verify that the URL was added with the correct path\n    expect((generator as any).urls).toHaveLength(1);\n    expect((generator as any).urls[0].loc).toBe('https://example.com/content/');\n  });\n\n  test('should exclude paths based on patterns', () => {\n    // Create a generator with exclude patterns\n    const excludeGenerator = new SiteMapGenerator({\n      baseUrl: 'https://example.com',\n      exclude: ['private/*', 'admin.html'],\n    });\n\n    // Create mock parsed content for excluded paths\n    const privateContent: ParsedContent = {\n      title: 'Private Page',\n      description: 'Private page description',\n      content: 'Private page content',\n      metadata: {\n        originalPath: 'private/secret.md',\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    const adminContent: ParsedContent = {\n      title: 'Admin Page',\n      description: 'Admin page description',\n      content: 'Admin page content',\n      metadata: {\n        originalPath: 'admin.html',\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    const publicContent: ParsedContent = {\n      title: 'Public Page',\n      description: 'Public page description',\n      content: 'Public page content',\n      metadata: {\n        originalPath: 'public/page.md',\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the afterParse hook to all content\n    excludeGenerator.hooks.afterParse(privateContent);\n    excludeGenerator.hooks.afterParse(adminContent);\n    excludeGenerator.hooks.afterParse(publicContent);\n\n    // Verify that only the public page was added\n    expect((excludeGenerator as any).urls).toHaveLength(1);\n    expect((excludeGenerator as any).urls[0].loc).toBe('https://example.com/public/page/');\n  });\n\n  test('should use custom change frequency and priority from metadata', () => {\n    // Create mock parsed content with custom metadata\n    const parsedContent: ParsedContent = {\n      title: 'Important Page',\n      description: 'Important page description',\n      content: 'Important page content',\n      metadata: {\n        originalPath: 'important.md',\n        changefreq: 'daily',\n        priority: 0.9,\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the afterParse hook\n    generator.hooks.afterParse(parsedContent);\n\n    // Verify that the custom values were used\n    expect((generator as any).urls).toHaveLength(1);\n    expect((generator as any).urls[0].changefreq).toBe('daily');\n    expect((generator as any).urls[0].priority).toBe(0.9);\n  });\n\n  test('should generate sitemap.xml after build', async () => {\n    // Create mock parsed content\n    const parsedContent1: ParsedContent = {\n      title: 'Home Page',\n      description: 'Home page description',\n      content: 'Home page content',\n      metadata: {\n        originalPath: 'index.md',\n        lastModified: 1625097600000, // 2021-07-01\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    const parsedContent2: ParsedContent = {\n      title: 'About Page',\n      description: 'About page description',\n      content: 'About page content',\n      metadata: {\n        originalPath: 'about.md',\n        lastModified: 1625184000000, // 2021-07-02\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the afterParse hook to collect URLs\n    generator.hooks.afterParse(parsedContent1);\n    generator.hooks.afterParse(parsedContent2);\n\n    // Mock process.cwd() to return a test directory\n    const originalCwd = process.cwd;\n    process.cwd = jest.fn().mockReturnValue('/test');\n\n    // Apply the afterBuild hook to generate the sitemap\n    await generator.hooks.afterBuild();\n\n    // Verify that the sitemap was generated\n    expect(fs.promises.writeFile).toHaveBeenCalledWith(\n      '/test/sitemap.xml',\n      expect.stringContaining('<?xml version=\"1.0\" encoding=\"UTF-8\"?>'),\n      'utf-8'\n    );\n\n    // Verify the sitemap content\n    const sitemapContent = (fs.promises.writeFile as jest.Mock).mock.calls[0][1];\n    expect(sitemapContent).toContain('<loc>https://example.com/</loc>');\n    expect(sitemapContent).toContain('<lastmod>2021-07-01</lastmod>');\n    expect(sitemapContent).toContain('<loc>https://example.com/about/</loc>');\n    expect(sitemapContent).toContain('<lastmod>2021-07-02</lastmod>');\n    expect(sitemapContent).toContain('<changefreq>weekly</changefreq>');\n    expect(sitemapContent).toContain('<priority>0.5</priority>');\n\n    // Verify that the URLs list was reset\n    expect((generator as any).urls).toHaveLength(0);\n\n    // Restore process.cwd\n    process.cwd = originalCwd;\n  });\n\n  test('should handle different lastModified formats', () => {\n    // Create mock parsed content with different lastModified formats\n    const dateString: ParsedContent = {\n      title: 'Date String',\n      description: 'Date string description',\n      content: 'Date string content',\n      metadata: {\n        originalPath: 'date-string.md',\n        lastModified: '2021-07-01',\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    const dateObject: ParsedContent = {\n      title: 'Date Object',\n      description: 'Date object description',\n      content: 'Date object content',\n      metadata: {\n        originalPath: 'date-object.md',\n        lastModified: new Date('2021-07-02'),\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    const noLastMod: ParsedContent = {\n      title: 'No Last Mod',\n      description: 'No last mod description',\n      content: 'No last mod content',\n      metadata: {\n        originalPath: 'no-last-mod.md',\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Mock Date.now to return a fixed date\n    const originalDateNow = Date.now;\n    Date.now = jest.fn().mockReturnValue(1625270400000); // 2021-07-03\n\n    // Apply the afterParse hook\n    generator.hooks.afterParse(dateString);\n    generator.hooks.afterParse(dateObject);\n    generator.hooks.afterParse(noLastMod);\n\n    // Verify the lastmod values\n    expect((generator as any).urls[0].lastmod).toBe('2021-07-01');\n    expect((generator as any).urls[1].lastmod).toBe('2021-07-02');\n    expect((generator as any).urls[2].lastmod).toBe('2021-07-03');\n\n    // Restore Date.now\n    Date.now = originalDateNow;\n  });\n\n  test('should not include lastmod when disabled', () => {\n    // Create a generator with lastmod disabled\n    const noLastModGenerator = new SiteMapGenerator({\n      baseUrl: 'https://example.com',\n      includeLastMod: false,\n    });\n\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Page',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {\n        originalPath: 'test.md',\n        lastModified: 1625097600000, // 2021-07-01\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the afterParse hook\n    noLastModGenerator.hooks.afterParse(parsedContent);\n\n    // Verify that lastmod is undefined\n    expect((noLastModGenerator as any).urls[0].lastmod).toBeUndefined();\n  });\n\n  test('should escape XML special characters in URLs', async () => {\n    // Create mock parsed content with special characters\n    const parsedContent: ParsedContent = {\n      title: 'Special Characters',\n      description: 'Special characters description',\n      content: 'Special characters content',\n      metadata: {\n        originalPath: 'special&<>\"\\'.md',\n      },\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the afterParse hook\n    generator.hooks.afterParse(parsedContent);\n\n    // Mock process.cwd() to return a test directory\n    const originalCwd = process.cwd;\n    process.cwd = jest.fn().mockReturnValue('/test');\n\n    // Apply the afterBuild hook to generate the sitemap\n    await generator.hooks.afterBuild();\n\n    // Verify that the special characters were escaped\n    const sitemapContent = (fs.promises.writeFile as jest.Mock).mock.calls[0][1];\n    expect(sitemapContent).toContain(\n      '<loc>https://example.com/special&amp;&lt;&gt;&quot;&apos;/</loc>'\n    );\n\n    // Restore process.cwd\n    process.cwd = originalCwd;\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/SyntaxHighlightPlugin.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SyntaxHighlightPlugin } from '../../plugins/SyntaxHighlightPlugin.js';\nimport { ParsedContent, ContentNode } from '../../../types/parser.js';\nimport { logger } from './utils/logger.js';\n\ndescribe('SyntaxHighlightPlugin', () => {\n  let plugin: SyntaxHighlightPlugin;\n\n  beforeEach(() => {\n    plugin = new SyntaxHighlightPlugin();\n  });\n\n  test('should initialize with default options', () => {\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('syntax-highlight');\n  });\n\n  test('should initialize with custom options', () => {\n    const customPlugin = new SyntaxHighlightPlugin({\n      theme: 'dark',\n      lineNumbers: true,\n      languages: ['javascript', 'typescript', 'html'],\n      highlightInline: true,\n      codeBlockClass: 'custom-code-block',\n    });\n\n    expect(customPlugin).toBeDefined();\n    expect(customPlugin.name).toBe('syntax-highlight');\n  });\n\n  test('should add syntax highlighting to code blocks', () => {\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n        },\n        {\n          type: 'codeBlock',\n          content: 'function hello() {\\n  logger.debug(\"Hello, world!\");\\n}',\n          attributes: {\n            language: 'javascript',\n          },\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was added to the code block\n    expect(result.sections[1].attributes).toEqual({\n      language: 'javascript',\n      highlighted: true,\n      theme: 'default',\n      lineNumbers: false,\n      className: 'code-block language-javascript',\n    });\n\n    // Verify that metadata was added\n    expect(result.metadata.syntaxHighlighting).toEqual({\n      enabled: true,\n      theme: 'default',\n      lineNumbers: false,\n    });\n  });\n\n  test('should highlight inline code when enabled', () => {\n    // Create a plugin with highlightInline: true\n    const inlinePlugin = new SyntaxHighlightPlugin({\n      highlightInline: true,\n    });\n\n    // Create mock parsed content with inline code\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: [\n            {\n              type: 'text',\n              content: 'This is some text with ',\n            },\n            {\n              type: 'inlineCode',\n              content: 'const x = 42;',\n            },\n            {\n              type: 'text',\n              content: ' inline code.',\n            },\n          ],\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = inlinePlugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was added to the inline code\n    const inlineCode = (result.sections[0].content as ContentNode[])[1];\n    expect(inlineCode.attributes).toEqual({\n      highlighted: true,\n      theme: 'default',\n      className: 'language-text',\n    });\n  });\n\n  test('should not highlight inline code when disabled', () => {\n    // Create mock parsed content with inline code\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: [\n            {\n              type: 'text',\n              content: 'This is some text with ',\n            },\n            {\n              type: 'inlineCode',\n              content: 'const x = 42;',\n            },\n            {\n              type: 'text',\n              content: ' inline code.',\n            },\n          ],\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was not added to the inline code\n    const inlineCode = (result.sections[0].content as ContentNode[])[1];\n    expect(inlineCode.attributes).toBeUndefined();\n  });\n\n  test('should respect the languages option', () => {\n    // Create a plugin with specific languages\n    const languagePlugin = new SyntaxHighlightPlugin({\n      languages: ['javascript', 'typescript'],\n    });\n\n    // Create mock parsed content with different language code blocks\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'codeBlock',\n          content: 'function hello() {\\n  logger.debug(\"Hello, world!\");\\n}',\n          attributes: {\n            language: 'javascript',\n          },\n        },\n        {\n          type: 'codeBlock',\n          content: 'const x: number = 42;',\n          attributes: {\n            language: 'typescript',\n          },\n        },\n        {\n          type: 'codeBlock',\n          content: '<div>Hello, world!</div>',\n          attributes: {\n            language: 'html',\n          },\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = languagePlugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was added to javascript and typescript blocks\n    expect(result.sections[0].attributes?.highlighted).toBe(true);\n    expect(result.sections[1].attributes?.highlighted).toBe(true);\n\n    // Verify that syntax highlighting was not added to html block\n    expect(result.sections[2].attributes?.highlighted).toBeUndefined();\n  });\n\n  test('should process nested content nodes', () => {\n    // Create mock parsed content with nested nodes\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          children: [\n            {\n              type: 'codeBlock',\n              content: 'function hello() {\\n  logger.debug(\"Hello, world!\");\\n}',\n              attributes: {\n                language: 'javascript',\n              },\n            },\n          ],\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that syntax highlighting was added to the nested code block\n    expect(result.sections[0].children?.[0].attributes).toEqual({\n      language: 'javascript',\n      highlighted: true,\n      theme: 'default',\n      lineNumbers: false,\n      className: 'code-block language-javascript',\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/plugins/TableOfContentsPlugin.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ContentNode' is defined but never used.","line":2,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TableOfContentsPlugin } from '../../plugins/TableOfContentsPlugin.js';\nimport { ParsedContent, ContentNode } from '../../../types/parser.js';\n\ndescribe('TableOfContentsPlugin', () => {\n  let plugin: TableOfContentsPlugin;\n\n  beforeEach(() => {\n    plugin = new TableOfContentsPlugin();\n  });\n\n  test('should initialize with default options', () => {\n    expect(plugin).toBeDefined();\n    expect(plugin.name).toBe('table-of-contents');\n  });\n\n  test('should initialize with custom options', () => {\n    const customPlugin = new TableOfContentsPlugin({\n      title: 'Custom TOC',\n      maxLevel: 2,\n      addAnchors: false,\n      className: 'custom-toc',\n      position: 'bottom',\n    });\n\n    expect(customPlugin).toBeDefined();\n    expect(customPlugin.name).toBe('table-of-contents');\n  });\n\n  test('should add table of contents to content', () => {\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n        {\n          type: 'section',\n          title: 'Getting Started',\n          content: 'This is the getting started section',\n          level: 2,\n        },\n        {\n          type: 'section',\n          title: 'Advanced Topics',\n          content: 'This is the advanced topics section',\n          level: 2,\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that the table of contents was added\n    expect(result.sections).toHaveLength(5);\n    expect(result.sections[0].type).toBe('toc');\n    expect(result.sections[0].title).toBe('Table of Contents');\n\n    // Verify the table of contents content\n    const tocContent = result.sections[0].content as string;\n    expect(tocContent).toContain('- [Introduction](#introduction)');\n    expect(tocContent).toContain('  - [Getting Started](#getting-started)');\n    expect(tocContent).toContain('  - [Advanced Topics](#advanced-topics)');\n    expect(tocContent).toContain('- [Conclusion](#conclusion)');\n  });\n\n  test('should add table of contents at the bottom', () => {\n    // Create a plugin with position: 'bottom'\n    const bottomPlugin = new TableOfContentsPlugin({\n      position: 'bottom',\n    });\n\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = bottomPlugin.hooks.afterParse(parsedContent);\n\n    // Verify that the table of contents was added at the bottom\n    expect(result.sections).toHaveLength(3);\n    expect(result.sections[2].type).toBe('toc');\n    expect(result.sections[2].title).toBe('Table of Contents');\n  });\n\n  test('should respect maxLevel option', () => {\n    // Create a plugin with maxLevel: 1\n    const maxLevelPlugin = new TableOfContentsPlugin({\n      maxLevel: 1,\n    });\n\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n        {\n          type: 'section',\n          title: 'Getting Started',\n          content: 'This is the getting started section',\n          level: 2,\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = maxLevelPlugin.hooks.afterParse(parsedContent);\n\n    // Verify the table of contents content\n    const tocContent = result.sections[0].content as string;\n    expect(tocContent).toContain('- [Introduction](#introduction)');\n    expect(tocContent).not.toContain('  - [Getting Started](#getting-started)');\n    expect(tocContent).toContain('- [Conclusion](#conclusion)');\n  });\n\n  test('should add anchors to headings', () => {\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n        {\n          type: 'section',\n          title: 'Getting Started',\n          content: 'This is the getting started section',\n          level: 2,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that anchors were added to headings\n    expect(result.sections[1].attributes).toBeDefined();\n    expect(result.sections[1].attributes?.id).toBe('introduction');\n    expect(result.sections[1].attributes?.className).toContain('anchor');\n\n    expect(result.sections[2].attributes).toBeDefined();\n    expect(result.sections[2].attributes?.id).toBe('getting-started');\n    expect(result.sections[2].attributes?.className).toContain('anchor');\n  });\n\n  test('should not add anchors when addAnchors is false', () => {\n    // Create a plugin with addAnchors: false\n    const noAnchorsPlugin = new TableOfContentsPlugin({\n      addAnchors: false,\n    });\n\n    // Create mock parsed content\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = noAnchorsPlugin.hooks.afterParse(parsedContent);\n\n    // Verify that anchors were not added to headings\n    expect(result.sections[1].attributes?.id).toBeUndefined();\n    expect(result.sections[1].attributes?.className).toBeUndefined();\n  });\n\n  test('should handle empty sections', () => {\n    // Create mock parsed content with no sections\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify that the result is the same as the input\n    expect(result).toBe(parsedContent);\n    expect(result.sections).toHaveLength(0);\n  });\n\n  test('should handle nested sections', () => {\n    // Create mock parsed content with nested sections\n    const parsedContent: ParsedContent = {\n      title: 'Test Document',\n      description: 'Test description',\n      content: 'Test content',\n      metadata: {},\n      sections: [\n        {\n          type: 'section',\n          title: 'Introduction',\n          content: 'This is the introduction',\n          level: 1,\n          children: [\n            {\n              type: 'section',\n              title: 'Background',\n              content: 'This is the background',\n              level: 2,\n            },\n          ],\n        },\n        {\n          type: 'section',\n          title: 'Conclusion',\n          content: 'This is the conclusion',\n          level: 1,\n        },\n      ],\n      assets: [],\n      references: [],\n    };\n\n    // Apply the plugin\n    const result = plugin.hooks.afterParse(parsedContent);\n\n    // Verify the table of contents content\n    const tocContent = result.sections[0].content as string;\n    expect(tocContent).toContain('- [Introduction](#introduction)');\n    expect(tocContent).toContain('  - [Background](#background)');\n    expect(tocContent).toContain('- [Conclusion](#conclusion)');\n\n    // Verify that anchors were added to nested headings\n    expect(result.sections[1].attributes?.id).toBe('introduction');\n    expect(result.sections[1].children?.[0].attributes?.id).toBe('background');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/services/ParserService.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[274,277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[274,277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1191,1194],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1191,1194],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1273,1276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1273,1276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ParserService } from '../../services/ParserService.js';\nimport { createMockFileSystem } from '../utils/test-helpers.js';\nimport { Plugin } from '../../../types/plugin.js';\n\ndescribe('ParserService', () => {\n  let parserService: ParserService;\n  let mockFileSystem: any;\n\n  beforeEach(() => {\n    mockFileSystem = createMockFileSystem();\n\n    // Add mock files\n    mockFileSystem.addMockFile(\n      '/test/source/document.md',\n      '# Test Document\\n\\nThis is a test document.'\n    );\n    mockFileSystem.addMockFile(\n      '/test/source/another.md',\n      '# Another Document\\n\\nThis is another document.'\n    );\n    mockFileSystem.addMockFile('/test/source/file.txt', 'This is not a markdown file.');\n\n    parserService = new ParserService({\n      fileSystem: mockFileSystem,\n      extensions: ['md', 'markdown'],\n      ignorePatterns: ['node_modules', '.git'],\n    });\n  });\n\n  test('should initialize with default configuration', () => {\n    const defaultParserService = new ParserService();\n    expect(defaultParserService).toBeDefined();\n  });\n\n  test('should initialize with custom configuration', () => {\n    expect(parserService).toBeDefined();\n    expect((parserService as any).config.extensions).toEqual(['md', 'markdown']);\n    expect((parserService as any).config.ignorePatterns).toEqual(['node_modules', '.git']);\n  });\n\n  test('should parse markdown file', async () => {\n    // Mock the readFile method\n    mockFileSystem.readFile.mockResolvedValue('# Test Document\\n\\nThis is a test document.');\n\n    // Call the parse method\n    const result = await parserService.parse('/test/source/document.md');\n\n    // Verify the result\n    expect(result).toEqual({\n      title: 'Test Document',\n      description: 'This is a test document.',\n      content: '# Test Document\\n\\nThis is a test document.',\n      sections: expect.any(Array),\n      metadata: expect.any(Object),\n      assets: expect.any(Array),\n      references: expect.any(Array),\n    });\n  });\n\n  test('should handle unsupported file format', async () => {\n    // Call the parse method with an unsupported file format\n    await expect(parserService.parse('/test/source/file.txt')).rejects.toThrow();\n  });\n\n  test('should apply plugins during parsing', async () => {\n    // Mock the readFile method\n    mockFileSystem.readFile.mockResolvedValue('# Test Document\\n\\nThis is a test document.');\n\n    // Create a mock plugin\n    const mockPlugin: Plugin = {\n      name: 'MockPlugin',\n      hooks: {\n        beforeParse: jest.fn().mockImplementation(content => `Modified: ${content}`),\n        afterParse: jest.fn().mockImplementation(parsed => ({\n          ...parsed,\n          title: `Enhanced: ${parsed.title}`,\n        })),\n      },\n    };\n\n    // Add the plugin to the parser service\n    parserService.addPlugin(mockPlugin);\n\n    // Call the parse method\n    const result = await parserService.parse('/test/source/document.md');\n\n    // Verify that the plugin hooks were called\n    expect(mockPlugin.hooks.beforeParse).toHaveBeenCalled();\n    expect(mockPlugin.hooks.afterParse).toHaveBeenCalled();\n\n    // Verify the result\n    expect(result.title).toBe('Enhanced: Test Document');\n  });\n\n  test('should parse multiple files', async () => {\n    // Mock the readFile method\n    mockFileSystem.readFile.mockImplementation((filePath: string) => {\n      if (filePath === '/test/source/document.md') {\n        return Promise.resolve('# Test Document\\n\\nThis is a test document.');\n      }\n      if (filePath === '/test/source/another.md') {\n        return Promise.resolve('# Another Document\\n\\nThis is another document.');\n      }\n      return Promise.reject(new Error(`File not found: ${filePath}`));\n    });\n\n    // Call the parseFiles method\n    const results = await parserService.parseFiles([\n      '/test/source/document.md',\n      '/test/source/another.md',\n    ]);\n\n    // Verify the results\n    expect(results).toHaveLength(2);\n    expect(results[0].title).toBe('Test Document');\n    expect(results[1].title).toBe('Another Document');\n  });\n\n  test('should handle errors during parsing', async () => {\n    // Mock the readFile method to throw an error\n    mockFileSystem.readFile.mockRejectedValue(new Error('Read error'));\n\n    // Call the parse method and expect it to throw\n    await expect(parserService.parse('/test/source/document.md')).rejects.toThrow('Read error');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/simple-test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/simple/basic.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/templates/HandlebarsTemplateEngine.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1171,1174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1171,1174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { HandlebarsTemplateEngine } from '../../templates/HandlebarsTemplateEngine.js';\nimport { createMockParsedContent } from '../utils/test-helpers.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as Handlebars from 'handlebars';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\njest.mock('handlebars');\n\ndescribe('HandlebarsTemplateEngine', () => {\n  let engine: HandlebarsTemplateEngine;\n  let mockHandlebars: jest.Mocked<typeof Handlebars>;\n  let mockTemplate: jest.Mock;\n  let mockCompile: jest.Mock;\n\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks();\n\n    // Mock Handlebars\n    mockTemplate = jest.fn().mockReturnValue('<div>Rendered Template</div>');\n    mockCompile = jest.fn().mockReturnValue(mockTemplate);\n    mockHandlebars = {\n      create: jest.fn().mockReturnValue({\n        compile: mockCompile,\n        registerHelper: jest.fn(),\n        registerPartial: jest.fn(),\n      }),\n    } as unknown as jest.Mocked<typeof Handlebars>;\n\n    // Replace the real Handlebars with the mock\n    (Handlebars as unknown) = mockHandlebars;\n\n    // Mock fs.promises.readFile to return template content\n    (fs.promises as any) = {\n      readFile: jest.fn().mockResolvedValue('Template content: {{title}}'),\n      readdir: jest.fn().mockResolvedValue(['partial.hbs', 'helper.js']),\n    };\n\n    // Mock fs.existsSync to return true for directories\n    (fs.existsSync as jest.Mock).mockReturnValue(true);\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => paths.join('/'));\n\n    // Mock path.basename to return the file name without extension\n    (path.basename as jest.Mock).mockImplementation((filePath: string, ext: string) => {\n      const parts = filePath.split('/');\n      const fileName = parts[parts.length - 1];\n      return ext ? fileName.replace(ext, '') : fileName;\n    });\n\n    // Mock path.extname to return the file extension\n    (path.extname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('.');\n      return parts.length > 1 ? `.${parts[parts.length - 1]}` : '';\n    });\n\n    // Create the engine\n    engine = new HandlebarsTemplateEngine({\n      partialsDir: '/test/partials',\n      helpersDir: '/test/helpers',\n      strict: true,\n      minify: true,\n    });\n  });\n\n  test('should initialize with default options', () => {\n    const defaultEngine = new HandlebarsTemplateEngine();\n    expect(defaultEngine).toBeDefined();\n    expect(Handlebars.create).toHaveBeenCalled();\n  });\n\n  test('should initialize with custom options', () => {\n    expect(engine).toBeDefined();\n    expect(Handlebars.create).toHaveBeenCalled();\n    expect(fs.existsSync).toHaveBeenCalledWith('/test/partials');\n    expect(fs.existsSync).toHaveBeenCalledWith('/test/helpers');\n  });\n\n  test('should render a template', async () => {\n    // Render a template\n    const result = await engine.render('/test/template.hbs', { title: 'Test' });\n\n    // Verify the result\n    expect(result).toBe('<div>Rendered Template</div>');\n    expect(fs.promises.readFile).toHaveBeenCalledWith('/test/template.hbs', 'utf-8');\n    expect(mockCompile).toHaveBeenCalledWith('Template content: {{title}}', { strict: true });\n    expect(mockTemplate).toHaveBeenCalledWith({ title: 'Test' });\n  });\n\n  test('should render content', async () => {\n    // Create mock parsed content\n    const mockContent = createMockParsedContent({\n      title: 'Test Document',\n      description: 'Test description',\n    });\n\n    // Render content\n    const result = await engine.renderContent(mockContent, '/test/template.hbs');\n\n    // Verify the result\n    expect(result).toBe('<div>Rendered Template</div>');\n    expect(fs.promises.readFile).toHaveBeenCalledWith('/test/template.hbs', 'utf-8');\n    expect(mockCompile).toHaveBeenCalledWith('Template content: {{title}}', { strict: true });\n    expect(mockTemplate).toHaveBeenCalledWith({\n      content: mockContent,\n      designSystem: undefined,\n      meta: {},\n      title: 'Test Document',\n      description: 'Test description',\n      sections: [],\n      assets: [],\n      references: [],\n    });\n  });\n\n  test('should cache templates', async () => {\n    // Render the same template twice\n    await engine.render('/test/template.hbs', { title: 'Test 1' });\n    await engine.render('/test/template.hbs', { title: 'Test 2' });\n\n    // Verify that the template was only loaded once\n    expect(fs.promises.readFile).toHaveBeenCalledTimes(1);\n    expect(mockCompile).toHaveBeenCalledTimes(1);\n    expect(mockTemplate).toHaveBeenCalledTimes(2);\n  });\n\n  test('should clear the template cache', async () => {\n    // Render a template\n    await engine.render('/test/template.hbs', { title: 'Test' });\n\n    // Clear the cache\n    engine.clearCache();\n\n    // Render the same template again\n    await engine.render('/test/template.hbs', { title: 'Test' });\n\n    // Verify that the template was loaded twice\n    expect(fs.promises.readFile).toHaveBeenCalledTimes(2);\n    expect(mockCompile).toHaveBeenCalledTimes(2);\n  });\n\n  test('should handle errors when loading templates', async () => {\n    // Mock fs.promises.readFile to throw an error\n    (fs.promises.readFile as jest.Mock).mockRejectedValue(new Error('File not found'));\n\n    // Render a template and expect it to throw\n    await expect(engine.render('/test/template.hbs', { title: 'Test' })).rejects.toThrow();\n  });\n\n  test('should minify HTML output when enabled', async () => {\n    // Mock the template function to return HTML with whitespace\n    mockTemplate.mockReturnValue('<div>\\n  <h1>Test</h1>\\n  <p>Content</p>\\n</div>');\n\n    // Render a template\n    const result = await engine.render('/test/template.hbs', { title: 'Test' });\n\n    // Verify that the output was minified\n    expect(result).toBe('<div><h1>Test</h1><p>Content</p></div>');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/templates/TemplateManager.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fs' is defined but never used.","line":6,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TemplateManager } from '../../templates/TemplateManager.js';\nimport { TemplateEngine } from '../../templates/TemplateEngine.js';\nimport { HandlebarsTemplateEngine } from '../../templates/HandlebarsTemplateEngine.js';\nimport { EjsTemplateEngine } from '../../templates/EjsTemplateEngine.js';\nimport { createMockParsedContent } from '../utils/test-helpers.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\njest.mock('../../templates/HandlebarsTemplateEngine');\njest.mock('../../templates/EjsTemplateEngine');\n\ndescribe('TemplateManager', () => {\n  let templateManager: TemplateManager;\n  let mockHandlebarsEngine: jest.Mocked<HandlebarsTemplateEngine>;\n  let mockEjsEngine: jest.Mocked<EjsTemplateEngine>;\n\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks();\n\n    // Create mock template engines\n    mockHandlebarsEngine = new HandlebarsTemplateEngine() as jest.Mocked<HandlebarsTemplateEngine>;\n    mockEjsEngine = new EjsTemplateEngine() as jest.Mocked<EjsTemplateEngine>;\n\n    // Mock the constructors\n    (HandlebarsTemplateEngine as jest.Mock).mockImplementation(() => mockHandlebarsEngine);\n    (EjsTemplateEngine as jest.Mock).mockImplementation(() => mockEjsEngine);\n\n    // Create the template manager\n    templateManager = new TemplateManager({\n      defaultEngine: 'handlebars',\n      handlebarsOptions: {\n        partialsDir: '/test/partials',\n      },\n      ejsOptions: {\n        includesDir: '/test/includes',\n      },\n    });\n  });\n\n  test('should initialize with default engines', () => {\n    expect(templateManager).toBeDefined();\n    expect(HandlebarsTemplateEngine).toHaveBeenCalled();\n    expect(EjsTemplateEngine).toHaveBeenCalled();\n  });\n\n  test('should register a custom template engine', () => {\n    // Create a mock custom engine\n    const mockCustomEngine = {\n      render: jest.fn().mockResolvedValue('<div>Custom Template</div>'),\n      renderContent: jest.fn().mockResolvedValue('<div>Custom Content</div>'),\n      clearCache: jest.fn(),\n    } as unknown as TemplateEngine;\n\n    // Register the custom engine\n    templateManager.registerEngine('custom', mockCustomEngine);\n\n    // Get the custom engine\n    const engine = templateManager.getEngine('custom');\n    expect(engine).toBe(mockCustomEngine);\n  });\n\n  test('should get the default engine when no name is provided', () => {\n    const engine = templateManager.getEngine();\n    expect(engine).toBe(mockHandlebarsEngine);\n  });\n\n  test('should throw an error when getting a non-existent engine', () => {\n    expect(() => templateManager.getEngine('non-existent')).toThrow();\n  });\n\n  test('should infer engine from file extension', async () => {\n    // Mock path.extname to return the file extension\n    (path.extname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('.');\n      return parts.length > 1 ? `.${parts[parts.length - 1]}` : '';\n    });\n\n    // Mock the render methods\n    mockHandlebarsEngine.render.mockResolvedValue('<div>Handlebars Template</div>');\n    mockEjsEngine.render.mockResolvedValue('<div>EJS Template</div>');\n\n    // Render templates with different extensions\n    await templateManager.render('template.hbs', { title: 'Test' });\n    await templateManager.render('template.ejs', { title: 'Test' });\n    await templateManager.render('template.txt', { title: 'Test' });\n\n    // Verify that the correct engines were used\n    expect(mockHandlebarsEngine.render).toHaveBeenCalledTimes(2); // .hbs and .txt (default)\n    expect(mockEjsEngine.render).toHaveBeenCalledTimes(1); // .ejs\n  });\n\n  test('should render content with the specified engine', async () => {\n    // Create mock parsed content\n    const mockContent = createMockParsedContent({\n      title: 'Test Document',\n      description: 'Test description',\n    });\n\n    // Mock the renderContent method\n    mockHandlebarsEngine.renderContent.mockResolvedValue('<div>Rendered Content</div>');\n\n    // Render content with the handlebars engine\n    const result = await templateManager.renderContent(\n      mockContent,\n      'template.hbs',\n      undefined,\n      'handlebars'\n    );\n\n    // Verify the result\n    expect(result).toBe('<div>Rendered Content</div>');\n    expect(mockHandlebarsEngine.renderContent).toHaveBeenCalledWith(\n      mockContent,\n      'template.hbs',\n      undefined\n    );\n  });\n\n  test('should clear cache for all engines', () => {\n    // Clear the cache\n    templateManager.clearCache();\n\n    // Verify that clearCache was called on all engines\n    expect(mockHandlebarsEngine.clearCache).toHaveBeenCalled();\n    expect(mockEjsEngine.clearCache).toHaveBeenCalled();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/templates/helpers/component-helper.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/tools/plugin-docs-generator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-function","severity":2,"message":"Unexpected empty arrow function.","line":23,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"unexpected","endLine":23,"endColumn":60},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[728,731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[728,731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2037,2040],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2037,2040],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2093,2096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2093,2096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2154,2157],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2154,2157],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PluginDocsGenerator } from '../../tools/plugin-docs-generator.js';\nimport { Plugin } from '../../../types/plugin.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('PluginDocsGenerator', () => {\n  let generator: PluginDocsGenerator;\n  let mockPlugin1: Plugin;\n  let mockPlugin2: Plugin;\n\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks();\n\n    // Mock fs.existsSync to return false for directories\n    (fs.existsSync as jest.Mock).mockReturnValue(false);\n\n    // Mock fs.mkdirSync to do nothing\n    (fs.mkdirSync as jest.Mock).mockImplementation(() => {});\n\n    // Mock fs.promises.writeFile to do nothing\n    (fs.promises as any) = {\n      writeFile: jest.fn().mockResolvedValue(undefined),\n    };\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => paths.join('/'));\n\n    // Create mock plugins\n    mockPlugin1 = {\n      name: 'test-plugin-1',\n      description: 'A test plugin',\n      hooks: {\n        beforeParse: jest.fn(),\n        afterParse: jest.fn(),\n      },\n      options: {\n        option1: {\n          type: 'string',\n          description: 'Option 1 description',\n          required: true,\n        },\n        option2: {\n          type: 'boolean',\n          description: 'Option 2 description',\n          required: false,\n          default: false,\n        },\n      },\n    };\n\n    mockPlugin2 = {\n      name: 'test-plugin-2',\n      description: 'Another test plugin',\n      hooks: {\n        beforeBuild: jest.fn(),\n        afterBuild: jest.fn(),\n      },\n    };\n\n    // Create the generator\n    generator = new PluginDocsGenerator('/test/docs');\n  });\n\n  test('should initialize with the output directory', () => {\n    expect(generator).toBeDefined();\n  });\n\n  test('should add plugins', () => {\n    // Add plugins\n    generator.addPlugin(mockPlugin1);\n    generator.addPlugin(mockPlugin2);\n\n    // Verify that the plugins were added\n    expect((generator as any).plugins).toHaveLength(2);\n    expect((generator as any).plugins[0]).toBe(mockPlugin1);\n    expect((generator as any).plugins[1]).toBe(mockPlugin2);\n  });\n\n  test('should generate documentation', async () => {\n    // Add plugins\n    generator.addPlugin(mockPlugin1);\n    generator.addPlugin(mockPlugin2);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Verify that the output directory was created\n    expect(fs.existsSync).toHaveBeenCalledWith('/test/docs');\n    expect(fs.mkdirSync).toHaveBeenCalledWith('/test/docs', { recursive: true });\n\n    // Verify that the index file was generated\n    expect(fs.promises.writeFile).toHaveBeenCalledWith(\n      '/test/docs/README.md',\n      expect.stringContaining('# Plugin Documentation'),\n      undefined\n    );\n\n    // Verify that the plugin documentation files were generated\n    expect(fs.promises.writeFile).toHaveBeenCalledWith(\n      '/test/docs/test-plugin-1.md',\n      expect.stringContaining('# test-plugin-1 Plugin'),\n      undefined\n    );\n    expect(fs.promises.writeFile).toHaveBeenCalledWith(\n      '/test/docs/test-plugin-2.md',\n      expect.stringContaining('# test-plugin-2 Plugin'),\n      undefined\n    );\n  });\n\n  test('should generate index file with plugin links', async () => {\n    // Add plugins\n    generator.addPlugin(mockPlugin1);\n    generator.addPlugin(mockPlugin2);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the index file content\n    const indexFileCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/README.md'\n    );\n    const indexContent = indexFileCall ? indexFileCall[1] : '';\n\n    // Verify the index content\n    expect(indexContent).toContain('# Plugin Documentation');\n    expect(indexContent).toContain('## Available Plugins');\n    expect(indexContent).toContain('- [test-plugin-1](test-plugin-1.md): A test plugin');\n    expect(indexContent).toContain('- [test-plugin-2](test-plugin-2.md): Another test plugin');\n  });\n\n  test('should generate plugin documentation with hooks', async () => {\n    // Add a plugin\n    generator.addPlugin(mockPlugin1);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/test-plugin-1.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('# test-plugin-1 Plugin');\n    expect(pluginDocContent).toContain('A test plugin');\n    expect(pluginDocContent).toContain('## Hooks');\n    expect(pluginDocContent).toContain('- `beforeParse`: Called before parsing content');\n    expect(pluginDocContent).toContain('- `afterParse`: Called after parsing content');\n  });\n\n  test('should generate plugin documentation with options', async () => {\n    // Add a plugin\n    generator.addPlugin(mockPlugin1);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/test-plugin-1.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Options');\n    expect(pluginDocContent).toContain('| Option | Type | Description | Required | Default |');\n    expect(pluginDocContent).toContain('| `option1` | `string` | Option 1 description | Yes | - |');\n    expect(pluginDocContent).toContain(\n      '| `option2` | `boolean` | Option 2 description | No | false |'\n    );\n  });\n\n  test('should handle plugins without hooks', async () => {\n    // Create a plugin without hooks\n    const pluginWithoutHooks: Plugin = {\n      name: 'plugin-without-hooks',\n      description: 'A plugin without hooks',\n    };\n\n    // Add the plugin\n    generator.addPlugin(pluginWithoutHooks);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/plugin-without-hooks.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Hooks');\n    expect(pluginDocContent).toContain('This plugin does not implement any hooks.');\n  });\n\n  test('should handle plugins without options', async () => {\n    // Create a plugin without options\n    const pluginWithoutOptions: Plugin = {\n      name: 'plugin-without-options',\n      description: 'A plugin without options',\n      hooks: {\n        beforeParse: jest.fn(),\n      },\n    };\n\n    // Add the plugin\n    generator.addPlugin(pluginWithoutOptions);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/plugin-without-options.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Options');\n    expect(pluginDocContent).toContain('This plugin does not have any options.');\n  });\n\n  test('should handle plugins without description', async () => {\n    // Create a plugin without description\n    const pluginWithoutDescription: Plugin = {\n      name: 'plugin-without-description',\n      hooks: {\n        beforeParse: jest.fn(),\n      },\n    };\n\n    // Add the plugin\n    generator.addPlugin(pluginWithoutDescription);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/plugin-without-description.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('# plugin-without-description Plugin');\n    expect(pluginDocContent).toContain('No description available.');\n  });\n\n  test('should handle plugins with examples', async () => {\n    // Create a plugin with examples\n    const pluginWithExamples: Plugin = {\n      name: 'plugin-with-examples',\n      description: 'A plugin with examples',\n      hooks: {\n        beforeParse: jest.fn(),\n      },\n      examples: [\n        'const plugin = new ExamplePlugin();\\ngenerator.addPlugin(plugin);',\n        'const plugin = new ExamplePlugin({ option: \"value\" });\\ngenerator.addPlugin(plugin);',\n      ],\n    };\n\n    // Add the plugin\n    generator.addPlugin(pluginWithExamples);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/plugin-with-examples.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Examples');\n    expect(pluginDocContent).toContain('```javascript');\n    expect(pluginDocContent).toContain('const plugin = new ExamplePlugin();');\n    expect(pluginDocContent).toContain('const plugin = new ExamplePlugin({ option: \"value\" });');\n  });\n\n  test('should handle plugins without examples', async () => {\n    // Add a plugin without examples\n    generator.addPlugin(mockPlugin1);\n\n    // Generate documentation\n    await generator.generateDocs();\n\n    // Get the plugin documentation content\n    const pluginDocCall = (fs.promises.writeFile as jest.Mock).mock.calls.find(\n      call => call[0] === '/test/docs/test-plugin-1.md'\n    );\n    const pluginDocContent = pluginDocCall ? pluginDocCall[1] : '';\n\n    // Verify the plugin documentation content\n    expect(pluginDocContent).toContain('## Examples');\n    expect(pluginDocContent).toContain('No examples available.');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/cache-simple.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/cache.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dirPath' is defined but never used.","line":40,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":68},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":40,"column":70,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":78},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filePath' is defined but never used.","line":45,"column":57,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":73},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_content' is defined but never used.","line":45,"column":75,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":91},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filePath' is defined but never used.","line":68,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":68,"endColumn":70},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2428,2431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2428,2431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2589,2592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2589,2592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cache' is assigned a value but never used.","line":103,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":103,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3012,3015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3012,3015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3227,3230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3227,3230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3482,3485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3482,3485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4054,4057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4054,4057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4267,4270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4267,4270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4543,4546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4543,4546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4965,4968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4965,4968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5256,5259],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5256,5259],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5635,5638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5635,5638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5953,5956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5953,5956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":207,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6243,6246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6243,6246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6586,6589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6586,6589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7002,7005],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7002,7005],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7501,7504],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7501,7504],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":266,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7969,7972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7969,7972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ContentCache, CacheOptions } from '../../utils/cache.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('ContentCache', () => {\n  // Sample cache options\n  const memoryCacheOptions: CacheOptions = {\n    enabled: true,\n    storageType: 'memory',\n    maxSize: 10,\n    ttl: 3600000, // 1 hour\n  };\n\n  const filesystemCacheOptions: CacheOptions = {\n    enabled: true,\n    storageType: 'filesystem',\n    cacheDir: '/test/cache',\n    ttl: 3600000, // 1 hour\n  };\n\n  // Sample cache data\n  const sampleData = {\n    title: 'Test Document',\n    content: 'Test content',\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for cache directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath === '/test/cache';\n    });\n\n    // Mock fs.mkdirSync\n    (fs.mkdirSync as jest.Mock).mockImplementation((dirPath: string, _options) => {\n      return undefined;\n    });\n\n    // Mock fs.writeFileSync\n    (fs.writeFileSync as jest.Mock).mockImplementation((filePath: string, _content: string) => {\n      return undefined;\n    });\n\n    // Mock fs.readFileSync\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.includes('valid-key')) {\n        return JSON.stringify({\n          data: sampleData,\n          timestamp: Date.now() - 1000, // 1 second ago\n          key: 'valid-key',\n        });\n      } else if (filePath.includes('expired-key')) {\n        return JSON.stringify({\n          data: sampleData,\n          timestamp: Date.now() - 7200000, // 2 hours ago (expired)\n          key: 'expired-key',\n        });\n      }\n      throw new Error(`File not found: ${filePath}`);\n    });\n\n    // Mock fs.unlinkSync\n    (fs.unlinkSync as jest.Mock).mockImplementation((filePath: string) => {\n      return undefined;\n    });\n\n    // Mock fs.readdirSync\n    (fs.readdirSync as jest.Mock).mockImplementation((dirPath: string) => {\n      if (dirPath === '/test/cache') {\n        return ['valid-key.json', 'expired-key.json'];\n      }\n      return [];\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => {\n      return paths.join('/').replace(/\\/+/g, '/');\n    });\n  });\n\n  test('should initialize with memory storage', () => {\n    const cache = new ContentCache<any>(memoryCacheOptions);\n    expect(cache).toBeDefined();\n  });\n\n  test('should initialize with filesystem storage', () => {\n    const cache = new ContentCache<any>(filesystemCacheOptions);\n    expect(cache).toBeDefined();\n    expect(fs.existsSync).toHaveBeenCalledWith('/test/cache');\n  });\n\n  test('should create cache directory if it does not exist', () => {\n    // Mock fs.existsSync to return false for cache directory\n    (fs.existsSync as jest.Mock).mockImplementation((dirPath: string) => {\n      return dirPath !== '/test/cache';\n    });\n\n    const cache = new ContentCache<any>(filesystemCacheOptions);\n    expect(fs.mkdirSync).toHaveBeenCalledWith('/test/cache', { recursive: true });\n  });\n\n  test('should set and get item from memory cache', () => {\n    const cache = new ContentCache<any>(memoryCacheOptions);\n\n    cache.set('test-key', sampleData);\n    const result = cache.get('test-key');\n\n    expect(result).toEqual(sampleData);\n  });\n\n  test('should set and get item from filesystem cache', () => {\n    const cache = new ContentCache<any>(filesystemCacheOptions);\n\n    cache.set('test-key', sampleData);\n\n    // Mock fs.existsSync to return true for cache file\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath === '/test/cache/098f6bcd4621d373cade4e832627b4f6.json';\n    });\n\n    const result = cache.get('test-key');\n\n    expect(result).toEqual(sampleData);\n    expect(fs.writeFileSync).toHaveBeenCalled();\n    expect(fs.readFileSync).toHaveBeenCalled();\n  });\n\n  test('should return null for non-existent item', () => {\n    const cache = new ContentCache<any>(memoryCacheOptions);\n\n    const result = cache.get('non-existent-key');\n\n    expect(result).toBeNull();\n  });\n\n  test('should check if item exists in memory cache', () => {\n    const cache = new ContentCache<any>(memoryCacheOptions);\n\n    cache.set('test-key', sampleData);\n\n    expect(cache.has('test-key')).toBe(true);\n    expect(cache.has('non-existent-key')).toBe(false);\n  });\n\n  test('should check if item exists in filesystem cache', () => {\n    const cache = new ContentCache<any>(filesystemCacheOptions);\n\n    // Mock fs.existsSync to return true for valid cache file\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath.includes('valid-key');\n    });\n\n    expect(cache.has('valid-key')).toBe(true);\n    expect(cache.has('non-existent-key')).toBe(false);\n  });\n\n  test('should delete item from memory cache', () => {\n    const cache = new ContentCache<any>(memoryCacheOptions);\n\n    cache.set('test-key', sampleData);\n    expect(cache.has('test-key')).toBe(true);\n\n    cache.delete('test-key');\n    expect(cache.has('test-key')).toBe(false);\n  });\n\n  test('should delete item from filesystem cache', () => {\n    const cache = new ContentCache<any>(filesystemCacheOptions);\n\n    // Mock fs.existsSync to return true for cache file\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath.includes('test-key');\n    });\n\n    cache.delete('test-key');\n\n    expect(fs.unlinkSync).toHaveBeenCalled();\n  });\n\n  test('should clear memory cache', () => {\n    const cache = new ContentCache<any>(memoryCacheOptions);\n\n    cache.set('test-key-1', sampleData);\n    cache.set('test-key-2', sampleData);\n\n    cache.clear();\n\n    expect(cache.has('test-key-1')).toBe(false);\n    expect(cache.has('test-key-2')).toBe(false);\n  });\n\n  test('should clear filesystem cache', () => {\n    const cache = new ContentCache<any>(filesystemCacheOptions);\n\n    cache.clear();\n\n    expect(fs.readdirSync).toHaveBeenCalledWith('/test/cache');\n    expect(fs.unlinkSync).toHaveBeenCalledTimes(2); // Two cache files\n  });\n\n  test('should handle expired items in memory cache', () => {\n    const cache = new ContentCache<any>({\n      ...memoryCacheOptions,\n      ttl: 1000, // 1 second\n    });\n\n    cache.set('test-key', sampleData);\n\n    // Fast-forward time by 2 seconds\n    jest.advanceTimersByTime(2000);\n\n    expect(cache.get('test-key')).toBeNull();\n  });\n\n  test('should handle expired items in filesystem cache', () => {\n    const cache = new ContentCache<any>(filesystemCacheOptions);\n\n    // Mock fs.existsSync to return true for expired cache file\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return filePath.includes('expired-key');\n    });\n\n    expect(cache.get('expired-key')).toBeNull();\n    expect(fs.unlinkSync).toHaveBeenCalled();\n  });\n\n  test('should enforce maximum cache size', () => {\n    const cache = new ContentCache<any>({\n      ...memoryCacheOptions,\n      maxSize: 2, // Only allow 2 items\n    });\n\n    // Add 3 items\n    cache.set('test-key-1', { id: 1 });\n    cache.set('test-key-2', { id: 2 });\n    cache.set('test-key-3', { id: 3 });\n\n    // The oldest item should be removed\n    expect(cache.has('test-key-1')).toBe(false);\n    expect(cache.has('test-key-2')).toBe(true);\n    expect(cache.has('test-key-3')).toBe(true);\n  });\n\n  test('should get cache statistics', () => {\n    const cache = new ContentCache<any>(memoryCacheOptions);\n\n    cache.set('test-key-1', { id: 1 });\n    cache.set('test-key-2', { id: 2 });\n\n    const stats = cache.getStats();\n\n    expect(stats).toBeDefined();\n    expect(stats.enabled).toBe(true);\n    expect(stats.storageType).toBe('memory');\n    expect(stats.size).toBe(2);\n    expect(stats.maxSize).toBe(10);\n    expect(stats.ttl).toBe(3600000);\n  });\n\n  test('should do nothing when cache is disabled', () => {\n    const cache = new ContentCache<any>({\n      ...memoryCacheOptions,\n      enabled: false,\n    });\n\n    cache.set('test-key', sampleData);\n\n    expect(cache.get('test-key')).toBeNull();\n    expect(cache.has('test-key')).toBe(false);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/config-validator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":100,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":100,"endColumn":66},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":105,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":66},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_mode' is defined but never used.","line":105,"column":68,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":81},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_mode' is defined but never used.","line":165,"column":68,"nodeType":"Identifier","messageId":"unusedVar","endLine":165,"endColumn":81},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4997,5000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4997,5000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":230,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6028,6031],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6028,6031],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6886,6889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6886,6889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":327,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8793,8796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8793,8796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":363,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":363,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9818,9821],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9818,9821],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":394,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10641,10644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10641,10644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":442,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":442,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11963,11966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11963,11966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":477,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":477,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13122,13125],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13122,13125],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { validateConfig } from '../../utils/config-validator.js';\nimport { WebsiteGeneratorConfig } from '../../../config/generator.config.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('path');\n\ndescribe('Config Validator', () => {\n  // Valid test configuration\n  const validConfig: WebsiteGeneratorConfig = {\n    projectName: 'test-project',\n    sourceDir: '/test/source',\n    outputDir: '/test/output',\n\n    parser: {\n      extensions: ['md'],\n      ignorePatterns: ['node_modules'],\n      plugins: [],\n    },\n\n    generator: {\n      templates: {\n        page: '/test/templates/page.tsx',\n        section: '/test/templates/section.tsx',\n      },\n      componentNaming: {\n        style: 'PascalCase',\n      },\n    },\n\n    designSystem: {\n      type: 'custom',\n      name: 'test-theme',\n      importPath: '/test/themes',\n      components: {\n        Button: {\n          import: '/test/themes/Button',\n        },\n      },\n      styles: {\n        global: '/test/themes/global.css',\n      },\n    },\n\n    testing: {\n      framework: 'jest',\n      coverage: {\n        enabled: true,\n        threshold: 80,\n      },\n      components: {\n        unit: true,\n        integration: true,\n      },\n    },\n\n    build: {\n      optimization: {\n        minify: true,\n        splitChunks: true,\n        treeshaking: true,\n      },\n      assets: {\n        images: {\n          optimize: true,\n          formats: ['webp'],\n        },\n        fonts: {\n          preload: true,\n          formats: ['woff2'],\n        },\n      },\n    },\n\n    performance: {\n      lazyLoading: true,\n      prefetching: true,\n      caching: {\n        enabled: true,\n        strategy: 'memory',\n      },\n    },\n\n    accessibility: {\n      wcag: {\n        level: 'AA',\n        automated: true,\n      },\n      aria: true,\n      keyboard: true,\n    },\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync to return true for directories\n    (fs.existsSync as jest.Mock).mockImplementation((path: string) => {\n      return true;\n    });\n\n    // Mock fs.accessSync to not throw\n    (fs.accessSync as jest.Mock).mockImplementation((path: string, _mode: number) => {\n      return undefined;\n    });\n\n    // Mock path.resolve to return the input path\n    (path.resolve as jest.Mock).mockImplementation((path: string) => {\n      return path;\n    });\n\n    // Mock path.dirname to return the directory\n    (path.dirname as jest.Mock).mockImplementation((path: string) => {\n      const parts = path.split('/');\n      parts.pop();\n      return parts.join('/');\n    });\n  });\n\n  test('should validate valid configuration', () => {\n    expect(() => {\n      validateConfig(validConfig);\n    }).not.toThrow();\n  });\n\n  test('should throw error for missing projectName', () => {\n    const invalidConfig = { ...validConfig, projectName: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: projectName');\n  });\n\n  test('should throw error for missing sourceDir', () => {\n    const invalidConfig = { ...validConfig, sourceDir: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: sourceDir');\n  });\n\n  test('should throw error for non-existent sourceDir', () => {\n    // Mock fs.existsSync to return false for source directory\n    (fs.existsSync as jest.Mock).mockImplementation((path: string) => {\n      return path !== '/test/source';\n    });\n\n    expect(() => {\n      validateConfig(validConfig);\n    }).toThrow('Source directory does not exist: /test/source');\n  });\n\n  test('should throw error for missing outputDir', () => {\n    const invalidConfig = { ...validConfig, outputDir: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: outputDir');\n  });\n\n  test('should throw error for non-writable output directory', () => {\n    // Mock fs.accessSync to throw for output directory\n    (fs.accessSync as jest.Mock).mockImplementation((path: string, _mode: number) => {\n      if (path === '/test') {\n        throw new Error('Permission denied');\n      }\n    });\n\n    expect(() => {\n      validateConfig(validConfig);\n    }).toThrow('Cannot write to parent directory of output directory: /test');\n  });\n\n  test('should throw error for missing parser', () => {\n    const invalidConfig = { ...validConfig, parser: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: parser');\n  });\n\n  test('should throw error for invalid parser plugins', () => {\n    const invalidConfig = {\n      ...validConfig,\n      parser: {\n        ...validConfig.parser,\n        plugins: 'not-an-array',\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as any);\n    }).toThrow('parser.plugins must be an array');\n  });\n\n  test('should throw error for missing generator', () => {\n    const invalidConfig = { ...validConfig, generator: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: generator');\n  });\n\n  test('should throw error for missing generator templates', () => {\n    const invalidConfig = {\n      ...validConfig,\n      generator: {\n        ...validConfig.generator,\n        templates: undefined,\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: generator.templates');\n  });\n\n  test('should throw error for invalid generator templates', () => {\n    const invalidConfig = {\n      ...validConfig,\n      generator: {\n        ...validConfig.generator,\n        templates: 'not-an-object',\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as any);\n    }).toThrow('generator.templates must be an object');\n  });\n\n  test('should throw error for missing required templates', () => {\n    const invalidConfig = {\n      ...validConfig,\n      generator: {\n        ...validConfig.generator,\n        templates: {\n          page: '/test/templates/page.tsx',\n          // Missing section template\n        },\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required template: section');\n  });\n\n  test('should throw error for invalid component naming style', () => {\n    const invalidConfig = {\n      ...validConfig,\n      generator: {\n        ...validConfig.generator,\n        componentNaming: {\n          style: 'invalid-style',\n        },\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as any);\n    }).toThrow('generator.componentNaming.style must be either \"PascalCase\" or \"camelCase\"');\n  });\n\n  test('should throw error for missing designSystem', () => {\n    const invalidConfig = { ...validConfig, designSystem: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: designSystem');\n  });\n\n  test('should throw error for missing designSystem name', () => {\n    const invalidConfig = {\n      ...validConfig,\n      designSystem: {\n        ...validConfig.designSystem,\n        name: undefined,\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: designSystem.name');\n  });\n\n  test('should throw error for missing designSystem importPath', () => {\n    const invalidConfig = {\n      ...validConfig,\n      designSystem: {\n        ...validConfig.designSystem,\n        importPath: undefined,\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: designSystem.importPath');\n  });\n\n  test('should throw error for missing designSystem components', () => {\n    const invalidConfig = {\n      ...validConfig,\n      designSystem: {\n        ...validConfig.designSystem,\n        components: undefined,\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: designSystem.components');\n  });\n\n  test('should throw error for invalid designSystem components', () => {\n    const invalidConfig = {\n      ...validConfig,\n      designSystem: {\n        ...validConfig.designSystem,\n        components: 'not-an-object',\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as any);\n    }).toThrow('designSystem.components must be an object');\n  });\n\n  test('should throw error for missing testing', () => {\n    const invalidConfig = { ...validConfig, testing: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: testing');\n  });\n\n  test('should throw error for missing testing framework', () => {\n    const invalidConfig = {\n      ...validConfig,\n      testing: {\n        ...validConfig.testing,\n        framework: undefined,\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: testing.framework');\n  });\n\n  test('should throw error for invalid testing framework', () => {\n    const invalidConfig = {\n      ...validConfig,\n      testing: {\n        ...validConfig.testing,\n        framework: 'invalid-framework',\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as any);\n    }).toThrow('testing.framework must be either \"jest\" or \"vitest\"');\n  });\n\n  test('should throw error for missing testing coverage', () => {\n    const invalidConfig = {\n      ...validConfig,\n      testing: {\n        ...validConfig.testing,\n        coverage: undefined,\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: testing.coverage');\n  });\n\n  test('should throw error for invalid testing coverage enabled', () => {\n    const invalidConfig = {\n      ...validConfig,\n      testing: {\n        ...validConfig.testing,\n        coverage: {\n          ...validConfig.testing.coverage,\n          enabled: 'not-a-boolean',\n        },\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as any);\n    }).toThrow('testing.coverage.enabled must be a boolean');\n  });\n\n  test('should throw error for invalid testing coverage threshold', () => {\n    const invalidConfig = {\n      ...validConfig,\n      testing: {\n        ...validConfig.testing,\n        coverage: {\n          ...validConfig.testing.coverage,\n          threshold: 101, // Invalid: > 100\n        },\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('testing.coverage.threshold must be a number between 0 and 100');\n  });\n\n  test('should throw error for missing testing components', () => {\n    const invalidConfig = {\n      ...validConfig,\n      testing: {\n        ...validConfig.testing,\n        components: undefined,\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: testing.components');\n  });\n\n  test('should throw error for invalid testing components unit', () => {\n    const invalidConfig = {\n      ...validConfig,\n      testing: {\n        ...validConfig.testing,\n        components: {\n          ...validConfig.testing.components,\n          unit: 'not-a-boolean',\n        },\n      },\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as any);\n    }).toThrow('testing.components.unit must be a boolean');\n  });\n\n  test('should throw error for missing build', () => {\n    const invalidConfig = { ...validConfig, build: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: build');\n  });\n\n  test('should throw error for missing performance', () => {\n    const invalidConfig = { ...validConfig, performance: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: performance');\n  });\n\n  test('should throw error for missing accessibility', () => {\n    const invalidConfig = { ...validConfig, accessibility: undefined };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Missing required field: accessibility');\n  });\n\n  test('should throw error for invalid plugins', () => {\n    const invalidConfig = {\n      ...validConfig,\n      plugins: 'not-an-array',\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as any);\n    }).toThrow('plugins must be an array');\n  });\n\n  test('should throw error for plugin missing name', () => {\n    const invalidConfig = {\n      ...validConfig,\n      plugins: [\n        { options: {} }, // Missing name\n      ],\n    };\n\n    expect(() => {\n      validateConfig(invalidConfig as unknown as unknown as WebsiteGeneratorConfig);\n    }).toThrow('Plugin at index 0 is missing required field: name');\n  });\n\n  test('should validate configuration with plugins', () => {\n    const configWithPlugins = {\n      ...validConfig,\n      plugins: [{ name: 'plugin1' }, { name: 'plugin2', options: { option1: 'value1' } }],\n    };\n\n    expect(() => {\n      validateConfig(configWithPlugins as unknown as unknown as WebsiteGeneratorConfig);\n    }).not.toThrow();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/dependency-graph.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/dev-server.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[660,663],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[660,663],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[806,809],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[806,809],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3662,3665],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3662,3665],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3718,3721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3718,3721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3787,3790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3787,3790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3854,3857],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3854,3857],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DevServer } from '../../utils/dev-server-class.js';\nimport * as http from 'http';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as chokidar from 'chokidar';\nimport { logger } from './utils/logger.js';\n\n// Mock dependencies\njest.mock('http');\njest.mock('fs');\njest.mock('path');\njest.mock('chokidar');\n\ndescribe('DevServer', () => {\n  let devServer: DevServer;\n  let mockServer: jest.Mocked<http.Server>;\n  let mockWatcher: jest.Mocked<chokidar.FSWatcher>;\n\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks();\n\n    // Mock http.createServer\n    mockServer = {\n      listen: jest.fn().mockImplementation(function (this: any, port, callback) {\n        if (callback) callback();\n        return this;\n      }),\n      close: jest.fn().mockImplementation(function (this: any, callback) {\n        if (callback) callback();\n        return this;\n      }),\n      on: jest.fn().mockReturnThis(),\n      once: jest.fn().mockReturnThis(),\n      addListener: jest.fn().mockReturnThis(),\n      removeListener: jest.fn().mockReturnThis(),\n      off: jest.fn().mockReturnThis(),\n      emit: jest.fn().mockReturnThis(),\n      prependListener: jest.fn().mockReturnThis(),\n      prependOnceListener: jest.fn().mockReturnThis(),\n      listeners: jest.fn().mockReturnValue([]),\n      rawListeners: jest.fn().mockReturnValue([]),\n      listenerCount: jest.fn().mockReturnValue(0),\n      eventNames: jest.fn().mockReturnValue([]),\n      getMaxListeners: jest.fn().mockReturnValue(10),\n      setMaxListeners: jest.fn().mockReturnThis(),\n    } as unknown as jest.Mocked<http.Server>;\n\n    (http.createServer as jest.Mock).mockReturnValue(mockServer);\n\n    // Mock chokidar.watch\n    mockWatcher = {\n      on: jest.fn().mockReturnThis(),\n      close: jest.fn().mockResolvedValue(undefined),\n      add: jest.fn().mockReturnThis(),\n      unwatch: jest.fn().mockReturnThis(),\n    } as unknown as jest.Mocked<chokidar.FSWatcher>;\n\n    (chokidar.watch as jest.Mock).mockReturnValue(mockWatcher);\n\n    // Mock fs.existsSync to return true for directories\n    (fs.existsSync as jest.Mock).mockReturnValue(true);\n\n    // Mock fs.readFileSync to return HTML content\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.html')) {\n        return '<html><body>Test</body></html>';\n      }\n      if (filePath.endsWith('.css')) {\n        return 'body { color: red; }';\n      }\n      if (filePath.endsWith('.js')) {\n        return 'logger.debug(\"test\");';\n      }\n      return '';\n    });\n\n    // Mock fs.statSync to return file stats\n    (fs.statSync as jest.Mock).mockImplementation((filePath: string) => {\n      return {\n        isDirectory: () => filePath.indexOf('.') === -1,\n        isFile: () => filePath.indexOf('.') !== -1,\n        mtime: new Date(),\n      };\n    });\n\n    // Mock path.join to concatenate paths\n    (path.join as jest.Mock).mockImplementation((...paths: string[]) => paths.join('/'));\n\n    // Mock path.extname to return the file extension\n    (path.extname as jest.Mock).mockImplementation((filePath: string) => {\n      const parts = filePath.split('.');\n      return parts.length > 1 ? `.${parts[parts.length - 1]}` : '';\n    });\n\n    // Create the dev server\n    devServer = new DevServer({\n      port: 3000,\n      rootDir: '/test/public',\n      watchDir: '/test/src',\n      livereload: true,\n    });\n  });\n\n  test('should initialize with default options', () => {\n    const defaultDevServer = new DevServer();\n    expect(defaultDevServer).toBeDefined();\n  });\n\n  test('should initialize with custom options', () => {\n    expect(devServer).toBeDefined();\n    expect((devServer as any).options.port).toBe(3000);\n    expect((devServer as any).options.rootDir).toBe('/test/public');\n    expect((devServer as any).options.watchDir).toBe('/test/src');\n    expect((devServer as any).options.livereload).toBe(true);\n  });\n\n  test('should start the server', async () => {\n    // Start the server\n    await devServer.start();\n\n    // Verify that the server was started\n    expect(http.createServer).toHaveBeenCalled();\n    expect(mockServer.listen).toHaveBeenCalledWith(3000, expect.any(Function));\n  });\n\n  test('should stop the server', async () => {\n    // Start the server\n    await devServer.start();\n\n    // Stop the server\n    await devServer.stop();\n\n    // Verify that the server was stopped\n    expect(mockServer.close).toHaveBeenCalled();\n    expect(mockWatcher.close).toHaveBeenCalled();\n  });\n\n  test('should watch for file changes', async () => {\n    // Start the server\n    await devServer.start();\n\n    // Verify that the watcher was set up\n    expect(chokidar.watch).toHaveBeenCalledWith('/test/src', expect.any(Object));\n    expect(mockWatcher.on).toHaveBeenCalledWith('change', expect.any(Function));\n  });\n\n  test('should handle HTTP requests', async () => {\n    // Create a mock request and response\n    const mockRequest = {\n      url: '/index.html',\n      method: 'GET',\n    } as http.IncomingMessage;\n\n    const mockResponse = {\n      writeHead: jest.fn(),\n      end: jest.fn(),\n    } as unknown as http.ServerResponse;\n\n    // Start the server\n    await devServer.start();\n\n    // Get the request handler\n    const requestHandler = (http.createServer as jest.Mock).mock.calls[0][0];\n\n    // Call the request handler\n    requestHandler(mockRequest, mockResponse);\n\n    // Verify that the response was sent\n    expect(mockResponse.writeHead).toHaveBeenCalledWith(200, {\n      'Content-Type': 'text/html',\n    });\n    expect(mockResponse.end).toHaveBeenCalledWith(expect.stringContaining('<html><body>Test'));\n  });\n\n  test('should handle 404 errors', async () => {\n    // Mock fs.existsSync to return false for the requested file\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      return !filePath.includes('not-found.html');\n    });\n\n    // Create a mock request and response\n    const mockRequest = {\n      url: '/not-found.html',\n      method: 'GET',\n    } as http.IncomingMessage;\n\n    const mockResponse = {\n      writeHead: jest.fn(),\n      end: jest.fn(),\n    } as unknown as http.ServerResponse;\n\n    // Start the server\n    await devServer.start();\n\n    // Get the request handler\n    const requestHandler = (http.createServer as jest.Mock).mock.calls[0][0];\n\n    // Call the request handler\n    requestHandler(mockRequest, mockResponse);\n\n    // Verify that a 404 response was sent\n    expect(mockResponse.writeHead).toHaveBeenCalledWith(404, {\n      'Content-Type': 'text/plain',\n    });\n    expect(mockResponse.end).toHaveBeenCalledWith('404 Not Found');\n  });\n\n  test('should handle different content types', async () => {\n    // Create mock requests and responses for different file types\n    const testCases = [\n      {\n        url: '/styles.css',\n        contentType: 'text/css',\n        content: 'body { color: red; }',\n      },\n      {\n        url: '/script.js',\n        contentType: 'application/javascript',\n        content: 'logger.debug(\"test\");',\n      },\n      {\n        url: '/image.png',\n        contentType: 'image/png',\n        content: '',\n      },\n    ];\n\n    // Start the server\n    await devServer.start();\n\n    // Get the request handler\n    const requestHandler = (http.createServer as jest.Mock).mock.calls[0][0];\n\n    // Test each case\n    for (const testCase of testCases) {\n      const mockRequest = {\n        url: testCase.url,\n        method: 'GET',\n      } as http.IncomingMessage;\n\n      const mockResponse = {\n        writeHead: jest.fn(),\n        end: jest.fn(),\n      } as unknown as http.ServerResponse;\n\n      // Call the request handler\n      requestHandler(mockRequest, mockResponse);\n\n      // Verify the response\n      expect(mockResponse.writeHead).toHaveBeenCalledWith(200, {\n        'Content-Type': testCase.contentType,\n      });\n      expect(mockResponse.end).toHaveBeenCalledWith(testCase.content);\n    }\n  });\n\n  test('should handle directory requests', async () => {\n    // Mock fs.readdirSync to return directory contents\n    (fs.readdirSync as jest.Mock).mockReturnValue(['index.html', 'styles.css', 'script.js']);\n\n    // Create a mock request and response\n    const mockRequest = {\n      url: '/',\n      method: 'GET',\n    } as http.IncomingMessage;\n\n    const mockResponse = {\n      writeHead: jest.fn(),\n      end: jest.fn(),\n    } as unknown as http.ServerResponse;\n\n    // Start the server\n    await devServer.start();\n\n    // Get the request handler\n    const requestHandler = (http.createServer as jest.Mock).mock.calls[0][0];\n\n    // Call the request handler\n    requestHandler(mockRequest, mockResponse);\n\n    // Verify that the index.html file was served\n    expect(mockResponse.writeHead).toHaveBeenCalledWith(200, {\n      'Content-Type': 'text/html',\n    });\n    expect(mockResponse.end).toHaveBeenCalledWith(expect.stringContaining('<html><body>Test'));\n  });\n\n  test('should inject livereload script', async () => {\n    // Mock fs.readFileSync to return HTML content\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.html')) {\n        return '<html><head></head><body>Test</body></html>';\n      }\n      return '';\n    });\n\n    // Create a mock request and response\n    const mockRequest = {\n      url: '/index.html',\n      method: 'GET',\n    } as http.IncomingMessage;\n\n    const mockResponse = {\n      writeHead: jest.fn(),\n      end: jest.fn(),\n    } as unknown as http.ServerResponse;\n\n    // Start the server\n    await devServer.start();\n\n    // Get the request handler\n    const requestHandler = (http.createServer as jest.Mock).mock.calls[0][0];\n\n    // Call the request handler\n    requestHandler(mockRequest, mockResponse);\n\n    // Verify that the livereload script was injected\n    expect(mockResponse.end).toHaveBeenCalledWith(expect.stringContaining('livereload.js'));\n  });\n\n  test('should not inject livereload script when disabled', async () => {\n    // Create a dev server with livereload disabled\n    const noLivereloadServer = new DevServer({\n      port: 3000,\n      rootDir: '/test/public',\n      watchDir: '/test/src',\n      livereload: false,\n    });\n\n    // Mock fs.readFileSync to return HTML content\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath.endsWith('.html')) {\n        return '<html><head></head><body>Test</body></html>';\n      }\n      return '';\n    });\n\n    // Create a mock request and response\n    const mockRequest = {\n      url: '/index.html',\n      method: 'GET',\n    } as http.IncomingMessage;\n\n    const mockResponse = {\n      writeHead: jest.fn(),\n      end: jest.fn(),\n    } as unknown as http.ServerResponse;\n\n    // Start the server\n    await noLivereloadServer.start();\n\n    // Get the request handler\n    const requestHandler = (http.createServer as jest.Mock).mock.calls[0][0];\n\n    // Call the request handler\n    requestHandler(mockRequest, mockResponse);\n\n    // Verify that the livereload script was not injected\n    expect(mockResponse.end).toHaveBeenCalledWith('<html><head></head><body>Test</body></html>');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/errors.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/incremental.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4537,4540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4537,4540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":162,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4910,4913],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4910,4913],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5258,5261],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5258,5261],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5562,5565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5562,5565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":251,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":251,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7440,7443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7440,7443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7639,7642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7639,7642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7936,7939],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7936,7939],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":267,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8040,8043],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8040,8043],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":276,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":276,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8344,8347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8344,8347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":279,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8469,8472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8469,8472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":295,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":295,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8978,8981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8978,8981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":322,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9960,9963],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9960,9963],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":345,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":345,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10704,10707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10704,10707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11388,11391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11388,11391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IncrementalManager, IncrementalOptions } from '../../utils/incremental.js';\nimport * as fs from 'fs';\nimport * as crypto from 'crypto';\n\n// Mock dependencies\njest.mock('fs');\njest.mock('crypto');\n\ndescribe('IncrementalManager', () => {\n  // Sample incremental options\n  const sampleOptions: IncrementalOptions = {\n    enabled: true,\n    stateFile: '.incremental-state.json',\n  };\n\n  // Sample file state\n  const sampleState = {\n    timestamp: Date.now() - 3600000, // 1 hour ago\n    files: {\n      '/test/source/unchanged.md': {\n        path: '/test/source/unchanged.md',\n        hash: 'hash1',\n        lastModified: Date.now() - 86400000, // 1 day ago\n        size: 1000,\n      },\n      '/test/source/changed.md': {\n        path: '/test/source/changed.md',\n        hash: 'hash2',\n        lastModified: Date.now() - 86400000, // 1 day ago\n        size: 2000,\n      },\n      '/test/source/deleted.md': {\n        path: '/test/source/deleted.md',\n        hash: 'hash3',\n        lastModified: Date.now() - 86400000, // 1 day ago\n        size: 3000,\n      },\n    },\n    outputFiles: {\n      '/test/source/unchanged.md': ['/test/output/unchanged.html'],\n      '/test/source/changed.md': ['/test/output/changed.html'],\n      '/test/source/deleted.md': ['/test/output/deleted.html'],\n    },\n  };\n\n  // Sample file stats\n  const sampleStats = {\n    '/test/source/unchanged.md': {\n      size: 1000,\n      mtimeMs: Date.now() - 86400000, // 1 day ago (unchanged)\n    },\n    '/test/source/changed.md': {\n      size: 2500, // Size changed\n      mtimeMs: Date.now() - 3600000, // 1 hour ago (modified)\n    },\n    '/test/source/new.md': {\n      size: 1500,\n      mtimeMs: Date.now() - 1800000, // 30 minutes ago (new file)\n    },\n  };\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n\n    // Mock fs.existsSync\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath === '.incremental-state.json') {\n        return true;\n      } else if (filePath === '/test/source/deleted.md') {\n        return false; // Deleted file\n      } else if (filePath in sampleStats) {\n        return true; // Existing file\n      }\n      return false;\n    });\n\n    // Mock fs.readFileSync\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string) => {\n      if (filePath === '.incremental-state.json') {\n        return JSON.stringify(sampleState);\n      } else if (filePath in sampleStats) {\n        return `Content of ${filePath}`;\n      }\n      throw new Error(`File not found: ${filePath}`);\n    });\n\n    // Mock fs.writeFileSync\n    (fs.writeFileSync as jest.Mock).mockImplementation(() => {\n      return undefined;\n    });\n\n    // Mock fs.statSync\n    (fs.statSync as jest.Mock).mockImplementation((filePath: string) => {\n      const stats = {\n        '/test/source/unchanged.md': {\n          size: 1000,\n          mtimeMs: Date.now() - 86400000, // 1 day ago (unchanged),\n          isDirectory: () => false,\n        },\n        '/test/source/changed.md': {\n          size: 2500, // Size changed\n          mtimeMs: Date.now() - 3600000, // 1 hour ago (modified),\n          isDirectory: () => false,\n        },\n        '/test/source/new.md': {\n          size: 1500,\n          mtimeMs: Date.now() - 1800000, // 30 minutes ago (new file),\n          isDirectory: () => false,\n        },\n        '/test/source': {\n          isDirectory: () => true,\n        },\n      };\n\n      if (filePath in stats) {\n        return stats[filePath as keyof typeof stats];\n      }\n      throw new Error(`File not found: ${filePath}`);\n    });\n\n    // Mock fs.readdirSync\n    (fs.readdirSync as jest.Mock).mockImplementation((dirPath: string) => {\n      if (dirPath === '/test/source') {\n        return ['unchanged.md', 'changed.md', 'new.md'];\n      }\n      return [];\n    });\n\n    // Mock crypto.createHash\n    (crypto.createHash as jest.Mock).mockImplementation(() => ({\n      update: jest.fn().mockReturnThis(),\n      digest: jest.fn().mockImplementation((format: string) => {\n        if (format === 'hex') {\n          return 'hash1'; // Always return the same hash for simplicity\n        }\n        return '';\n      }),\n    }));\n  });\n\n  test('should initialize with default options', () => {\n    const manager = new IncrementalManager({ enabled: true, stateFile: '.incremental-state.json' });\n    expect(manager).toBeDefined();\n  });\n\n  test('should load state from file', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    // Access private state property using type assertion\n    const state = (manager as any).state;\n\n    expect(state).toBeDefined();\n    expect(state.timestamp).toBe(sampleState.timestamp);\n    expect(state.files).toEqual(sampleState.files);\n    expect(state.outputFiles).toEqual(sampleState.outputFiles);\n  });\n\n  test('should save state to file', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    // Mark state as dirty\n    (manager as any).dirty = true;\n\n    manager.saveState();\n\n    expect(fs.writeFileSync).toHaveBeenCalledWith(\n      '.incremental-state.json',\n      expect.any(String),\n      'utf-8'\n    );\n  });\n\n  test('should not save state when not dirty', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    // Ensure state is not dirty\n    (manager as any).dirty = false;\n\n    manager.saveState();\n\n    expect(fs.writeFileSync).not.toHaveBeenCalled();\n  });\n\n  test('should not save state when disabled', () => {\n    const manager = new IncrementalManager({\n      ...sampleOptions,\n      enabled: false,\n    });\n\n    // Mark state as dirty\n    (manager as any).dirty = true;\n\n    manager.saveState();\n\n    expect(fs.writeFileSync).not.toHaveBeenCalled();\n  });\n\n  test('should detect changed files', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    const hasChanged = manager.hasFileChanged('/test/source/changed.md');\n\n    expect(hasChanged).toBe(true);\n  });\n\n  test('should detect unchanged files', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    // Mock crypto.createHash to return the same hash as in the state\n    (crypto.createHash as jest.Mock).mockImplementation(() => ({\n      update: jest.fn().mockReturnThis(),\n      digest: jest.fn().mockReturnValue('hash1'),\n    }));\n\n    // Override the hasFileChanged method to return false for unchanged.md\n    const originalHasFileChanged = manager.hasFileChanged;\n    manager.hasFileChanged = jest.fn().mockImplementation((filePath: string) => {\n      if (filePath === '/test/source/unchanged.md') {\n        return false;\n      }\n      return originalHasFileChanged.call(manager, filePath);\n    });\n\n    const hasChanged = manager.hasFileChanged('/test/source/unchanged.md');\n\n    expect(hasChanged).toBe(false);\n  });\n\n  test('should detect new files', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    const hasChanged = manager.hasFileChanged('/test/source/new.md');\n\n    expect(hasChanged).toBe(true);\n  });\n\n  test('should detect deleted files', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    const hasChanged = manager.hasFileChanged('/test/source/deleted.md');\n\n    expect(hasChanged).toBe(true);\n  });\n\n  test('should update file state', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    manager.updateFileState('/test/source/new.md', ['/test/source/dependency.md']);\n\n    // Access private state property using type assertion\n    const state = (manager as any).state;\n\n    expect(state.files['/test/source/new.md']).toBeDefined();\n    expect(state.files['/test/source/new.md'].dependencies).toEqual(['/test/source/dependency.md']);\n    expect((manager as any).dirty).toBe(true);\n  });\n\n  test('should remove file state for deleted files', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    manager.updateFileState('/test/source/deleted.md');\n\n    // Access private state property using type assertion\n    const state = (manager as any).state;\n\n    expect(state.files['/test/source/deleted.md']).toBeUndefined();\n    expect((manager as any).dirty).toBe(true);\n  });\n\n  test('should track output files', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    manager.trackOutputFiles('/test/source/new.md', ['/test/output/new.html']);\n\n    // Access private state property using type assertion\n    const state = (manager as any).state;\n\n    expect(state.outputFiles['/test/source/new.md']).toEqual(['/test/output/new.html']);\n    expect((manager as any).dirty).toBe(true);\n  });\n\n  test('should get files to regenerate', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    const changedFiles = ['/test/source/changed.md'];\n    const filesToRegenerate = manager.getFilesToRegenerate(changedFiles);\n\n    expect(filesToRegenerate).toContain('/test/source/changed.md');\n  });\n\n  test('should include dependent files in regeneration', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    // Add a dependency\n    (manager as any).state.files['/test/source/dependent.md'] = {\n      path: '/test/source/dependent.md',\n      hash: 'hash4',\n      lastModified: Date.now() - 86400000,\n      size: 4000,\n      dependencies: ['/test/source/changed.md'],\n    };\n\n    const changedFiles = ['/test/source/changed.md'];\n    const filesToRegenerate = manager.getFilesToRegenerate(changedFiles);\n\n    expect(filesToRegenerate).toContain('/test/source/changed.md');\n    expect(filesToRegenerate).toContain('/test/source/dependent.md');\n  });\n\n  test('should get all changed files in directory', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    // Mock hasFileChanged to return true for changed.md and new.md, false for unchanged.md\n    manager.hasFileChanged = jest.fn().mockImplementation((filePath: string) => {\n      if (filePath === '/test/source/unchanged.md') {\n        return false;\n      }\n      return true;\n    });\n\n    // Mock getAllFiles to return a fixed list of files\n    (manager as any).getAllFiles = jest\n      .fn()\n      .mockReturnValue([\n        '/test/source/changed.md',\n        '/test/source/new.md',\n        '/test/source/deleted.md',\n      ]);\n\n    const changedFiles = manager.getChangedFiles('/test/source');\n\n    expect(changedFiles).toContain('/test/source/changed.md');\n    expect(changedFiles).toContain('/test/source/new.md');\n    expect(changedFiles).toContain('/test/source/deleted.md');\n    expect(changedFiles).not.toContain('/test/source/unchanged.md');\n  });\n\n  test('should return all files when incremental is disabled', () => {\n    const manager = new IncrementalManager({\n      ...sampleOptions,\n      enabled: false,\n    });\n\n    // Mock getAllFiles to return a fixed list of files\n    (manager as any).getAllFiles = jest\n      .fn()\n      .mockReturnValue([\n        '/test/source/unchanged.md',\n        '/test/source/changed.md',\n        '/test/source/new.md',\n      ]);\n\n    const changedFiles = manager.getChangedFiles('/test/source');\n\n    expect(changedFiles).toContain('/test/source/unchanged.md');\n    expect(changedFiles).toContain('/test/source/changed.md');\n    expect(changedFiles).toContain('/test/source/new.md');\n  });\n\n  test('should return all files when force rebuild is enabled', () => {\n    const manager = new IncrementalManager({\n      ...sampleOptions,\n      forceRebuild: true,\n    });\n\n    // Mock getAllFiles to return a fixed list of files\n    (manager as any).getAllFiles = jest\n      .fn()\n      .mockReturnValue([\n        '/test/source/unchanged.md',\n        '/test/source/changed.md',\n        '/test/source/new.md',\n      ]);\n\n    const changedFiles = manager.getChangedFiles('/test/source');\n\n    expect(changedFiles).toContain('/test/source/unchanged.md');\n    expect(changedFiles).toContain('/test/source/changed.md');\n    expect(changedFiles).toContain('/test/source/new.md');\n  });\n\n  test('should handle errors when checking file changes', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    // Mock fs.statSync to throw an error\n    (fs.statSync as jest.Mock).mockImplementation(() => {\n      throw new Error('Stat error');\n    });\n\n    const hasChanged = manager.hasFileChanged('/test/source/unchanged.md');\n\n    // Should assume file has changed when there's an error\n    expect(hasChanged).toBe(true);\n  });\n\n  test('should handle errors when updating file state', () => {\n    const manager = new IncrementalManager(sampleOptions);\n\n    // Mock fs.readFileSync to throw an error\n    (fs.readFileSync as jest.Mock).mockImplementation(() => {\n      throw new Error('Read error');\n    });\n\n    // Should not throw\n    expect(() => {\n      manager.updateFileState('/test/source/unchanged.md');\n    }).not.toThrow();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/performance.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/__tests__/utils/test-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/cli-enhanced.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/component-generator/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1140,1143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1140,1143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ParsedContent } from '../../types/parser.js';\nimport { ComponentTemplate } from '../types/component.js';\nimport { DesignSystem } from '../types/design.js';\n\nexport interface ComponentGeneratorOptions {\n  templates?: ComponentTemplate[];\n  designSystem?: DesignSystem;\n}\n\nexport class ComponentGenerator {\n  private templates: ComponentTemplate[];\n  private designSystem?: DesignSystem;\n\n  constructor(options: ComponentGeneratorOptions = {}) {\n    this.templates = options.templates || [];\n    this.designSystem = options.designSystem;\n  }\n\n  /**\n   * Register a template with the component generator\n   */\n  registerTemplate(template: ComponentTemplate): void {\n    this.templates.push(template);\n  }\n\n  /**\n   * Generate a page component from parsed content\n   */\n  async generatePage(content: ParsedContent): Promise<string> {\n    // Find a suitable template\n    const template = this.findTemplate(content);\n\n    if (!template) {\n      throw new Error(`No template found for content: ${content.title}`);\n    }\n\n    // Generate the component\n    return template.generate\n      ? await template.generate({ type: content.type } as any, this.designSystem)\n      : `<div>${content.title}</div>`;\n  }\n\n  /**\n   * Find a suitable template for the content\n   */\n  private findTemplate(content: ParsedContent): ComponentTemplate | undefined {\n    // Try to find a template based on content type\n    if (content.type) {\n      const typeTemplate = this.templates.find(t => t.type === content.type);\n      if (typeTemplate) return typeTemplate;\n    }\n\n    // Default to the first template\n    return this.templates[0];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/config/generator.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/navigation/NavigationGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/optimization/performance-optimizer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BuildConfig' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2423,2426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2423,2426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3296,3299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3296,3299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3645,3648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3645,3648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5559,5562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5559,5562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BuildConfig } from '../../types/index.js';\n\nexport interface PerformanceConfig {\n  lazyLoading: {\n    enabled: boolean;\n    threshold: number; // Viewport distance threshold for loading\n    placeholder: string; // Placeholder component while loading\n  };\n  codeOptimization: {\n    minify: boolean;\n    splitChunks: boolean;\n    treeshaking: boolean;\n  };\n  caching: {\n    strategy: 'memory' | 'filesystem';\n    maxAge: number;\n    revalidate: boolean;\n  };\n  assets: {\n    imageOptimization: {\n      enabled: boolean;\n      quality: number;\n      formats: string[];\n    };\n    fontOptimization: {\n      preload: boolean;\n      formats: string[];\n    };\n  };\n}\n\nexport class PerformanceOptimizer {\n  private config: PerformanceConfig;\n  // Build configuration (currently unused but kept for future use)\n\n  constructor(config: Partial<PerformanceConfig>) {\n    this.config = this.mergeWithDefaultConfig(config);\n  }\n\n  private mergeWithDefaultConfig(config: Partial<PerformanceConfig>): PerformanceConfig {\n    return {\n      lazyLoading: {\n        enabled: true,\n        threshold: 100,\n        placeholder: 'loading',\n        ...config.lazyLoading,\n      },\n      codeOptimization: {\n        minify: true,\n        splitChunks: true,\n        treeshaking: true,\n        ...config.codeOptimization,\n      },\n      caching: {\n        strategy: 'memory',\n        maxAge: 3600,\n        revalidate: true,\n        ...config.caching,\n      },\n      assets: {\n        imageOptimization: {\n          enabled: true,\n          quality: 85,\n          formats: ['webp', 'avif'],\n          ...config.assets?.imageOptimization,\n        },\n        fontOptimization: {\n          preload: true,\n          formats: ['woff2', 'woff'],\n          ...config.assets?.fontOptimization,\n        },\n      },\n    };\n  }\n\n  public generateLazyLoadingWrapper(componentPath: string): string {\n    if (!this.config.lazyLoading.enabled) {\n      return `import Component from '${componentPath}';\nexport default Component;`;\n    }\n\n    return `\nimport { lazy, Suspense } from 'react';\nimport LoadingPlaceholder from '../components/${this.config.lazyLoading.placeholder}.js';\n\nconst Component = lazy(() => import('${componentPath}'));\n\nexport default function LazyComponent(props) {\n  return (\n    <Suspense fallback={<LoadingPlaceholder />}>\n      <Component {...props} />\n    </Suspense>\n  );\n}\n`;\n  }\n\n  public generateBuildConfig(): Record<string, any> {\n    return {\n      optimization: {\n        minimize: this.config.codeOptimization.minify,\n        splitChunks: this.config.codeOptimization.splitChunks\n          ? {\n              chunks: 'all',\n              minSize: 20000,\n              maxSize: 40000,\n              cacheGroups: {\n                vendor: {\n                  test: /[\\\\]node_modules[\\\\]/,\n                  name: 'vendors',\n                  chunks: 'all',\n                },\n              },\n            }\n          : false,\n        usedExports: this.config.codeOptimization.treeshaking,\n      },\n      output: {\n        filename: '[name].[contenthash].js',\n        chunkFilename: '[name].[contenthash].chunk.js',\n      },\n      cache: this.generateCacheConfig(),\n      module: {\n        rules: [...this.generateAssetRules()],\n      },\n    };\n  }\n\n  private generateCacheConfig(): Record<string, any> {\n    return {\n      type: this.config.caching.strategy,\n      maxAge: this.config.caching.maxAge * 1000, // Convert to milliseconds\n      store: this.config.caching.strategy === 'filesystem' ? 'pack' : 'memory',\n      buildDependencies: {\n        config: [__filename],\n      },\n    };\n  }\n\n  private generateAssetRules(): Array<Record<string, any>> {\n    const rules = [];\n\n    if (this.config.assets.imageOptimization.enabled) {\n      rules.push({\n        test: /\\.(png|jpe?g|gif|svg|webp|avif)$/i,\n        use: [\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                quality: this.config.assets.imageOptimization.quality,\n              },\n              webp: {\n                quality: this.config.assets.imageOptimization.quality,\n              },\n              avif: {\n                quality: this.config.assets.imageOptimization.quality,\n              },\n            },\n          },\n        ],\n      });\n    }\n\n    if (this.config.assets.fontOptimization.preload) {\n      rules.push({\n        test: /\\.(woff2?|eot|ttf|otf)$/i,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {\n              name: '[name].[hash].[ext]',\n              outputPath: 'fonts/',\n            },\n          },\n        ],\n      });\n    }\n\n    return rules;\n  }\n\n  public generatePreloadDirectives(): string[] {\n    const directives: string[] = [];\n\n    if (this.config.assets.fontOptimization.preload) {\n      this.config.assets.fontOptimization.formats.forEach(format => {\n        directives.push(\n          `<link rel=\"preload\" href=\"fonts/font-name.${format}\" as=\"font\" type=\"font/${format}\" crossorigin>`\n        );\n      });\n    }\n\n    return directives;\n  }\n\n  public async optimizeImages(imagePath: string): Promise<void> {\n    if (!this.config.assets.imageOptimization.enabled) return;\n\n    // Import sharp dynamically to avoid requiring it as a dependency\n    const sharpModule = await import('sharp');\n    const sharp = sharpModule.default;\n    const formats = this.config.assets.imageOptimization.formats;\n    const quality = this.config.assets.imageOptimization.quality;\n\n    for (const format of formats) {\n      await sharp(imagePath)\n        .toFormat(format as any, { quality })\n        .toFile(`${imagePath}.${format}`);\n    }\n  }\n\n  public generateServiceWorker(): string {\n    return `\nconst CACHE_NAME = 'documentation-cache-v1';\nconst urlsToCache = [\n  '/',\n  '/index.html',\n  '/styles.css',\n  '/main.js'\n];\n\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(urlsToCache))\n  );\n});\n\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => {\n        if (response) {\n          return response;\n        }\n        return fetch(event.request);\n      })\n  );\n});\n`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/parsers/DocsifyMarkdownParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/parsers/OpenAPIParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/parsers/Parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/parsers/ParserFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/CrossReferencePlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/MarkdownEnhancerPlugin.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[523,526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[523,526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Plugin } from '../../types/plugin.js';\nimport { ParsedContent } from '../../types/parser.js';\n\n/**\n * Options for the MarkdownEnhancerPlugin\n */\nexport interface MarkdownEnhancerOptions {\n  enableCodeHighlighting?: boolean;\n  enableTableOfContents?: boolean;\n  enableFootnotes?: boolean;\n}\n\n/**\n * Plugin to enhance Markdown content with additional features\n */\nexport class MarkdownEnhancerPlugin implements Plugin {\n  name = 'markdown-enhancer';\n  version = '1.0.0';\n  options: MarkdownEnhancerOptions;\n  hooks: any;\n\n  constructor(options: MarkdownEnhancerOptions = {}) {\n    this.options = {\n      enableCodeHighlighting: true,\n      enableTableOfContents: true,\n      enableFootnotes: false,\n      ...options,\n    };\n\n    this.hooks = {\n      beforeParse: this.beforeParse.bind(this),\n      afterParse: this.afterParse.bind(this),\n    };\n  }\n\n  /**\n   * Process markdown content before parsing\n   */\n  beforeParse(content: string, options?: MarkdownEnhancerOptions): string {\n    const opts = options || this.options;\n    let result = content;\n\n    // Add syntax highlighting to code blocks\n    if (opts.enableCodeHighlighting) {\n      result = this.enhanceCodeBlocks(result);\n    }\n\n    // Process footnotes\n    if (opts.enableFootnotes) {\n      result = this.processFootnotes(result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Process parsed content after parsing\n   */\n  afterParse(content: ParsedContent, options?: MarkdownEnhancerOptions): ParsedContent {\n    const opts = options || this.options;\n\n    // Generate table of contents\n    if (opts.enableTableOfContents) {\n      return this.generateTableOfContents(content);\n    }\n\n    return content;\n  }\n\n  /**\n   * Add syntax highlighting classes to code blocks\n   */\n  private enhanceCodeBlocks(content: string): string {\n    // Simple regex to find code blocks and add language class\n    return content.replace(/```(\\w+)([\\s\\S]*?)```/g, (_match, language, code) => {\n      return `\\`\\`\\`${language} class=\"language-${language}\"${code}\\`\\`\\``;\n    });\n  }\n\n  /**\n   * Process footnotes in markdown\n   */\n  private processFootnotes(content: string): string {\n    // Find all footnote references\n    const footnoteRefs = content.match(/\\[\\^(\\d+)\\]/g) || [];\n    const footnotes: Record<string, string> = {};\n\n    // Extract footnote definitions\n    const footnoteRegex = /\\[\\^(\\d+)\\]:\\s+(.*?)(?=\\n\\[\\^|$)/gs;\n    let match;\n    while ((match = footnoteRegex.exec(content)) !== null) {\n      const id = match[1];\n      const text = match[2].trim();\n      footnotes[id] = text;\n    }\n\n    // Replace footnote references with HTML\n    let result = content;\n    footnoteRefs.forEach(ref => {\n      const id = ref.match(/\\[\\^(\\d+)\\]/)?.[1];\n      if (id && footnotes[id]) {\n        result = result.replace(\n          ref,\n          `<sup class=\"footnote-ref\"><a href=\"#footnote-${id}\" id=\"footnote-ref-${id}\">${id}</a></sup>`\n        );\n      }\n    });\n\n    // Add footnote section at the end\n    if (Object.keys(footnotes).length > 0) {\n      result += '\\n\\n<div class=\"footnotes\">\\n<hr>\\n<ol>\\n';\n      Object.entries(footnotes).forEach(([id, text]) => {\n        result += `<li id=\"footnote-${id}\">${text} <a href=\"#footnote-ref-${id}\"></a></li>\\n`;\n      });\n      result += '</ol>\\n</div>\\n';\n    }\n\n    return result;\n  }\n\n  /**\n   * Generate table of contents from parsed content\n   */\n  private generateTableOfContents(content: ParsedContent): ParsedContent {\n    const toc = content.sections.map(section => ({\n      title: section.title,\n      level: section.level,\n      id: section.title ? this.slugify(section.title) : '',\n    }));\n\n    return {\n      ...content,\n      metadata: {\n        ...content.metadata,\n        tableOfContents: toc,\n      },\n    };\n  }\n\n  /**\n   * Convert a string to a slug for use in IDs\n   */\n  private slugify(text: string): string {\n    return text\n      .toLowerCase()\n      .replace(/[^\\w\\s-]/g, '')\n      .replace(/[\\s_-]+/g, '-')\n      .replace(/^-+|-+$/g, '');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/MermaidPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/PluginLoader.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":30,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":30,"endColumn":37,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/PluginManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_filePath' is defined but never used.","line":105,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_filePath' is defined but never used.","line":109,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":109,"endColumn":73}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Plugin } from '../../types/plugin.js';\nimport { ParsedContent } from '../../types/parser.js';\nimport { logger } from './utils/logger.js';\n\nexport class PluginManager {\n  private plugins: Plugin[] = [];\n  // Flag to track if the plugin list has been modified\n\n  constructor(plugins: Plugin[] = []) {\n    this.plugins = [...plugins];\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getPlugins(): Plugin[] {\n    return this.plugins;\n  }\n\n  /**\n   * Register a new plugin\n   */\n  registerPlugin(plugin: Plugin): void {\n    this.plugins.push(plugin);\n  }\n\n  /**\n   * Initialize all plugins that have an initialize method\n   */\n  async initializePlugins(): Promise<void> {\n    for (const plugin of this.plugins) {\n      if (plugin.initialize) {\n        await plugin.initialize();\n      }\n    }\n  }\n\n  /**\n   * Execute a specific hook for all plugins\n   */\n  executeHook<T>(hookName: string, data: T, continueOnError = false): T {\n    let result = data;\n\n    for (const plugin of this.plugins) {\n      if (plugin.hooks && plugin.hooks[hookName]) {\n        try {\n          result = plugin.hooks[hookName](result, plugin.options);\n        } catch (error) {\n          if (!continueOnError) {\n            throw error;\n          }\n          logger.warn(`Error executing hook ${hookName} for plugin ${plugin.name}: ${error}`);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Execute a specific hook for a specific plugin\n   */\n  executeHookForPlugin<T>(hookName: string, pluginName: string, data: T): T {\n    const plugin = this.getPluginByName(pluginName);\n\n    if (!plugin || !plugin.hooks || !plugin.hooks[hookName]) {\n      return data;\n    }\n\n    try {\n      return plugin.hooks[hookName](data, plugin.options);\n    } catch (error) {\n      logger.error(`Error executing hook ${hookName} for plugin ${pluginName}: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get a plugin by name\n   */\n  getPluginByName(name: string): Plugin | undefined {\n    return this.plugins.find(plugin => plugin.name === name);\n  }\n\n  /**\n   * Check if a plugin exists\n   */\n  hasPlugin(name: string): boolean {\n    return this.plugins.some(plugin => plugin.name === name);\n  }\n\n  /**\n   * Remove a plugin by name\n   */\n  removePlugin(name: string): void {\n    const index = this.plugins.findIndex(plugin => plugin.name === name);\n    if (index !== -1) {\n      this.plugins.splice(index, 1);\n    }\n  }\n\n  /**\n   * Legacy methods for backward compatibility\n   */\n  async applyBeforeParse(content: string, _filePath?: string): Promise<string> {\n    return this.executeHook('beforeParse', content);\n  }\n\n  async applyAfterParse(parsedContent: ParsedContent, _filePath?: string): Promise<ParsedContent> {\n    return this.executeHook('afterParse', parsedContent);\n  }\n\n  getPlugin(name: string): Plugin | undefined {\n    return this.getPluginByName(name);\n  }\n\n  register(plugin: Plugin): void {\n    this.registerPlugin(plugin);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/PluginSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/PrismPlugin.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1758,1761],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1758,1761],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2341,2344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2341,2344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Plugin } from '../../types/plugin.js';\nimport { ParsedContent } from '../../types/parser.js';\n\nexport class PrismPlugin implements Plugin {\n  name = 'prism';\n  version = '1.0.0';\n  hooks = {\n    beforeParse: this.beforeParse.bind(this),\n    afterParse: this.afterParse.bind(this),\n  };\n  options = {\n    theme: 'default',\n    languages: ['javascript', 'typescript', 'html', 'css', 'json', 'markdown'],\n  };\n\n  async beforeParse(content: string): Promise<string> {\n    // No pre-processing needed for Prism\n    return content;\n  }\n\n  async afterParse(parsedContent: ParsedContent): Promise<ParsedContent> {\n    // Check if the content contains code blocks\n    const hasCodeBlocks = parsedContent.html && parsedContent.html.includes('<pre><code');\n\n    if (hasCodeBlocks) {\n      // Add Prism as a dependency\n      parsedContent.metadata = parsedContent.metadata || {};\n      parsedContent.metadata.dependencies = parsedContent.metadata.dependencies || [];\n\n      // Initialize dependencies array if it doesn't exist\n      if (!parsedContent.metadata.dependencies) {\n        parsedContent.metadata.dependencies = [];\n      }\n\n      // Add prism dependency if not already included\n      if (\n        !Array.isArray(parsedContent.metadata.dependencies) ||\n        !parsedContent.metadata.dependencies.includes('prism')\n      ) {\n        (parsedContent.metadata.dependencies as string[]).push('prism');\n      }\n\n      // Add initialization script for Prism\n      parsedContent.metadata.scripts = parsedContent.metadata.scripts || [];\n      // Initialize scripts array if it doesn't exist\n      if (!parsedContent.metadata.scripts) {\n        parsedContent.metadata.scripts = [];\n      }\n\n      // Add Prism script\n      (parsedContent.metadata.scripts as any[]).push({\n        type: 'text/javascript',\n        content: `\n          document.addEventListener('DOMContentLoaded', () => {\n            if (_typeof Prism !== 'undefined') {\n              Prism.highlightAll();\n            }\n          });\n        `,\n      });\n\n      // Add CSS for Prism\n      parsedContent.metadata.styles = parsedContent.metadata.styles || [];\n      // Initialize styles array if it doesn't exist\n      if (!parsedContent.metadata.styles) {\n        parsedContent.metadata.styles = [];\n      }\n\n      // Add Prism styles\n      (parsedContent.metadata.styles as any[]).push({\n        type: 'text/css',\n        href: 'https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.css',\n      });\n    }\n\n    return parsedContent;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/SiteMapGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/SyntaxHighlightPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/TableOfContentsPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/plugins/docsify-plugin.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'element' is defined but never used.","line":136,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":136,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'designSystem' is defined but never used.","line":136,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":136,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'element' is defined but never used.","line":147,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":147,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'designSystem' is defined but never used.","line":147,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":147,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'element' is defined but never used.","line":158,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":158,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'designSystem' is defined but never used.","line":158,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":158,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Plugin } from '../../types/plugin.js';\nimport { ParsedContent } from '../../types/parser.js';\nimport { ComponentTemplate } from '../../types/component.js';\n\ninterface DocsifyPluginOptions {\n  basePath?: string;\n  coverpage?: boolean;\n  navbar?: boolean;\n  sidebar?: boolean;\n  themeable?: {\n    responsiveTables: boolean;\n    readyTransition: boolean;\n  };\n}\n\nexport class DocsifyPlugin implements Plugin {\n  name = 'docsify';\n  version = '1.0.0';\n  options: DocsifyPluginOptions;\n  // Hooks are defined in the constructor\n\n  constructor(options: DocsifyPluginOptions = {}) {\n    this.options = {\n      basePath: '/',\n      coverpage: true,\n      navbar: true,\n      sidebar: true,\n      themeable: {\n        responsiveTables: true,\n        readyTransition: true,\n      },\n      ...options,\n    };\n  }\n\n  hooks = {\n    beforeParse: async (content: string): Promise<string> => {\n      // Handle docsify-specific markdown extensions\n      return this.processDocsifyMarkdown(content);\n    },\n\n    afterParse: async (parsed: ParsedContent): Promise<ParsedContent> => {\n      // Add docsify-specific metadata and structure\n      return parsed;\n    },\n\n    beforeGenerate: async (components: ComponentTemplate[]): Promise<ComponentTemplate[]> => {\n      // Add docsify-specific components and styling\n      return this.addDocsifyComponents(components);\n    },\n  };\n\n  private processDocsifyMarkdown(content: string): string {\n    // Process docsify-specific markdown features\n    content = this.processEmbeds(content);\n    content = this.processAlerts(content);\n    content = this.processCodeTabs(content);\n    return content;\n  }\n\n  private processEmbeds(content: string): string {\n    // Handle [!embed] syntax\n    return content.replace(/\\[!embed\\]\\((.*?)\\)/g, (_match, url) => {\n      return `<div class=\"embed-container\">\n        <iframe src=\"${url}\" frameborder=\"0\" allowfullscreen></iframe>\n      </div>`;\n    });\n  }\n\n  private processAlerts(content: string): string {\n    // Handle docsify alert blocks\n    const alertTypes = ['info', 'tip', 'warning', 'danger'];\n    alertTypes.forEach(type => {\n      const regex = new RegExp(`> \\\\[!${type}\\\\]\\\\n([\\\\s\\\\S]*?)(?=\\\\n(?:>|$))`, 'g');\n      content = content.replace(regex, (_match, text) => {\n        return `<div class=\"alert alert-${type}\">${text.trim()}</div>`;\n      });\n    });\n    return content;\n  }\n\n  private processCodeTabs(content: string): string {\n    // Handle code tabs syntax\n    return content.replace(/```tabs([\\\\s\\\\S]*?)```/g, (_match, content) => {\n      const tabs = content.split('====').map((tab: string) => tab.trim());\n      return this.generateCodeTabsHTML(tabs);\n    });\n  }\n\n  private generateCodeTabsHTML(tabs: string[]): string {\n    const tabButtons = tabs\n      .map((tab, index) => {\n        const title = tab.split('\\n')[0];\n        return `<button class=\"tab-button${\n          index === 0 ? ' active' : ''\n        }\" data-tab=\"${index}\">${title}</button>`;\n      })\n      .join('');\n\n    const tabContents = tabs\n      .map((tab, index) => {\n        const content = tab.split('\\n').slice(1).join('\\n');\n        return `<div class=\"tab-content${\n          index === 0 ? ' active' : ''\n        }\" data-tab=\"${index}\">${content}</div>`;\n      })\n      .join('');\n\n    return `<div class=\"tabs-container\">\n      <div class=\"tab-buttons\">${tabButtons}</div>\n      <div class=\"tab-contents\">${tabContents}</div>\n    </div>`;\n  }\n\n  private addDocsifyComponents(components: ComponentTemplate[]): ComponentTemplate[] {\n    // Add docsify-specific components (navbar, sidebar, etc.)\n    if (this.options.navbar) {\n      components.unshift(this.createNavbarComponent());\n    }\n    if (this.options.sidebar) {\n      components.unshift(this.createSidebarComponent());\n    }\n    if (this.options.coverpage) {\n      components.unshift(this.createCoverpageComponent());\n    }\n    return components;\n  }\n\n  private createNavbarComponent(): ComponentTemplate {\n    return {\n      name: 'navbar',\n      path: 'components/navbar.html',\n      type: 'navbar',\n      content: '<nav class=\"app-nav\"></nav>',\n      metadata: { docsify: true },\n      generate: async (element, designSystem) => '<nav class=\"app-nav\"></nav>',\n    };\n  }\n\n  private createSidebarComponent(): ComponentTemplate {\n    return {\n      name: 'sidebar',\n      path: 'components/sidebar.html',\n      type: 'sidebar',\n      content: '<aside class=\"sidebar\"></aside>',\n      metadata: { docsify: true },\n      generate: async (element, designSystem) => '<aside class=\"sidebar\"></aside>',\n    };\n  }\n\n  private createCoverpageComponent(): ComponentTemplate {\n    return {\n      name: 'coverpage',\n      path: 'components/coverpage.html',\n      type: 'coverpage',\n      content: '<section class=\"cover show\"></section>',\n      metadata: { docsify: true },\n      generate: async (element, designSystem) => '<section class=\"cover show\"></section>',\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/services/BaseService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/services/ParserService.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":168,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":168,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseService } from './BaseService.js';\nimport { ContentCache, CacheOptions } from '../utils/cache.js';\nimport { ParserError } from '../utils/errors.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { logger } from './utils/logger.js';\n\n/**\n * Parser service configuration\n */\nexport interface ParserServiceConfig {\n  extensions: string[];\n  ignorePatterns: string[];\n  plugins?: string[];\n  caching?: CacheOptions;\n}\n\n/**\n * Parser result\n */\nexport interface ParseResult {\n  content: Record<string, unknown>;\n  metadata: {\n    filePath: string;\n    lastModified: number;\n    size: number;\n  };\n}\n\n/**\n * Parser service for parsing documentation files\n */\nexport class ParserService extends BaseService {\n  private config: ParserServiceConfig;\n  private cache: ContentCache<ParseResult>;\n  private parsers: Map<string, (content: string, filePath: string) => Record<string, unknown>>;\n\n  constructor(config: ParserServiceConfig) {\n    super('parser-service');\n\n    // Create config with defaults that will be overridden by any values in config\n    this.config = {\n      ...{\n        extensions: ['md', 'markdown'],\n        ignorePatterns: ['node_modules', '.git'],\n      },\n      ...config,\n    };\n\n    this.parsers = new Map();\n\n    // Initialize cache\n    this.cache = new ContentCache<ParseResult>(\n      this.config.caching || {\n        enabled: true,\n        storageType: 'memory',\n      }\n    );\n  }\n\n  /**\n   * Start the parser service\n   */\n  protected async doStart(): Promise<void> {\n    // Register default parsers\n    this.registerParser('md', this.parseMarkdown.bind(this));\n    this.registerParser('markdown', this.parseMarkdown.bind(this));\n\n    // Load plugins if specified\n    if (this.config.plugins && this.config.plugins.length > 0) {\n      for (const plugin of this.config.plugins) {\n        try {\n          // In a real implementation, this would dynamically load plugins\n          logger.debug(`Loading plugin: ${plugin}`);\n        } catch (error) {\n          throw new ParserError(`Failed to load plugin: ${plugin}`, {\n            plugin,\n            error,\n          });\n        }\n      }\n    }\n\n    this.setMetric('parsers', this.parsers.size);\n  }\n\n  /**\n   * Stop the parser service\n   */\n  protected async doStop(): Promise<void> {\n    // Clean up resources\n    this.parsers.clear();\n  }\n\n  /**\n   * Register a parser for a file extension\n   */\n  registerParser(\n    extension: string,\n    parser: (content: string, filePath: string) => Record<string, unknown>\n  ): void {\n    this.parsers.set(extension.toLowerCase(), parser);\n    this.setMetric('parsers', this.parsers.size);\n  }\n\n  /**\n   * Parse a file\n   */\n  async parseFile(filePath: string): Promise<ParseResult> {\n    if (!this.isRunning()) {\n      throw new ParserError('Parser service is not running', {\n        filePath,\n        status: this.getStatus(),\n      });\n    }\n\n    // Check if file exists\n    if (!fs.existsSync(filePath)) {\n      throw new ParserError(`File not found: ${filePath}`, {\n        filePath,\n      });\n    }\n\n    // Get file stats\n    const stats = fs.statSync(filePath);\n\n    // Check if it's a directory\n    if (stats.isDirectory()) {\n      throw new ParserError(`Cannot parse a directory: ${filePath}`, {\n        filePath,\n      });\n    }\n\n    // Check if the file is in the ignore patterns\n    for (const pattern of this.config.ignorePatterns) {\n      if (filePath.includes(pattern)) {\n        throw new ParserError(`File is in ignore pattern: ${filePath}`, {\n          filePath,\n          pattern,\n        });\n      }\n    }\n\n    // Get file extension\n    const extension = path.extname(filePath).slice(1).toLowerCase();\n\n    // Check if we have a parser for this extension\n    if (!this.parsers.has(extension)) {\n      throw new ParserError(`No parser registered for extension: ${extension}`, {\n        filePath,\n        extension,\n      });\n    }\n\n    // Check cache first\n    const cacheKey = `${filePath}:${stats.mtimeMs}`;\n    const cachedResult = this.cache.get(cacheKey);\n\n    if (cachedResult) {\n      this.incrementMetric('cache_hits');\n      return cachedResult;\n    }\n\n    // Read file content\n    const content = fs.readFileSync(filePath, 'utf-8');\n\n    // Parse the content\n    const parser = this.parsers.get(extension)!;\n\n    try {\n      const parsedContent = parser(content, filePath);\n\n      const result: ParseResult = {\n        content: parsedContent,\n        metadata: {\n          filePath,\n          lastModified: stats.mtimeMs,\n          size: stats.size,\n        },\n      };\n\n      // Cache the result\n      this.cache.set(cacheKey, result);\n\n      this.incrementMetric('files_parsed');\n      this.incrementMetric('cache_misses');\n\n      return result;\n    } catch (error) {\n      throw new ParserError(`Failed to parse file: ${filePath}`, {\n        filePath,\n        extension,\n        error,\n      });\n    }\n  }\n\n  /**\n   * Parse a directory recursively\n   */\n  async parseDirectory(dirPath: string): Promise<ParseResult[]> {\n    if (!this.isRunning()) {\n      throw new ParserError('Parser service is not running', {\n        dirPath,\n        status: this.getStatus(),\n      });\n    }\n\n    // Check if directory exists\n    if (!fs.existsSync(dirPath)) {\n      throw new ParserError(`Directory not found: ${dirPath}`, {\n        dirPath,\n      });\n    }\n\n    // Check if it's a directory\n    const stats = fs.statSync(dirPath);\n    if (!stats.isDirectory()) {\n      throw new ParserError(`Not a directory: ${dirPath}`, {\n        dirPath,\n      });\n    }\n\n    const results: ParseResult[] = [];\n\n    // Read directory contents\n    const files = fs.readdirSync(dirPath);\n\n    for (const file of files) {\n      const filePath = path.join(dirPath, file);\n      const fileStats = fs.statSync(filePath);\n\n      // Skip ignored patterns\n      let ignored = false;\n      for (const pattern of this.config.ignorePatterns) {\n        if (filePath.includes(pattern)) {\n          ignored = true;\n          break;\n        }\n      }\n\n      if (ignored) {\n        continue;\n      }\n\n      if (fileStats.isDirectory()) {\n        // Recursively parse subdirectory\n        const subResults = await this.parseDirectory(filePath);\n        results.push(...subResults);\n      } else {\n        // Get file extension\n        const extension = path.extname(file).slice(1).toLowerCase();\n\n        // Check if we have a parser for this extension\n        if (this.parsers.has(extension)) {\n          try {\n            const result = await this.parseFile(filePath);\n            results.push(result);\n          } catch (error) {\n            // Log error but continue with other files\n            logger.error(`Error parsing file ${filePath}:`, error);\n          }\n        }\n      }\n    }\n\n    this.incrementMetric('directories_parsed');\n\n    return results;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): Record<string, unknown> {\n    return this.cache.getStats();\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n    this.setMetric('cache_hits', 0);\n    this.setMetric('cache_misses', 0);\n  }\n\n  /**\n   * Parse Markdown content\n   * This is a simple implementation - in a real app, you'd use a proper Markdown parser\n   */\n  private parseMarkdown(content: string, filePath: string): Record<string, unknown> {\n    // Extract front matter if present\n    let metadata = {};\n    let mainContent = content;\n\n    const frontMatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n\n    if (frontMatterMatch) {\n      try {\n        metadata = JSON.parse(`{${frontMatterMatch[1]}}`);\n        mainContent = frontMatterMatch[2];\n      } catch (error) {\n        // If parsing fails, assume no front matter\n      }\n    }\n\n    // Extract title from first heading\n    const titleMatch = mainContent.match(/^#\\s+(.*)$/m);\n    const title = titleMatch ? titleMatch[1] : path.basename(filePath, path.extname(filePath));\n\n    // Extract sections\n    const sections = [];\n    const sectionMatches = mainContent.matchAll(/^(#{2,6})\\s+(.*)$/gm);\n\n    for (const match of sectionMatches) {\n      sections.push({\n        level: match[1].length,\n        title: match[2],\n      });\n    }\n\n    return {\n      title,\n      metadata,\n      content: mainContent,\n      sections,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/EjsTemplateEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":3,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2258,2261],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2258,2261],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TemplateEngine, TemplateEngineOptions } from './TemplateEngine.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as ejs from 'ejs';\nimport { FileSystemError } from '../utils/errors.js';\nimport { tryCatch } from '../utils/errors.js';\n\n/**\n * Interface for EJS template engine options\n */\nexport interface EjsTemplateEngineOptions extends TemplateEngineOptions {\n  /**\n   * Path to the includes directory\n   */\n  includesDir?: string;\n\n  /**\n   * Whether to use strict mode\n   */\n  strict?: boolean;\n\n  /**\n   * Whether to use async rendering\n   */\n  async?: boolean;\n\n  /**\n   * EJS options\n   */\n  ejsOptions?: ejs.Options;\n}\n\n/**\n * EJS template engine implementation\n */\nexport class EjsTemplateEngine extends TemplateEngine {\n  protected options: EjsTemplateEngineOptions;\n\n  constructor(options: EjsTemplateEngineOptions = {}) {\n    super(options);\n    this.options = {\n      ...options,\n      ejsOptions: {\n        async: options.async || false,\n        cache: options.cacheSize && options.cacheSize > 0,\n        ...options.ejsOptions,\n      },\n    };\n\n    // Initialize the template engine\n    this.initialize();\n  }\n\n  /**\n   * Initialize the template engine\n   */\n  private async initialize(): Promise<void> {\n    // Set up includes directory if provided\n    if (this.options.includesDir) {\n      this.options.ejsOptions = {\n        ...this.options.ejsOptions,\n        views: [this.options.includesDir],\n      };\n    }\n  }\n\n  /**\n   * Load a template from the given path\n   * @param templatePath Path to the template file\n   * @returns The loaded template\n   */\n  protected async loadTemplate(templatePath: string): Promise<string> {\n    if (!templatePath || typeof templatePath !== 'string') {\n      throw new Error('Template path must be a non-empty string');\n    }\n\n    // Check if the template is already cached\n    if (this.templateCache.has(templatePath)) {\n      const cached = this.templateCache.get(templatePath);\n      if (typeof cached === 'string') {\n        return cached;\n      }\n      throw new Error(`Invalid cached template type for ${templatePath}`);\n    }\n\n    // Read the template file\n    const templateContent = await tryCatch(\n      () => fs.promises.readFile(templatePath, 'utf-8'),\n      (error: any) => {\n        throw new FileSystemError(`Failed to read template file: ${templatePath}`, {\n          path: templatePath,\n          operation: 'read',\n          cause: error,\n        });\n      }\n    );\n\n    // Cache the template if caching is enabled\n    if (this.options.cacheSize && this.options.cacheSize > 0) {\n      // Limit the cache size\n      if (this.templateCache.size >= this.options.cacheSize) {\n        // Remove the oldest entry\n        const firstKey = this.templateCache.keys().next().value;\n        this.templateCache.delete(firstKey);\n      }\n\n      // Add the template to the cache\n      this.templateCache.set(templatePath, templateContent);\n    }\n\n    return templateContent;\n  }\n\n  /**\n   * Render a template with the given data\n   * @param template The template to render\n   * @param data Data to render the template with\n   * @returns The rendered template\n   */\n  protected async renderTemplate(template: string, data: Record<string, unknown>): Promise<string> {\n    if (!template || typeof template !== 'string') {\n      throw new Error('Template must be a non-empty string');\n    }\n\n    // Set up the EJS options\n    const ejsOptions: ejs.Options = {\n      ...this.options.ejsOptions,\n      filename: data.filename && typeof data.filename === 'string' ? data.filename : undefined,\n    };\n\n    // Render the template\n    let rendered: string;\n\n    if (this.options.async) {\n      // Use async rendering\n      rendered = await ejs.render(template, data, ejsOptions);\n    } else {\n      // Use sync rendering\n      if (!ejsOptions.filename) {\n        throw new Error('Filename is required for synchronous EJS rendering');\n      }\n      rendered = await ejs.render(template, data, ejsOptions);\n    }\n\n    // Minify the output if enabled\n    if (this.options.minify) {\n      return this.minifyHtml(rendered);\n    }\n\n    return rendered;\n  }\n\n  /**\n   * Minify HTML content\n   * @param html HTML content to minify\n   * @returns Minified HTML content\n   */\n  private minifyHtml(html: string): string {\n    // Simple minification (just for demonstration)\n    // In a real implementation, you would use a proper HTML minifier\n    return html\n      .replace(/\\s+/g, ' ')\n      .replace(/>\\s+</g, '><')\n      .replace(/\\s+>/g, '>')\n      .replace(/<\\s+/g, '<')\n      .trim();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/HandlebarsTemplateEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6366,6369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6366,6369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TemplateEngine, TemplateEngineOptions } from './TemplateEngine.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as Handlebars from 'handlebars';\nimport { FileSystemError } from '../utils/errors.js';\nimport { tryCatch } from '../utils/errors.js';\n\n/**\n * Interface for Handlebars template engine options\n */\nexport interface HandlebarsTemplateEngineOptions extends TemplateEngineOptions {\n  /**\n   * Path to the partials directory\n   */\n  partialsDir?: string;\n\n  /**\n   * Path to the helpers directory\n   */\n  helpersDir?: string;\n\n  /**\n   * Whether to use strict mode\n   */\n  strict?: boolean;\n}\n\n/**\n * Handlebars template engine implementation\n */\nexport class HandlebarsTemplateEngine extends TemplateEngine {\n  private handlebars: typeof Handlebars;\n  protected options: HandlebarsTemplateEngineOptions;\n\n  constructor(options: HandlebarsTemplateEngineOptions = {}) {\n    super(options);\n    this.options = options;\n    this.handlebars = Handlebars.create();\n\n    // Set strict mode if enabled\n    if (options.strict) {\n      this.handlebars.registerHelper(\n        'blockHelperMissing',\n        (_context: unknown, options: Handlebars.HelperOptions & { name?: string }) => {\n          throw new Error(`Missing helper: ${options.name || 'unknown'}`);\n        }\n      );\n    }\n\n    // Initialize the template engine\n    this.initialize();\n  }\n\n  /**\n   * Initialize the template engine\n   */\n  private async initialize(): Promise<void> {\n    // Register built-in helpers\n    this.registerBuiltInHelpers();\n\n    // Register custom helpers if helpersDir is provided\n    if (this.options.helpersDir) {\n      await this.registerHelpers(this.options.helpersDir);\n    }\n\n    // Register partials if partialsDir is provided\n    if (this.options.partialsDir) {\n      await this.registerPartials(this.options.partialsDir);\n    }\n  }\n\n  /**\n   * Register built-in helpers\n   */\n  private registerBuiltInHelpers(): void {\n    // Format date helper\n    this.handlebars.registerHelper('formatDate', (date: Date, format: string) => {\n      if (!date) return '';\n\n      const d = new Date(date);\n\n      // Simple format implementation\n      switch (format) {\n        case 'YYYY-MM-DD':\n          return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(\n            d.getDate()\n          ).padStart(2, '0')}`;\n        case 'MM/DD/YYYY':\n          return `${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getDate()).padStart(\n            2,\n            '0'\n          )}/${d.getFullYear()}`;\n        case 'DD/MM/YYYY':\n          return `${String(d.getDate()).padStart(2, '0')}/\n            ${String(d.getMonth() + 1).padStart(2, '0')}/\n            ${d.getFullYear()}`;\n        default:\n          return d.toLocaleDateString();\n      }\n    });\n\n    // Markdown helper\n    this.handlebars.registerHelper('markdown', (content: string) => {\n      if (!content) return '';\n\n      // Simple markdown implementation (just for demonstration)\n      // In a real implementation, you would use a markdown parser\n      return content\n        .replace(/^# (.+)$/gm, '<h1>$1</h1>')\n        .replace(/^## (.+)$/gm, '<h2>$1</h2>')\n        .replace(/^### (.+)$/gm, '<h3>$1</h3>')\n        .replace(/\\*\\*(.+?)\\*\\*/g, '<strong>$1</strong>')\n        .replace(/\\*(.+?)\\*/g, '<em>$1</em>')\n        .replace(/\\n\\n/g, '</p><p>');\n    });\n\n    // Equals helper\n    this.handlebars.registerHelper(\n      'eq',\n      function (this: unknown, a: unknown, b: unknown, options: Handlebars.HelperOptions) {\n        if (typeof a !== typeof b) return options.inverse(this);\n        return a === b ? options.fn(this) : options.inverse(this);\n      }\n    );\n\n    // Not equals helper\n    this.handlebars.registerHelper(\n      'neq',\n      function (this: unknown, a: unknown, b: unknown, options: Handlebars.HelperOptions) {\n        if (typeof a !== typeof b) return options.inverse(this);\n        return a !== b ? options.fn(this) : options.inverse(this);\n      }\n    );\n\n    // Greater than helper\n    this.handlebars.registerHelper(\n      'gt',\n      function (this: unknown, a: unknown, b: unknown, options: Handlebars.HelperOptions) {\n        if (typeof a !== 'number' || typeof b !== 'number') return options.inverse(this);\n        return a > b ? options.fn(this) : options.inverse(this);\n      }\n    );\n\n    // Less than helper\n    this.handlebars.registerHelper(\n      'lt',\n      function (this: unknown, a: unknown, b: unknown, options: Handlebars.HelperOptions) {\n        if (typeof a !== 'number' || typeof b !== 'number') return options.inverse(this);\n        return a < b ? options.fn(this) : options.inverse(this);\n      }\n    );\n\n    // JSON stringify helper\n    this.handlebars.registerHelper('json', function (obj: unknown) {\n      return typeof obj === 'object' && obj !== null ? JSON.stringify(obj, null, 2) : String(obj);\n    });\n  }\n\n  /**\n   * Register custom helpers from a directory\n   * @param helpersDir Path to the helpers directory\n   */\n  private async registerHelpers(helpersDir: string): Promise<void> {\n    await tryCatch(async () => {\n      // Check if the helpers directory exists\n      if (!fs.existsSync(helpersDir)) {\n        throw new FileSystemError(`Helpers directory does not exist: ${helpersDir}`, {\n          path: helpersDir,\n          operation: 'read',\n        });\n      }\n\n      // Read the helpers directory\n      const files = await fs.promises.readdir(helpersDir);\n\n      // Register each helper\n      for (const file of files) {\n        if (file.endsWith('.js') || file.endsWith('.ts')) {\n          const helperPath = path.join(helpersDir, file);\n          const helperModule = await import(helperPath);\n          const helper = typeof helperModule === 'function' ? helperModule : helperModule.default;\n\n          // Register the helper\n          if (typeof helper === 'function') {\n            const helperName = path.basename(file, path.extname(file));\n            this.handlebars.registerHelper(helperName, (context?: unknown, ...args: unknown[]) => {\n              return helper(context, ...args);\n            });\n          } else if (typeof helper === 'object') {\n            // Register multiple helpers from a single file\n            for (const [name, fn] of Object.entries(helper)) {\n              if (typeof fn === 'function') {\n                this.handlebars.registerHelper(name, (...args: any[]) => fn(...args));\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Register partials from a directory\n   * @param partialsDir Path to the partials directory\n   */\n  private async registerPartials(partialsDir: string): Promise<void> {\n    await tryCatch(async () => {\n      // Check if the partials directory exists\n      if (!fs.existsSync(partialsDir)) {\n        throw new FileSystemError(`Partials directory does not exist: ${partialsDir}`, {\n          path: partialsDir,\n          operation: 'read',\n        });\n      }\n\n      // Read the partials directory\n      const files = await fs.promises.readdir(partialsDir);\n\n      // Register each partial\n      for (const file of files) {\n        if (file.endsWith('.hbs') || file.endsWith('.handlebars')) {\n          const partialPath = path.join(partialsDir, file);\n          const partialName = path.basename(file, path.extname(file));\n\n          // Read the partial content\n          const partialContent = await fs.promises.readFile(partialPath, 'utf8');\n\n          // Register the partial\n          this.handlebars.registerPartial(partialName, partialContent);\n        }\n      }\n    });\n  }\n\n  /**\n   * Load a template from the given path\n   * @param templatePath Path to the template file\n   * @returns The loaded template\n   */\n  protected async loadTemplate(templatePath: string): Promise<Handlebars.TemplateDelegate> {\n    // Check if the template is already cached\n    if (this.templateCache.has(templatePath)) {\n      return this.templateCache.get(templatePath) as Handlebars.TemplateDelegate;\n    }\n\n    // Read the template file\n    if (!templatePath) throw new Error('Template path is required');\n    if (!templatePath) throw new Error('Template path is required');\n    const templateContent = await tryCatch(\n      () => fs.promises.readFile(templatePath, 'utf8'),\n      (error: unknown) => {\n        throw new FileSystemError(`Failed to read template file: ${templatePath}`, {\n          path: templatePath,\n          operation: 'read',\n          cause: error instanceof Error ? error : new Error(String(error)),\n        });\n      }\n    );\n\n    // Compile the template\n    const template = this.handlebars.compile(templateContent, {\n      strict: this.options.strict,\n    });\n\n    // Cache the template if caching is enabled\n    if (this.options.cacheSize && this.options.cacheSize > 0) {\n      // Limit the cache size\n      if (this.templateCache.size >= this.options.cacheSize) {\n        // Remove the oldest entry\n        const firstKey = this.templateCache.keys().next().value;\n        if (firstKey) {\n          this.templateCache.delete(firstKey);\n        }\n      }\n\n      // Add the template to the cache\n      this.templateCache.set(templatePath, template);\n    }\n\n    return template;\n  }\n\n  /**\n   * Render a template with the given data\n   * @param template The template to render\n   * @param data Data to render the template with\n   * @returns The rendered template\n   */\n  protected async renderTemplate(\n    template: Handlebars.TemplateDelegate,\n    data: Record<string, unknown>\n  ): Promise<string> {\n    // Render the template\n    const rendered = template(data);\n\n    // Minify the output if enabled\n    if (this.options.minify) {\n      return this.minifyHtml(rendered);\n    }\n\n    return rendered;\n  }\n\n  /**\n   * Minify HTML content\n   * @param html HTML content to minify\n   * @returns Minified HTML content\n   */\n  private minifyHtml(html: string): string {\n    // Simple minification (just for demonstration)\n    // In a real implementation, you would use a proper HTML minifier\n    return html\n      .replace(/\\s+/g, ' ')\n      .replace(/>\\s+</g, '><')\n      .replace(/\\s+>/g, '>')\n      .replace(/<\\s+/g, '<')\n      .trim();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/TemplateEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/TemplateManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TemplateEngineOptions' is defined but never used.","line":1,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":47},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":1,"message":"Forbidden non-null assertion.","line":64,"column":29,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":64,"endColumn":60}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TemplateEngine, TemplateEngineOptions } from './TemplateEngine.js';\nimport {\n  HandlebarsTemplateEngine,\n  HandlebarsTemplateEngineOptions,\n} from './HandlebarsTemplateEngine.js';\nimport { EjsTemplateEngine, EjsTemplateEngineOptions } from './EjsTemplateEngine.js';\nimport { ParsedContent } from '../../types/parser.js';\nimport { DesignSystem } from '../../types/design.js';\nimport * as path from 'path';\nimport { TemplateError } from '../utils/errors.js';\n\n/**\n * Type of template engine\n */\nexport type TemplateEngineType = 'handlebars' | 'ejs' | 'custom';\n\n/**\n * Interface for template manager options\n */\nexport interface TemplateManagerOptions {\n  /**\n   * The default template engine to use\n   */\n  defaultEngine?: TemplateEngineType;\n\n  /**\n   * Options for the Handlebars template engine\n   */\n  handlebarsOptions?: HandlebarsTemplateEngineOptions;\n\n  /**\n   * Options for the EJS template engine\n   */\n  ejsOptions?: EjsTemplateEngineOptions;\n\n  /**\n   * Custom template engines\n   */\n  customEngines?: Record<string, TemplateEngine>;\n}\n\n/**\n * Template manager for handling different template engines\n */\nexport class TemplateManager {\n  private engines: Map<string, TemplateEngine>;\n  private defaultEngine: TemplateEngineType;\n\n  constructor(options: TemplateManagerOptions = {}) {\n    this.engines = new Map();\n    this.defaultEngine = options.defaultEngine || 'handlebars';\n\n    // Initialize the template engines\n    this.initializeEngines(options);\n  }\n\n  /**\n   * Initialize the template engines\n   * @param options Template manager options\n   */\n  private initializeEngines(options: TemplateManagerOptions): void {\n    // Initialize the Handlebars template engine\n    this.engines.set('handlebars', new HandlebarsTemplateEngine(options.handlebarsOptions));\n    this.engines.set('hbs', this.engines.get('handlebars')!);\n\n    // Initialize the EJS template engine\n    this.engines.set('ejs', new EjsTemplateEngine(options.ejsOptions));\n\n    // Initialize custom template engines\n    if (options.customEngines) {\n      for (const [name, engine] of Object.entries(options.customEngines)) {\n        this.engines.set(name, engine);\n      }\n    }\n  }\n\n  /**\n   * Register a custom template engine\n   * @param name Name of the template engine\n   * @param engine The template engine instance\n   */\n  registerEngine(name: string, engine: TemplateEngine): void {\n    this.engines.set(name, engine);\n  }\n\n  /**\n   * Get a template engine by name\n   * @param name Name of the template engine\n   * @returns The template engine instance\n   */\n  getEngine(name?: string): TemplateEngine {\n    // If no name is provided, use the default engine\n    const engineName = name || this.defaultEngine;\n\n    // Get the template engine\n    const engine = this.engines.get(engineName);\n    if (!engine) {\n      throw new TemplateError(`Template engine not found: ${engineName}`);\n    }\n\n    return engine;\n  }\n\n  /**\n   * Render a template with the given data\n   * @param templatePath Path to the template file\n   * @param data Data to render the template with\n   * @param engineName Optional name of the template engine to use\n   * @returns The rendered template\n   */\n  async render(\n    templatePath: string,\n    data: Record<string, unknown>,\n    engineName?: string\n  ): Promise<string> {\n    // If no engine name is provided, infer it from the template file extension\n    const inferredEngineName = engineName || this.inferEngineFromPath(templatePath);\n\n    // Get the template engine\n    const engine = this.getEngine(inferredEngineName);\n\n    // Render the template\n    return await engine.render(templatePath, data);\n  }\n\n  /**\n   * Render content with the given template\n   * @param content The parsed content to render\n   * @param templatePath Path to the template file\n   * @param designSystem Optional design system to apply\n   * @param engineName Optional name of the template engine to use\n   * @returns The rendered content\n   */\n  async renderContent(\n    content: ParsedContent,\n    templatePath: string,\n    designSystem?: DesignSystem,\n    engineName?: string\n  ): Promise<string> {\n    // If no engine name is provided, infer it from the template file extension\n    const inferredEngineName = engineName || this.inferEngineFromPath(templatePath);\n\n    // Get the template engine\n    const engine = this.getEngine(inferredEngineName);\n\n    // Render the content\n    return await engine.renderContent(content, templatePath, designSystem);\n  }\n\n  /**\n   * Clear the template cache for all engines\n   */\n  clearCache(): void {\n    for (const engine of this.engines.values()) {\n      engine.clearCache();\n    }\n  }\n\n  /**\n   * Infer the template engine from the template file path\n   * @param templatePath Path to the template file\n   * @returns The inferred template engine name\n   */\n  private inferEngineFromPath(templatePath: string): string {\n    const extension = path.extname(templatePath).toLowerCase();\n\n    switch (extension) {\n      case '.hbs':\n      case '.handlebars':\n        return 'handlebars';\n      case '.ejs':\n        return 'ejs';\n      default:\n        return this.defaultEngine;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/docsify-templates.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'designSystem' is defined but never used.","line":37,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'designSystem' is defined but never used.","line":70,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":70,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'designSystem' is defined but never used.","line":165,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":165,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentTemplate } from '../../types/component.js';\nimport { DesignSystem } from '../../types/design.js';\nimport { ContentElement } from '../../types/cms.js';\n\nexport class DocsifyTemplateManager {\n  private designSystem: DesignSystem;\n\n  constructor(designSystem: DesignSystem) {\n    this.designSystem = designSystem;\n  }\n\n  public getTemplate(type: string): ComponentTemplate {\n    switch (type) {\n      case 'markdown':\n        return new MarkdownTemplate(this.designSystem);\n      case 'api':\n        return new APITemplate(this.designSystem);\n      case 'code':\n        return new CodeTemplate(this.designSystem);\n      default:\n        throw new Error(`Template type '${type}' not supported`);\n    }\n  }\n}\n\nclass MarkdownTemplate implements ComponentTemplate {\n  name = 'markdown-template';\n  path = 'templates/markdown.html';\n  content = '';\n  type = 'markdown';\n  private designSystem: DesignSystem;\n\n  constructor(designSystem: DesignSystem) {\n    this.designSystem = designSystem;\n  }\n\n  async generate(element: ContentElement, designSystem: DesignSystem): Promise<string> {\n    const content = element as unknown as { title?: string; body: string };\n    const { title, body } = content;\n    return `\n      <div class=\"markdown-section ${this.designSystem.classNames?.markdownContainer || ''}\">\n        ${title ? `<h1>${title}</h1>` : ''}\n        <div class=\"markdown-body\">\n          ${this.processMarkdownContent(body)}\n        </div>\n      </div>\n    `;\n  }\n\n  private processMarkdownContent(content: string): string {\n    // Apply design system styles to markdown elements\n    return content.replace(\n      /<h([1-6])>/g,\n      (_, level) => `<h${level} class=\"${this.designSystem.classNames?.[`heading${level}`] || ''}\">`\n    );\n  }\n}\n\nclass APITemplate implements ComponentTemplate {\n  name = 'api-template';\n  path = 'templates/api.html';\n  content = '';\n  type = 'api';\n  private designSystem: DesignSystem;\n\n  constructor(designSystem: DesignSystem) {\n    this.designSystem = designSystem;\n  }\n\n  async generate(element: ContentElement, designSystem: DesignSystem): Promise<string> {\n    const content = element as unknown as {\n      method: string;\n      endpoint: string;\n      parameters?: Array<{ name: string; type: string; description: string }>;\n      responses?: Record<string, { description: string; example?: unknown }>;\n    };\n    const { method, endpoint, parameters, responses } = content;\n    return `\n      <div class=\"api-section ${this.designSystem.classNames?.apiContainer || ''}\">\n        <div class=\"api-method ${method.toLowerCase()}\">\n          <span class=\"method\">${method}</span>\n          <span class=\"endpoint\">${endpoint}</span>\n        </div>\n        ${this.generateParameters(parameters)}\n        ${this.generateResponses(responses)}\n      </div>\n    `;\n  }\n\n  private generateParameters(\n    parameters?: Array<{ name: string; type: string; description: string }>\n  ): string {\n    if (!parameters?.length) return '';\n    return `\n      <div class=\"parameters\">\n        <h3>Parameters</h3>\n        <table class=\"${this.designSystem.classNames?.table || ''}\">\n          <thead>\n            <tr>\n              <th>Name</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            ${parameters\n              .map(\n                param => `\n              <tr>\n                <td>${param.name}</td>\n                <td>${param.type}</td>\n                <td>${param.description}</td>\n              </tr>\n            `\n              )\n              .join('')}\n          </tbody>\n        </table>\n      </div>\n    `;\n  }\n\n  private generateResponses(\n    responses?: Record<string, { description: string; example?: unknown }>\n  ): string {\n    if (!responses) return '';\n    return `\n      <div class=\"responses\">\n        <h3>Responses</h3>\n        ${Object.entries(responses)\n          .map(\n            ([code, response]: [string, { description: string; example?: unknown }]) => `\n          <div class=\"response-code\">\n            <span class=\"code\">${code}</span>\n            <span class=\"description\">${response.description}</span>\n          </div>\n          ${\n            response.example\n              ? `\n            <pre><code class=\"language-json\">\n              ${JSON.stringify(response.example, null, 2)}\n            </code></pre>\n          `\n              : ''\n          }\n        `\n          )\n          .join('')}\n      </div>\n    `;\n  }\n}\n\nclass CodeTemplate implements ComponentTemplate {\n  name = 'code-template';\n  path = 'templates/code.html';\n  content = '';\n  type = 'code';\n  private designSystem: DesignSystem;\n\n  constructor(designSystem: DesignSystem) {\n    this.designSystem = designSystem;\n  }\n\n  async generate(element: ContentElement, designSystem: DesignSystem): Promise<string> {\n    const content = element as unknown as { language: string; code: string; filename?: string };\n    const { language, code, filename } = content;\n    return `\n      <div class=\"code-section ${this.designSystem.classNames?.codeContainer || ''}\">\n        ${filename ? `<div class=\"filename\">${filename}</div>` : ''}\n        <pre><code class=\"language-${language}\">\n          ${this.escapeHtml(code)}\n        </code></pre>\n      </div>\n    `;\n  }\n\n  private escapeHtml(str: string): string {\n    const escapeMap: { [key: string]: string } = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#039;',\n    };\n    return str.replace(/[&<>\"']/g, m => escapeMap[m]);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/templates/helpers/component-helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/themes/DocsifyThemeAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/themes/docsify-theme-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/tools/plugin-docs-generator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2198,2201],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2198,2201],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2252,2255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2252,2255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2332,2335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2332,2335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2398,2401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2398,2401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2445,2448],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2445,2448],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as fs from 'fs';\nimport * as path from 'path';\nimport { Plugin } from '../types/plugin.js';\n\ninterface PluginDocumentation {\n  name: string;\n  description: string;\n  hooks: string[];\n  options: {\n    name: string;\n    type: string;\n    description: string;\n    required: boolean;\n    default?: string;\n  }[];\n  examples: string[];\n}\n\nexport class PluginDocsGenerator {\n  private plugins: Plugin[] = [];\n  private outputDir: string;\n\n  constructor(outputDir: string) {\n    this.outputDir = outputDir;\n  }\n\n  /**\n   * Add a plugin to document\n   */\n  addPlugin(plugin: Plugin): void {\n    this.plugins.push(plugin);\n  }\n\n  /**\n   * Generate documentation for all plugins\n   */\n  async generateDocs(): Promise<void> {\n    // Create output directory if it doesn't exist\n    if (!fs.existsSync(this.outputDir)) {\n      fs.mkdirSync(this.outputDir, { recursive: true });\n    }\n\n    // Generate index file\n    await this.generateIndexFile();\n\n    // Generate docs for each plugin\n    for (const plugin of this.plugins) {\n      await this.generatePluginDoc(plugin);\n    }\n  }\n\n  /**\n   * Generate index file\n   */\n  private async generateIndexFile(): Promise<void> {\n    let content = '# Plugin Documentation\\n\\n';\n    content += 'This documentation describes the available plugins for the Site Generator.\\n\\n';\n    content += '## Available Plugins\\n\\n';\n\n    for (const plugin of this.plugins) {\n      content += `- [${plugin.name}](${plugin.name}.md): ${\n        plugin.description || 'No description'\n      }\\n`;\n    }\n\n    const filePath = path.join(this.outputDir, 'README.md');\n    await fs.promises.writeFile(filePath, content);\n  }\n\n  /**\n   * Generate documentation for a specific plugin\n   */\n  private async generatePluginDoc(plugin: Plugin): Promise<void> {\n    const doc: PluginDocumentation = {\n      name: plugin.name,\n      description: plugin.description || 'No description available.',\n      hooks: Object.keys(plugin.hooks || {}),\n      options: [],\n      examples: [],\n    };\n\n    // Extract options from plugin\n    if (plugin.options) {\n      for (const [name, option] of Object.entries(plugin.options)) {\n        doc.options.push({\n          name,\n          type: (option as any).type || 'any',\n          description: (option as any).description || 'No description available.',\n          required: (option as any).required || false,\n          default:\n            (option as any).default !== undefined ? String((option as any).default) : undefined,\n        });\n      }\n    }\n\n    // Generate markdown content\n    let content = `# ${doc.name} Plugin\\n\\n`;\n    content += `${doc.description}\\n\\n`;\n\n    // Hooks\n    content += '## Hooks\\n\\n';\n    if (doc.hooks.length > 0) {\n      for (const hook of doc.hooks) {\n        content += `- \\`${hook}\\`: ${this.getHookDescription(hook)}\\n`;\n      }\n    } else {\n      content += 'This plugin does not implement any hooks.\\n';\n    }\n    content += '\\n';\n\n    // Options\n    content += '## Options\\n\\n';\n    if (doc.options.length > 0) {\n      content += '| Option | Type | Description | Required | Default |\\n';\n      content += '|--------|------|-------------|----------|--------|\\n';\n\n      for (const option of doc.options) {\n        content += `| \\`${option.name}\\` | \\`${option.type}\\` | ${option.description} | ${\n          option.required ? 'Yes' : 'No'\n        } | ${option.default || '-'} |\\n`;\n      }\n    } else {\n      content += 'This plugin does not have any options.\\n';\n    }\n    content += '\\n';\n\n    // Examples\n    content += '## Examples\\n\\n';\n    if (doc.examples.length > 0) {\n      for (const example of doc.examples) {\n        content += '```javascript\\n';\n        content += example;\n        content += '\\n```\\n\\n';\n      }\n    } else {\n      content += 'No examples available.\\n';\n    }\n\n    const filePath = path.join(this.outputDir, `${plugin.name}.md`);\n    await fs.promises.writeFile(filePath, content);\n  }\n\n  /**\n   * Get description for a hook\n   */\n  private getHookDescription(hook: string): string {\n    const descriptions: Record<string, string> = {\n      beforeParse: 'Called before parsing content, allows modifying the raw content.',\n      afterParse: 'Called after parsing content, allows modifying the parsed content.',\n      beforeGenerate: 'Called before generating components, allows modifying the component data.',\n      afterGenerate:\n        'Called after generating components, allows modifying the generated components.',\n      beforeBuild: 'Called before building the website, allows modifying the build configuration.',\n      afterBuild: 'Called after building the website, allows performing post-build operations.',\n    };\n\n    return descriptions[hook] || 'No description available.';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/build.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/build.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/cms.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/cms.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/component.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[262,265],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[262,265],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DesignSystem } from './design';\nimport { ContentElement } from './cms';\n/**\n * Interface for component templates\n */\nexport interface ComponentTemplate {\n  name?: string;\n  path?: string;\n  content?: string;\n  type?: string;\n  metadata?: Record<string, any>;\n  generate?(element: ContentElement, designSystem: DesignSystem): Promise<string>;\n}\n/**\n * Configuration for a component\n */\nexport interface ComponentConfig {\n  name: string;\n  path: string;\n  content: string;\n  variables?: Record<string, unknown>;\n  dependencies?: string[];\n}\n/**\n * Design system configuration for a specific component type\n */\nexport interface ComponentDesignConfig {\n  classMapping: Record<string, string>;\n  components: string[];\n}\n/**\n * API endpoint definition for documentation\n */\nexport interface APIEndpoint {\n  method: string;\n  endpoint: string;\n  parameters?: Array<{\n    name: string;\n    type: string;\n    description: string;\n    required?: boolean;\n  }>;\n  responses?: Record<\n    string,\n    {\n      description: string;\n      example?: unknown;\n    }\n  >;\n}\n/**\n * Table component data structure\n */\nexport interface TableData {\n  headers: string[];\n  rows: string[][];\n}\n/**\n * Code block component data structure\n */\nexport interface CodeBlock {\n  language: string;\n  content: string[];\n  filename?: string;\n}\n/**\n * Section component data structure\n */\nexport interface Section {\n  title: string;\n  level: number;\n  content: ContentElement[];\n}\n/**\n * Navigation component data structure\n */\nexport interface Navigation {\n  items: Array<{\n    label: string;\n    path: string;\n    active?: boolean;\n    children?: Array<{\n      label: string;\n      path: string;\n      active?: boolean;\n    }>;\n  }>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/component.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[299,302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[299,302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Component generator types\n\nimport { DesignSystem } from './design.js';\nimport { ContentElement } from './cms.js';\n\n/**\n * Interface for component templates\n */\nexport interface ComponentTemplate {\n  name?: string;\n  path?: string;\n  content?: string;\n  type?: string;\n  metadata?: Record<string, any>;\n  generate?(element: ContentElement, designSystem?: DesignSystem): Promise<string>;\n}\n\n/**\n * Configuration for a component\n */\nexport interface ComponentConfig {\n  name: string;\n  path: string;\n  content: string;\n  variables?: Record<string, unknown>;\n  dependencies?: string[];\n}\n\n/**\n * Design system configuration for a specific component type\n */\nexport interface ComponentDesignConfig {\n  classMapping: Record<string, string>;\n  components: string[];\n}\n\n/**\n * API endpoint definition for documentation\n */\nexport interface APIEndpoint {\n  method: string;\n  endpoint: string;\n  parameters?: Array<{\n    name: string;\n    type: string;\n    description: string;\n    required?: boolean;\n  }>;\n  responses?: Record<\n    string,\n    {\n      description: string;\n      example?: unknown;\n    }\n  >;\n}\n\n/**\n * Table component data structure\n */\nexport interface TableData {\n  headers: string[];\n  rows: string[][];\n}\n\n/**\n * Code block component data structure\n */\nexport interface CodeBlock {\n  language: string;\n  content: string[];\n  filename?: string;\n}\n\n/**\n * Section component data structure\n */\nexport interface Section {\n  title: string;\n  level: number;\n  content: ContentElement[];\n}\n\n/**\n * Navigation component data structure\n */\nexport interface Navigation {\n  items: Array<{\n    label: string;\n    path: string;\n    active?: boolean;\n    children?: Array<{\n      label: string;\n      path: string;\n      active?: boolean;\n    }>;\n  }>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/design.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[545,548],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[545,548],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[685,688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[685,688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1083,1086],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1083,1086],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Design system configuration\n */\nexport interface DesignSystem {\n  /**\n   * Type of design system\n   */\n  type: 'material-ui' | 'chakra-ui' | 'custom';\n  /**\n   * Name of the design system\n   */\n  name?: string;\n  /**\n   * Path to import design system components from\n   */\n  importPath: string;\n  /**\n   * CSS class names for different elements\n   */\n  classNames?: Record<string, string>;\n  /**\n   * Components to be used in page templates\n   */\n  pageComponents?: string[];\n  /**\n   * Theme configuration\n   */\n  theme?: Record<string, any>;\n  /**\n   * Component configurations\n   */\n  components?: Record<\n    string,\n    {\n      import: string;\n      props?: Record<string, any>;\n    }\n  >;\n  /**\n   * Style configurations\n   */\n  styles?: {\n    global?: string;\n    components?: Record<string, string>;\n  };\n  /**\n   * Get configuration for a specific component type\n   */\n  getConfigForType?(elementType: string): {\n    classMapping: Record<string, string>;\n    components: string[];\n  };\n  /**\n   * Update theme configuration\n   */\n  updateTheme?(theme: Record<string, any>): void;\n}\n/**\n * Theme configuration for design system\n */\nexport interface ThemeConfig {\n  colors?: Record<string, string>;\n  typography?: {\n    fontFamilies?: Record<string, string>;\n    fontSizes?: Record<string, string>;\n    lineHeights?: Record<string, string | number>;\n  };\n  spacing?: Record<string, string | number>;\n  breakpoints?: Record<string, string | number>;\n  shadows?: Record<string, string>;\n}\n/**\n * Design system component configuration\n */\nexport interface DesignSystemComponentConfig {\n  import: string;\n  props?: Record<string, unknown>;\n  styles?: Record<string, unknown>;\n  variants?: Record<string, unknown>;\n}\n/**\n * Complete design system configuration\n */\nexport interface DesignSystemConfig {\n  type: 'material-ui' | 'chakra-ui' | 'custom';\n  theme?: ThemeConfig;\n  components?: Record<string, DesignSystemComponentConfig>;\n  utilities?: Record<string, string>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/design.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[574,577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[574,577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[694,697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[694,697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1076,1079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1076,1079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Design system types\n\n/**\n * Design system configuration\n */\nexport interface DesignSystem {\n  /**\n   * Type of design system\n   */\n  type: 'material-ui' | 'chakra-ui' | 'custom';\n\n  /**\n   * Name of the design system\n   */\n  name?: string;\n\n  /**\n   * Path to import design system components from\n   */\n  importPath: string;\n\n  /**\n   * CSS class names for different elements\n   */\n  classNames?: Record<string, string>;\n\n  /**\n   * Components to be used in page templates\n   */\n  pageComponents?: string[];\n\n  /**\n   * Theme configuration\n   */\n  theme?: Record<string, any>;\n\n  /**\n   * Component configurations\n   */\n  components?: Record<string, { import: string; props?: Record<string, any> }>;\n\n  /**\n   * Style configurations\n   */\n  styles?: { global?: string; components?: Record<string, string> };\n\n  /**\n   * Get configuration for a specific component type\n   */\n  getConfigForType?(elementType: string): {\n    classMapping: Record<string, string>;\n    components: string[];\n  };\n\n  /**\n   * Update theme configuration\n   */\n  updateTheme?(theme: Record<string, any>): void;\n}\n\n/**\n * Theme configuration for design system\n */\nexport interface ThemeConfig {\n  colors?: Record<string, string>;\n  typography?: {\n    fontFamilies?: Record<string, string>;\n    fontSizes?: Record<string, string>;\n    lineHeights?: Record<string, string | number>;\n  };\n  spacing?: Record<string, string | number>;\n  breakpoints?: Record<string, string | number>;\n  shadows?: Record<string, string>;\n}\n\n/**\n * Design system component configuration\n */\nexport interface DesignSystemComponentConfig {\n  import: string;\n  props?: Record<string, unknown>;\n  styles?: Record<string, unknown>;\n  variants?: Record<string, unknown>;\n}\n\n/**\n * Complete design system configuration\n */\nexport interface DesignSystemConfig {\n  type: 'material-ui' | 'chakra-ui' | 'custom';\n  theme?: ThemeConfig;\n  components?: Record<string, DesignSystemComponentConfig>;\n  utilities?: Record<string, string>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/handlebars.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[845,848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[845,848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[863,866],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[863,866],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[881,884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[881,884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[899,902],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[899,902],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[917,920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[917,920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[935,938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[935,938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[977,980],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[977,980],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1082,1085],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1082,1085],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1098,1101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1098,1101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1221,1224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1221,1224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1311,1314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1311,1314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1443,1446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1443,1446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1449,1452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1449,1452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1473,1476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1473,1476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1504,1507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1504,1507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1520,1523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1520,1523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1528,1531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1528,1531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1551,1554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1551,1554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1582,1585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1582,1585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1617,1620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1617,1620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// This file is used to resolve conflicts between @types/handlebars and handlebars/types\n// It provides a merged type definition that works with both\n\ndeclare module 'handlebars' {\n  import * as hbs from 'handlebars';\n  export = hbs;\n}\n\ndeclare namespace Handlebars {\n  interface KnownHelpers {\n    helperMissing?: boolean;\n    blockHelperMissing?: boolean;\n    each?: boolean;\n    if?: boolean;\n    unless?: boolean;\n    with?: boolean;\n    log?: boolean;\n    lookup?: boolean;\n  }\n\n  interface RuntimeOptions {\n    data?: boolean;\n    compat?: boolean;\n    knownHelpers?: KnownHelpers;\n    knownHelpersOnly?: boolean;\n    noEscape?: boolean;\n    strict?: boolean;\n    trackIds?: boolean;\n    preventIndent?: boolean;\n    ignoreStandalone?: boolean;\n    explicitPartialContext?: boolean;\n  }\n\n  interface HelperDelegate {\n    (\n      context?: any,\n      arg1?: any,\n      arg2?: any,\n      arg3?: any,\n      arg4?: any,\n      arg5?: any,\n      options?: HelperOptions\n    ): any;\n  }\n\n  interface HelperOptions {\n    fn: TemplateDelegate;\n    inverse: TemplateDelegate;\n    hash: any;\n    data?: any;\n  }\n\n  interface SafeString {\n    toString(): string;\n    toHTML(): string;\n  }\n\n  interface Template {\n    (context: any, options?: RuntimeOptions): string;\n  }\n\n  interface TemplateDelegate {\n    (context: any, options?: RuntimeOptions): string;\n  }\n\n  interface Utils {\n    escapeExpression(str: string): string;\n    createFrame(object: any): any;\n    isEmpty(value: any): boolean;\n    extend(obj: any, ...source: any[]): any;\n    toString(obj: any): string;\n    isArray(obj: any): boolean;\n    isFunction(obj: any): boolean;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/index.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2241,2244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2241,2244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export * from './cms';\nexport * from './component';\nexport * from './design';\nexport * from './parser';\nexport * from './plugin';\nexport interface GeneratorConfig {\n  outputFormat?: 'react' | 'next' | 'gatsby';\n  typescript?: boolean;\n  cssFramework?: 'css-modules' | 'styled-components' | 'emotion' | 'tailwind';\n  optimization?: {\n    minify?: boolean;\n    treeshake?: boolean;\n    splitChunks?: boolean;\n  };\n}\nexport interface ComponentTemplate {\n  name: string;\n  path: string;\n  content: string;\n  variables?: Record<string, unknown>;\n  dependencies?: string[];\n}\nexport interface DesignSystemConfig {\n  type: 'material-ui' | 'chakra-ui' | 'custom';\n  theme?: ThemeConfig;\n  components?: Record<string, ComponentConfig>;\n  utilities?: Record<string, string>;\n}\nexport interface ThemeConfig {\n  colors?: Record<string, string>;\n  typography?: {\n    fontFamilies?: Record<string, string>;\n    fontSizes?: Record<string, string>;\n    lineHeights?: Record<string, string | number>;\n  };\n  spacing?: Record<string, string | number>;\n  breakpoints?: Record<string, string | number>;\n  shadows?: Record<string, string>;\n}\nexport interface ComponentConfig {\n  import: string;\n  props?: Record<string, unknown>;\n  styles?: Record<string, unknown>;\n  variants?: Record<string, unknown>;\n}\nexport interface TestConfig {\n  framework: 'jest' | 'vitest';\n  coverage?: {\n    enabled: boolean;\n    threshold?: number;\n  };\n  patterns?: {\n    unit?: string[];\n    integration?: string[];\n    e2e?: string[];\n  };\n}\nexport interface BuildConfig {\n  target: 'development' | 'production' | 'preview';\n  outDir: string;\n  assets?: {\n    images?: {\n      optimize?: boolean;\n      formats?: string[];\n    };\n    fonts?: {\n      preload?: boolean;\n      formats?: string[];\n    };\n  };\n  optimization?: {\n    minify?: boolean;\n    treeshake?: boolean;\n    splitChunks?: boolean;\n  };\n}\nexport interface CMSConfig {\n  type: 'contentful' | 'strapi' | 'custom';\n  spaceId?: string;\n  accessToken?: string;\n  models?: Record<string, CMSModel>;\n}\nexport interface CMSModel {\n  type: string;\n  fields: Record<string, CMSField>;\n  relationships?: Record<string, CMSRelationship>;\n}\nexport interface CMSField {\n  type: string;\n  required?: boolean;\n  defaultValue?: any;\n  validations?: Record<string, unknown>;\n}\nexport interface CMSRelationship {\n  type: 'oneToOne' | 'oneToMany' | 'manyToOne' | 'manyToMany';\n  target: string;\n  inversedBy?: string;\n  required?: boolean;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/openapi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/plugin.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[339,342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[339,342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PluginOptions } from './index.js';\n\n/**\n * Interface for plugins\n */\nexport interface Plugin {\n  /**\n   * Name of the plugin\n   */\n  name: string;\n\n  /**\n   * Description of the plugin\n   */\n  description?: string;\n\n  /**\n   * Plugin options\n   */\n  options: PluginOptions;\n\n  /**\n   * Plugin hooks\n   */\n  hooks?: Record<string, any>;\n\n  /**\n   * Initialize the plugin\n   */\n  initialize(): void;\n\n  /**\n   * Process content\n   * @param content Content to process\n   */\n  processContent(content: string): string;\n\n  /**\n   * Process HTML\n   * @param html HTML to process\n   */\n  processHtml(html: string): string;\n\n  /**\n   * Get plugin assets\n   */\n  getAssets(): string[];\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/types/workbox.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":4,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[136,139],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[136,139],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[228,231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[228,231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// This file provides missing type definitions for workbox-core\n\ninterface ExtendableEvent extends Event {\n  waitUntil(promise: Promise<any>): void;\n}\n\ninterface ExtendableMessageEvent extends ExtendableEvent {\n  readonly data: any;\n  readonly lastEventId: string;\n  readonly origin: string;\n  readonly ports: ReadonlyArray<MessagePort>;\n  readonly source: Client | ServiceWorker | MessagePort | null;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/config-presets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/config-validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/dependency-graph.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/dev-server-class.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/dev-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/errors.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[278,281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[278,281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[355,358],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[355,358],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1207,1210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1207,1210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1450,1453],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1450,1453],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1696,1699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1696,1699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1940,1943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1940,1943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2168,2171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2168,2171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2416,2419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2416,2419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2648,2651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2648,2651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2884,2887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2884,2887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":116,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3122,3125],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3122,3125],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_promise' is defined but never used.","line":144,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":144,"endColumn":53},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":169,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4477,4480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4477,4480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from './utils/logger.js';\n\n/**\n * Base error class for all site generator errors\n * Provides standardized error handling with error codes and contextual information\n */\nexport class SiteGeneratorError extends Error {\n  code: string;\n  context?: Record<string, any>;\n\n  constructor(message: string, code: string, context?: Record<string, any>) {\n    super(message);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.context = context;\n\n    // Capture stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  /**\n   * Returns a formatted error message with context information\n   */\n  getFormattedMessage(): string {\n    let message = `[${this.code}] ${this.message}`;\n\n    if (this.context && Object.keys(this.context).length > 0) {\n      message += '\\nContext:';\n      for (const [key, value] of Object.entries(this.context)) {\n        message += `\\n  ${key}: ${JSON.stringify(value)}`;\n      }\n    }\n\n    return message;\n  }\n}\n\n/**\n * Error thrown when there's an issue with configuration\n */\nexport class ConfigurationError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, any>) {\n    super(message, 'CONFIG_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with parsing documentation\n */\nexport class ParserError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, any>) {\n    super(message, 'PARSER_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with generating components\n */\nexport class GeneratorError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, any>) {\n    super(message, 'GENERATOR_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with building the website\n */\nexport class BuildError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, any>) {\n    super(message, 'BUILD_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with plugins\n */\nexport class PluginError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, any>) {\n    super(message, 'PLUGIN_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with file system operations\n */\nexport class FileSystemError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, any>) {\n    super(message, 'FS_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when a feature is not implemented\n */\nexport class NotImplementedError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, any>) {\n    super(message, 'NOT_IMPLEMENTED', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with templates\n */\nexport class TemplateError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, any>) {\n    super(message, 'TEMPLATE_ERROR', context);\n  }\n}\n\n/**\n * Error thrown when there's an issue with validation\n */\nexport class ValidationError extends SiteGeneratorError {\n  constructor(message: string, context?: Record<string, any>) {\n    super(message, 'VALIDATION_ERROR', context);\n  }\n}\n\n/**\n * Global error handler for uncaught exceptions\n */\nexport function setupGlobalErrorHandler(verbose = false): void {\n  process.on('uncaughtException', error => {\n    logger.error('\\n Uncaught Exception:');\n\n    if (error instanceof SiteGeneratorError) {\n      logger.error(error.getFormattedMessage());\n    } else {\n      logger.error(`[UNKNOWN_ERROR] ${error.message}`);\n    }\n\n    if (verbose) {\n      logger.error('\\nStack Trace:');\n      logger.error(error.stack);\n    } else {\n      logger.error('\\nRun with --verbose flag for more details.');\n    }\n\n    process.exit(1);\n  });\n\n  process.on('unhandledRejection', (reason, _promise) => {\n    logger.error('\\n Unhandled Promise Rejection:');\n\n    if (reason instanceof SiteGeneratorError) {\n      logger.error(reason.getFormattedMessage());\n    } else {\n      logger.error(`[UNHANDLED_REJECTION] ${reason}`);\n    }\n\n    if (verbose) {\n      logger.error('\\nStack Trace:');\n      logger.error((reason as Error).stack);\n    } else {\n      logger.error('\\nRun with --verbose flag for more details.');\n    }\n\n    process.exit(1);\n  });\n}\n\n/**\n * Error handler for async functions\n * @param fn Async function to wrap with error handling\n * @returns Wrapped function with error handling\n */\nexport function withErrorHandling<T extends any[], R>(\n  fn: (...args: T) => Promise<R>\n): (...args: T) => Promise<R> {\n  return async (...args: T): Promise<R> => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      if (error instanceof SiteGeneratorError) {\n        throw error;\n      } else {\n        throw new SiteGeneratorError(\n          (error as Error).message || 'Unknown error occurred',\n          'INTERNAL_ERROR',\n          { originalError: error }\n        );\n      }\n    }\n  };\n}\n\n/**\n * Try-catch wrapper for async functions\n * @param fn Function to execute\n * @param errorHandler Optional error handler\n * @returns Result of the function or error handler\n */\nexport async function tryCatch<T>(\n  fn: () => Promise<T>,\n  errorHandler?: (error: unknown) => T | Promise<T>\n): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (errorHandler) {\n      return await errorHandler(error);\n    }\n    throw error;\n  }\n}\n\n/**\n * Try-catch wrapper for sync functions\n * @param fn Function to execute\n * @param errorHandler Optional error handler\n * @returns Result of the function or error handler\n */\nexport function tryCatchSync<T>(fn: () => T, errorHandler?: (error: unknown) => T): T {\n  try {\n    return fn();\n  } catch (error) {\n    if (errorHandler) {\n      return errorHandler(error);\n    }\n    throw error;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/file-watcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/incremental.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/monemnaifer/Library/CloudStorage/GoogleDrive-monemmacos@gmail.com/My Drive/Strategic AI Integration/Site_Generator/src/utils/performance.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2644,2647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2644,2647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from './utils/logger.js';\n\ninterface PerformanceEntry {\n  name: string;\n  startTime: number;\n  endTime: number;\n  duration: number;\n}\n\nexport class PerformanceMonitor {\n  private entries: PerformanceEntry[] = [];\n  private activeMarks: Map<string, number> = new Map();\n\n  /**\n   * Start timing an operation\n   */\n  mark(name: string): void {\n    this.activeMarks.set(name, Date.now());\n  }\n\n  /**\n   * End timing an operation and record the duration\n   */\n  measure(name: string): PerformanceEntry | undefined {\n    const startTime = this.activeMarks.get(name);\n    if (!startTime) {\n      logger.warn(`No mark found for: ${name}`);\n      return undefined;\n    }\n\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n\n    const entry: PerformanceEntry = {\n      name,\n      startTime,\n      endTime,\n      duration,\n    };\n\n    this.entries.push(entry);\n    this.activeMarks.delete(name);\n\n    return entry;\n  }\n\n  /**\n   * Get all performance entries\n   */\n  getEntries(): PerformanceEntry[] {\n    return [...this.entries];\n  }\n\n  /**\n   * Get entries for a specific operation\n   */\n  getEntriesByName(name: string): PerformanceEntry[] {\n    return this.entries.filter(entry => entry.name === name);\n  }\n\n  /**\n   * Calculate average duration for an operation\n   */\n  getAverageDuration(name: string): number {\n    const entries = this.getEntriesByName(name);\n    if (entries.length === 0) return 0;\n\n    const totalDuration = entries.reduce((sum, entry) => sum + entry.duration, 0);\n    return totalDuration / entries.length;\n  }\n\n  /**\n   * Clear all entries\n   */\n  clear(): void {\n    this.entries = [];\n    this.activeMarks.clear();\n  }\n\n  /**\n   * Generate a performance report\n   */\n  generateReport(): string {\n    const operations = new Set(this.entries.map(entry => entry.name));\n    let report = 'Performance Report\\n';\n    report += '=================\\n\\n';\n\n    for (const operation of operations) {\n      const entries = this.getEntriesByName(operation);\n      const avgDuration = this.getAverageDuration(operation);\n      const minDuration = Math.min(...entries.map(e => e.duration));\n      const maxDuration = Math.max(...entries.map(e => e.duration));\n\n      report += `Operation: ${operation}\\n`;\n      report += `  Count: ${entries.length}\\n`;\n      report += `  Average: ${avgDuration.toFixed(2)}ms\\n`;\n      report += `  Min: ${minDuration}ms\\n`;\n      report += `  Max: ${maxDuration}ms\\n\\n`;\n    }\n\n    return report;\n  }\n\n  /**\n   * Create a performance decorator for class methods\n   */\n  static createMethodDecorator() {\n    return function performanceDecorator(\n      _target: any,\n      propertyKey: string,\n      descriptor: PropertyDescriptor\n    ) {\n      const originalMethod = descriptor.value;\n\n      descriptor.value = function (...args: unknown[]) {\n        const className = this.constructor.name;\n        const methodName = propertyKey;\n        const operationName = `${className}.${methodName}`;\n\n        performance.mark(operationName);\n\n        try {\n          const result = originalMethod.apply(this, args);\n\n          // Handle promises\n          if (result instanceof Promise) {\n            return result.finally(() => {\n              performance.measure(operationName);\n            });\n          }\n\n          performance.measure(operationName);\n          return result;\n        } catch (error) {\n          performance.measure(operationName);\n          throw error;\n        }\n      };\n\n      return descriptor;\n    };\n  }\n}\n\n// Global performance monitor instance\nexport const performance = new PerformanceMonitor();\n","usedDeprecatedRules":[]}]
